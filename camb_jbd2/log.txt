base_planck_lowl_lowLike.ini:helium_fraction=0.2476949
base_plikHM_TT_lowTEB_lensing.ini:helium_fraction=0.245352
bdphi_plot.py:plot(a,weff,label = "Traditional")
bdphi_plot.py~:plot(a,weff,label = "Traditional")
bessels.f90:!CAMB spherical and hyperspherical Bessel function routines
bessels.f90:!This version May 2006 - minor changes to bjl (http://cosmocoffee.info/viewtopic.php?t=530)
bessels.f90:!Feb 2009: minor fix for non-flat compiled with non-smart IF evaluation
bessels.f90:!Flat bessel function module
bessels.f90:        use Precision
bessels.f90:!     Bessel functions and their second derivatives for interpolation
bessels.f90:        real(dl), dimension(:,:), allocatable ::  ajl,ajlpr, ddajlpr
bessels.f90:!      parameters for working out where the flat Bessel functions are small
bessels.f90:        Type(Regions):: BessRanges
bessels.f90:!     get the interpolation matrix for bessel functions
bessels.f90:        !!== MODIFIED SUBROUTINE FOR SPHERICAL BESSEL FUNCTIONS.                       ==!!
bessels.f90:        real(dl),parameter::GAMMA1 =   2.6789385347077476336556D0 !/* Gamma function of 1/3 */
bessels.f90:        real(dl),parameter::GAMMA2 =   1.3541179394264004169452D0 !/* Gamma function of 2/3 */
bessels.f90:            write(*,*) 'Can not evaluate Spherical Bessel Function with index l<0'
bessels.f90:                !          /**************** Region 2: x >> l ****************/
bessels.f90:                !          /***************** Region 3: x near l ****************/
bessels.f90:! Calculation of ultraspherical Bessel functions.                      c
bessels.f90:! Fortran version of the c program hyperjl.c by Arthur Kosowsky.       c
bessels.f90:! Modifications by Anthony Challinor and Antony Lewis                  c
bessels.f90:! Minor modifications to correct K=1 case outside [0,pi],              c
bessels.f90:! the small chi approximations for lSamp%l=0 and lSamp%l=1, and                    c
bessels.f90:! the quadratic approximation to Q(x) around Q(x)=0.                   c
bessels.f90:! Bug fixed in downwards recursion (phi_recurs)                        c
bessels.f90:! The routine phi_recurs uses recursion relations to calculate         c
bessels.f90:! the functions, which is accurate but relatively slow.                c  
bessels.f90:! uniform first-order asymptotic approximation in the open, closed     c
bessels.f90:! and flat cases. This approximation is EXCELLENT for all lSamp%l >= 3.      c
bessels.f90:! to the eikonal integral used in the WKB approximation.               c
bessels.f90:! The routine airy_ai returns the Airy function Ai(x) of the argument  c
bessels.f90:! passed. It employs a Pade-type approximation away from zero and      c
bessels.f90:! a Taylor expansion around zero. Highly accurate.                     c
bessels.f90:! evaluation routines used in the airy function calculation.           c
bessels.f90:! use Precision
bessels.f90:!Deep in the tails the closed recursion relation is not stable
bessels.f90:             !use recursive evaluation where WKB is poor and recurs is fast anyway.
bessels.f90:!by integrating up the differential equation and normalizing to phi_recurs
bessels.f90:!in the region in which phi_recurs is stable
bessels.f90:!This allows closed functions to be computed where chi << turning point
bessels.f90: !Series solution
bessels.f90:! One step in the ujl integration
bessels.f90:! fourth-order Runge-Kutta method to integrate equation for ujl
bessels.f90:! One step in the ujl integration
bessels.f90:! fourth-order Runge-Kutta method to integrate equation for ujl
bessels.f90:! Calculates Phi(l,beta,chi) using recursion on l.                     *
bessels.f90:! recursion relations and closed-form expressions for l=0,1.           *
bessels.f90:! When the flag direction is negative, downwards recursion on l        *
bessels.f90:! must be used because the upwards direction is unstable to roundoff   *
bessels.f90:! errors. The downwards recursion begins with arbitrary values and     *
bessels.f90:! using the closed form solution for l=1. (See, e.g., Numerical        *
bessels.f90:! Recipes of Bessel functions for more detail)                         *
bessels.f90:  function phi_recurs(l, K, beta, chi)
bessels.f90:  integer j, direction, lstart,ibeta
bessels.f90:     write(*,*) "Bessel function index ell < 0"
bessels.f90:  ! Closed form solution for l=0
bessels.f90:     ! Closed form solution for l=1
bessels.f90:     ! Find recursion direction
bessels.f90:     !  direction = +1 for upward recursion, -1 for downward
bessels.f90:        direction = 1
bessels.f90:        direction = -1
bessels.f90:     ! For K=1, must do upwards recursion:
bessels.f90:     if(K==1) direction = 1
bessels.f90:     ! Do upwards recursion on l
bessels.f90:     if(direction == 1)then
bessels.f90:        ! Do downwards recursion on l
bessels.f90:   end function phi_recurs
bessels.f90:! Calculates Phi(l,beta,chi) using the Langer uniform approximation    c
bessels.f90:! to the first-order WKB approximation.                                c
bessels.f90:! Differential equation for needed function can be cast into the       c
bessels.f90:! In the K= +1 case, the function is                                   c
bessels.f90:! conditions Phi(chi + pi) = (-1)^{beta - l - 1} Phi(chi),             c
bessels.f90:! Note that the second condition at chi = pi/2 gives an eigenvalue     c
bessels.f90:! condition on beta, which  must corrected. For the lowest             c
bessels.f90:! eigenvalue(s), the region between the turning points is not large    c
bessels.f90:! enough for the asymptotic solution to be valid, so the functions     c
bessels.f90:! The exact eigenvalue condition requires that beta must be an         c
bessels.f90:      function phi_langer(l,K,beta,chi)
bessels.f90:         write(*,*) "Bessel function index ell < 0"
bessels.f90:! Definitions
bessels.f90:! Closed form solution for l=0
bessels.f90:! Closed form solution for l=1
bessels.f90:! Closed form solution for K=1 and beta = l+1 (lowest eigenfunction)
bessels.f90:! Function in question has only a single simple turning point.
bessels.f90:! Calculate coefficients of linear and quadratic terms in Q(x) expansion
bessels.f90:! x>0 is the evanescent region
bessels.f90:! Argument of Airy function
bessels.f90:! Evaluate Airy function
bessels.f90:! Rest of functional dependence
bessels.f90:!  Normalization factor:
bessels.f90:! Langer approximation.
bessels.f90:      end function phi_langer
bessels.f90:! Evaluates the exact solution to  the integral giving the WKB          c
bessels.f90:! eikonal solution,   \int^x sqrt(abs(Q(x))) dx                         c
bessels.f90:! and a log; its evaluation will be roughly as expensive as the rest    c
bessels.f90:! region of the integrand contains a log and an atan, so at best a fit  c
bessels.f90:! can only save the computation of the square roots.                    c
bessels.f90:! The integrals are very bland functions of chi and alpha and could     c
bessels.f90:! be precomputed and cached to save computation time; interpolation     c
bessels.f90:      function qintegral(sin_K,alpha, K)
bessels.f90:      end function qintegral 
bessels.f90:!       Airy function                                                  c
bessels.f90:! Modifications: eliminates calculation of Bi(x), Ai'(x), Bi'(x)       c
bessels.f90:! and translation to Fortran                                           c
bessels.f90:! DESCRIPTION:
bessels.f90:! Solution of the differential equation
bessels.f90:! The function returns the two independent solutions Ai, Bi
bessels.f90:! Evaluation is by power series summation for small x,
bessels.f90:! by rational minimax approximations for large x.
bessels.f90:! Error criterion is absolute when function <= 1, relative
bessels.f90:! when function > 1, except * denotes relative error criterion.
bessels.f90:! Arithmetic  domain   function  # trials      peak         rms
bessels.f90:      function airy_ai(x)
bessels.f90:! Taylor series for region around x=0
bessels.f90:      end function airy_ai
bessels.f90:! DESCRIPTION:
bessels.f90:! The function p1evl() assumes that C = 1.0 and is
bessels.f90:! the functions in the library.  Depending on available
bessels.f90:      function polevl(x,coef,N)
bessels.f90:      dimension coef(N+1)
bessels.f90:      end function polevl
bessels.f90:      function p1evl(x,coef,N)
bessels.f90:      dimension coef(N)
bessels.f90:      end function p1evl
bessels.f90:        use Precision
bessels.f90:        !!== MODIFIED SUBROUTINE FOR SPHERICAL BESSEL FUNCTIONS.                       ==!!
Binary file camb matches
camb.cbp:<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
camb.cbp:	<FileVersion major="1" minor="6" />
camb.cbp:		<Option title="camb" />
camb.cbp:		<Option makefile_is_custom="1" />
camb.cbp:		<Option pch_mode="2" />
camb.cbp:		<Option compiler="gfortran" />
camb.cbp:		<Option virtualFolders="makefile/;" />
camb.cbp:				<Option output="camb" prefix_auto="1" extension_auto="1" />
camb.cbp:				<Option object_output="Debug/" />
camb.cbp:				<Option type="1" />
camb.cbp:				<Option compiler="gfortran" />
camb.cbp:				<Option parameters="params.ini" />
camb.cbp:					<Add option="-Wall" />
camb.cbp:					<Add option="-g" />
camb.cbp:				<Option output="camb" prefix_auto="1" extension_auto="1" />
camb.cbp:				<Option object_output="Release/" />
camb.cbp:				<Option type="1" />
camb.cbp:				<Option compiler="gfortran" />
camb.cbp:				<Option parameters="params.ini" />
camb.cbp:					<Add option="-Wall" />
camb.cbp:					<Add option="-O2" />
camb.cbp:					<Add option="-s" />
camb.cbp:			<Option virtualFolder="makefile/" />
camb.cbp:			<Option virtualFolder="makefile/" />
camb.cbp:			<Option weight="3" />
camb.cbp:			<Option weight="6" />
camb.cbp:			<Option weight="5" />
camb.cbp:			<Option weight="0" />
camb.cbp:		<Unit filename="equations.f90">
camb.cbp:			<Option weight="3" />
camb.cbp:			<Option weight="4" />
camb.cbp:			<Option weight="0" />
camb.cbp:			<Option weight="3" />
camb.cbp:			<Option weight="2" />
camb.cbp:			<Option weight="1" />
camb.cbp:			<Option weight="1" />
camb.cbp:		<Unit filename="reionization.f90">
camb.cbp:			<Option weight="1" />
camb.cbp:			<Option weight="1" />
camb.cbp:		<Extensions>
camb.cbp:			<code_completion />
camb.cbp:		</Extensions>
camb.f90:    use Precision
camb.f90:    use Reionization
camb.f90:    use Recombination
camb.f90:    integer, optional :: error !Zero if OK
camb.f90:    logical :: InReionization
camb.f90:    InReionization = Params%Reion%Reionization
camb.f90:            P%Transfer%high_precision = .false.
camb.f90:        CP%Transfer%high_precision = Params%Transfer%high_precision
camb.f90:        P%Transfer%high_precision = .false.
camb.f90:        CP%Transfer%high_precision = Params%Transfer%high_precision
camb.f90:        P%Transfer%high_precision = .false.
camb.f90:        CP%Transfer%high_precision = Params%Transfer%high_precision
camb.f90:        CP%Reion%Reionization = InReionization
camb.f90:    !Return real (NOT double precision) arrays of the computed CMB  Cls
camb.f90:    !If GC_Conventions = .false. use E-B conventions (as the rest of CAMB does)
camb.f90:    subroutine CAMB_GetCls(Cls, lmax, in, GC_conventions)
camb.f90:    logical, intent(IN) :: GC_conventions
camb.f90:    if (GC_conventions) then
camb.f90:    function CAMB_GetAge(P)
camb.f90:    end function CAMB_GetAge
camb.f90:    function CAMB_GetZreFromTau(P, tau)
camb.f90:    P%Reion%use_optical_depth = .true.
camb.f90:    P%Reion%optical_depth = tau
camb.f90:    CAMB_GetZreFromTau = CP%Reion%redshift
camb.f90:    end function CAMB_GetZreFromTau
camb.f90:    P%Scalar_initial_condition =initial_adiabatic
camb.f90:    call Recombination_SetDefParams(P%Recomb)
camb.f90:    call Reionization_SetDefParams(P%Reion)
camb.f90:    P%Transfer%high_precision=.false.
camb.f90:    P%OutputNormalization = outNone
camb.f90:    P%AccuratePolarization = .true.
camb.f90:    P%AccurateReionization = .false.
camb.f90:    function CAMB_ValidateParams(P) result(OK)
camb.f90:        write(*,*) 'There is nothing to do! Do transfer functions or Cls.'
camb.f90:        '  Warning: YHe is the Helium fraction of baryons.', &
camb.f90:    call Reionization_Validate(P%Reion, OK)
camb.f90:    call Recombination_Validate(P%Recomb, OK)
camb.f90:            write(*,*) 'Strange transfer function settings.'
camb.f90:    end function CAMB_ValidateParams
camb.f90~:    use Precision
camb.f90~:    use Reionization
camb.f90~:    use Recombination
camb.f90~:    integer, optional :: error !Zero if OK
camb.f90~:    logical :: InReionization
camb.f90~:    InReionization = Params%Reion%Reionization
camb.f90~:            P%Transfer%high_precision = .false.
camb.f90~:        CP%Transfer%high_precision = Params%Transfer%high_precision
camb.f90~:        P%Transfer%high_precision = .false.
camb.f90~:        CP%Transfer%high_precision = Params%Transfer%high_precision
camb.f90~:        P%Transfer%high_precision = .false.
camb.f90~:        CP%Transfer%high_precision = Params%Transfer%high_precision
camb.f90~:        CP%Reion%Reionization = InReionization
camb.f90~:    !Return real (NOT double precision) arrays of the computed CMB  Cls
camb.f90~:    !If GC_Conventions = .false. use E-B conventions (as the rest of CAMB does)
camb.f90~:    subroutine CAMB_GetCls(Cls, lmax, in, GC_conventions)
camb.f90~:    logical, intent(IN) :: GC_conventions
camb.f90~:    if (GC_conventions) then
camb.f90~:    function CAMB_GetAge(P)
camb.f90~:    end function CAMB_GetAge
camb.f90~:    function CAMB_GetZreFromTau(P, tau)
camb.f90~:    P%Reion%use_optical_depth = .true.
camb.f90~:    P%Reion%optical_depth = tau
camb.f90~:    CAMB_GetZreFromTau = CP%Reion%redshift
camb.f90~:    end function CAMB_GetZreFromTau
camb.f90~:    P%Scalar_initial_condition =initial_adiabatic
camb.f90~:    call Recombination_SetDefParams(P%Recomb)
camb.f90~:    call Reionization_SetDefParams(P%Reion)
camb.f90~:    P%Transfer%high_precision=.false.
camb.f90~:    P%OutputNormalization = outNone
camb.f90~:    P%AccuratePolarization = .true.
camb.f90~:    P%AccurateReionization = .false.
camb.f90~:    function CAMB_ValidateParams(P) result(OK)
camb.f90~:        write(*,*) 'There is nothing to do! Do transfer functions or Cls.'
camb.f90~:        '  Warning: YHe is the Helium fraction of baryons.', &
camb.f90~:    call Reionization_Validate(P%Reion, OK)
camb.f90~:    call Recombination_Validate(P%Recomb, OK)
camb.f90~:            write(*,*) 'Strange transfer function settings.'
camb.f90~:    end function CAMB_ValidateParams
cmbmain.f90:    !     See readme.html for documentation.
cmbmain.f90:    !     REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPlIED.
cmbmain.f90:    !     By way of example, but not limitation,
cmbmain.f90:    !     M.I.T. AND C.f.A MAKE NO REPRESENTATIONS OR WARRANTIES OF
cmbmain.f90:    !     THE USE OF THE lICENSED SOFTWARE OR DOCUMENTATION WIll NOT INFRINGE
cmbmain.f90:    !     portions of this software are based on the COSMICS package of
cmbmain.f90:    !     E. Bertschinger.  See the lICENSE file of the COSMICS distribution
cmbmain.f90:    !     for restrictions on the modification and distribution of this software.
cmbmain.f90:    !     This code evolves the linearized perturbation equations of general relativity,
cmbmain.f90:    !     the Boltzmann equations and the fluid equations for perturbations
cmbmain.f90:    !     of a Friedmann-Robertson-Walker universe with a supplied system of gauge-dependent equation
cmbmain.f90:    !     computed at sampled times during the evolution for various of wavenumbers. The sources
cmbmain.f90:    !     For CP%flat models the bessel functions are interpolated from a pre-computed table, for
cmbmain.f90:    !     non-CP%flat models the hyperspherical Bessel functions are computed by integrating their
cmbmain.f90:    !     differential equation. Both phases ('Evolution' and 'Integration') can do separate
cmbmain.f90:    !    EV = Time evolution variables
cmbmain.f90:    !    IV = Source integration variables
cmbmain.f90:    ! perturbation equations, and InitialPower which provides the initial power spectrum.
cmbmain.f90:    use precision
cmbmain.f90:    use EFTinitialization
cmbmain.f90:    !Variables for integrating the sources with the bessel functions for each wavenumber
cmbmain.f90:    type IntegrationVars
cmbmain.f90:        !        real(dl), dimension(:,:), pointer :: Delta_l_q
cmbmain.f90:        !Contribution to C_l integral from this k
cmbmain.f90:        real(dl), dimension(:,:), pointer :: Source_q, ddSource_q
cmbmain.f90:    end type IntegrationVars
cmbmain.f90:    real(dl), dimension(:,:,:), allocatable :: Src, ddSrc !Sources and second derivs
cmbmain.f90:    real(dl), dimension(:,:,:), allocatable :: iCl_scalar, iCl_vector, iCl_tensor
cmbmain.f90:    real(dl), dimension(:,:,:,:), allocatable :: iCl_Array
cmbmain.f90:    ! values of q to evolve the propagation equations to compute the sources
cmbmain.f90:    Type(Regions) :: Evolve_q
cmbmain.f90:    integer :: l_smooth_sample = 3000 !assume transfer functions effectively small for k>2*l_smooth_sample
cmbmain.f90:    type(EvolutionVars) EV
cmbmain.f90:            call EFTCAMB_initialization(EFTsuccess)
cmbmain.f90:            !I HAVE ALREADY CALLED IT IN EQUATIONS_EFT.F90
cmbmain.f90:    !Calculation of the CMB sources.
cmbmain.f90:    !***note that !$ is the prefix for conditional multi-processor compilation***
cmbmain.f90:            write(*,*) actual-timeprev,' Timing for source calculation'
cmbmain.f90:    ! If transfer functions are requested, set remaining k values and output
cmbmain.f90:    !     if CMB calculations are requested, calculate the Cl by
cmbmain.f90:            call InitSourceInterpolation
cmbmain.f90:            if (DebugMsgs .and. Feedbacklevel > 0) write(*,*) 'Set ',ThisCT%q%npoints,' integration k values'
cmbmain.f90:                write(*,*)actual-timeprev,' Timing For Integration'
cmbmain.f90:        !Final calculations for CMB output unless want the Cl transfer functions only.
cmbmain.f90:    if (CP%OutputNormalization >=2) call NormalizeClsAtl(CP%OutputNormalization)
cmbmain.f90:    !Normalize to C_l=1 at l=OutputNormalization
cmbmain.f90:    type(IntegrationVars) :: IV
cmbmain.f90:    call IntegrationVars_init(IV)
cmbmain.f90:    call DoSourceIntegration(IV)
cmbmain.f90:    real(dl), dimension(:), allocatable :: q_transfer
cmbmain.f90:        !Linear spacing for horizon scales and first few baryon osciallations
cmbmain.f90:        !Log spacing for last few oscillations
cmbmain.f90:        if (CP%Transfer%high_precision) boost = boost*1.5
cmbmain.f90:    function GetTauStart(q)
cmbmain.f90:    !     Conformal time (in Mpc) in the radiation era, for photons plus 3 species
cmbmain.f90:    !     Make sure to start early in the radiation era.
cmbmain.f90:    end function GetTauStart
cmbmain.f90:    type(EvolutionVars) EV
cmbmain.f90:    use precision
cmbmain.f90:    !     Timesteps during recombination (tentative, the actual
cmbmain.f90:    !     where taurst is the time when recombination starts - see inithermo
cmbmain.f90:    !AL:Changed Dec 2003, dtaurec feeds back into the non-flat integration via the step size
cmbmain.f90:    !     Initialize baryon temperature and ionization fractions vs. time.
cmbmain.f90:    !     saved in order to do the integration. So TimeSteps is set here.
cmbmain.f90:    !Do any array initialization for propagation equations
cmbmain.f90:    !     Calculating the times for the outputs of the transfer functions.
cmbmain.f90:    !     polarization will be calculated. For low values of k we
cmbmain.f90:    if (CP%WantScalars .and. CP%Reion%Reionization .and. CP%AccuratePolarization) then
cmbmain.f90:        !Need this to get accurate low l polarization
cmbmain.f90:    if (CP%AccurateReionization) dlnk0 = dlnk0/2
cmbmain.f90:    if (CP%Want_CMB .and. maximum_l > 5000 .and. CP%AccuratePolarization) q_cmb = q_cmb*1.4
cmbmain.f90:    Type(Regions) :: R
cmbmain.f90:        !quantization is important
cmbmain.f90:    type(EvolutionVars) EV
cmbmain.f90:        !evolution output
cmbmain.f90:        ! EFTCAMB MOD START: It's always nice to plot the evolution of perturbations in DE/MG models!
cmbmain.f90:            call CreateTxtFile('Results/Debug_Evolution/Files/1_FRW.dat',1)
cmbmain.f90:            call CreateTxtFile('Results/Debug_Evolution/Files/2_EFTfunctions.dat',2)
cmbmain.f90:            call CreateTxtFile('Results/Debug_Evolution/Files/3_EFTBackground.dat',3)
cmbmain.f90:            call CreateTxtFile('Results/Debug_Evolution/Files/4_PiFieldSolution.dat',4)
cmbmain.f90:            call CreateTxtFile('Results/Debug_Evolution/Files/5_MetricSolution.dat',5)
cmbmain.f90:            call CreateTxtFile('Results/Debug_Evolution/Files/6_DensitySolution.dat',6)
cmbmain.f90:            call CreateTxtFile('Results/Debug_Evolution/Files/7_EinsteinEqFactors.dat',7)
cmbmain.f90:            call CreateTxtFile('Results/Debug_Evolution/Files/8_PiEqFactors.dat',8)
cmbmain.f90:            call CreateTxtFile('Results/Debug_Evolution/Files/9_Sources.dat',9)
cmbmain.f90:            call CreateTxtFile('Results/Debug_Evolution/Files/10_MuGamma.dat',10)
cmbmain.f90:        !!Example code for plotting out variable evolution
cmbmain.f90:    if (CP%WantTransfer .and. CP%Transfer%high_precision) tol1=tol1/100
cmbmain.f90:        if (.not. DebugEvolution .and. (EV%q*tauend > max_etak_scalar .and. tauend > taurend) &
cmbmain.f90:            !     Calculation of transfer functions.
cmbmain.f90:                !     output transfer functions for this k-value.
cmbmain.f90:    type(EvolutionVars) EV
cmbmain.f90:    type(EvolutionVars) EV
cmbmain.f90:    !!Example code for plotting out variable evolution
cmbmain.f90:    !Output transfer functions for k larger than used for C_l computation
cmbmain.f90:    type(EvolutionVars) EV
cmbmain.f90:    type(EvolutionVars) EV
cmbmain.f90:            if (CP%Transfer%high_precision) atol=atol
cmbmain.f90:            if (CP%Transfer%high_precision) atol=atol/10000
cmbmain.f90:        ! if (CP%Transfer%high_precision) atol=atol/10000
cmbmain.f90:    subroutine InitSourceInterpolation
cmbmain.f90:    !     get the interpolation matrix for the sources to interpolate them
cmbmain.f90:    end subroutine InitSourceInterpolation
cmbmain.f90:    !     Fixing the # of k for the integration.
cmbmain.f90:                !This allows inclusion of high k modes for computing BB lensed spectrum accurately
cmbmain.f90:    type(IntegrationVars) IV
cmbmain.f90:    !     finding position of k in table Evolve_q to do the interpolation.
cmbmain.f90:    !Can't use the following in closed case because regions are not set up (only points)
cmbmain.f90:    !     Interpolating the source as a function of time for the present
cmbmain.f90:            if ((DebugEvolution .or. WantLateTime .or. IV%q*TimeSteps%points(i) < max_etak_scalar) &
cmbmain.f90:    subroutine IntegrationVars_Init(IV)
cmbmain.f90:    type(IntegrationVars), intent(INOUT) :: IV
cmbmain.f90:    end  subroutine IntegrationVars_Init
cmbmain.f90:    subroutine DoSourceIntegration(IV) !for particular wave number q
cmbmain.f90:    type(IntegrationVars) IV
cmbmain.f90:        call DoFlatIntegration(IV,llmax)
cmbmain.f90:    end subroutine DoSourceIntegration
cmbmain.f90:    function UseLimber(l,k)
cmbmain.f90:    !Calculate lensing potential power using Limber rather than j_l integration
cmbmain.f90:    !even when sources calculated as part of temperature calculation
cmbmain.f90:    !Could be lower but care with phi-T correlation at lower L
cmbmain.f90:    end function UseLimber
cmbmain.f90:    !flat source integration
cmbmain.f90:    subroutine DoFlatIntegration(IV, llmax)
cmbmain.f90:    type(IntegrationVars) IV
cmbmain.f90:    !     Find the position in the xx table for the x correponding to each
cmbmain.f90:        !Precomputed values for the interpolation
cmbmain.f90:        if (full_bessel_integration .or. do_bispectrum) then
cmbmain.f90:        !interpolate the Bessel functions only
cmbmain.f90:                    !Full Bessel integration
cmbmain.f90:                !Limber approximation for small scale lensing (better than poor version of above integral)
cmbmain.f90:    end subroutine DoFlatIntegration
cmbmain.f90:    !non-flat source integration
cmbmain.f90:    type(IntegrationVars) IV
cmbmain.f90:        !Integrate chi down in dissipative region
cmbmain.f90:            !Integrate chi up in oscillatory region
cmbmain.f90:                        if (chi==0) exit !small for remaining region
cmbmain.f90:            !Limber approximation for small scale lensing (better than poor version of above integral)
cmbmain.f90:        !Integrate chi down in dissipative region
cmbmain.f90:        !Integrate chi up in oscillatory region
cmbmain.f90:                    if (chi==0) exit !small for remaining region
cmbmain.f90:    !Non-flat version
cmbmain.f90:    ! differential equation from initial values.
cmbmain.f90:    use precision
cmbmain.f90:    type(IntegrationVars) IV
cmbmain.f90:    isgn=sign(1,Startn-nend)!direction of chi integration
cmbmain.f90:        ! One step in the ujl integration
cmbmain.f90:        ! fourth-order Runge-Kutta method to integrate equation for ujl
cmbmain.f90:            exit   !If this happens we are small, so stop integration
cmbmain.f90:                !may save time, and prevents numerical error leading to access violation of IV%Source_q(0)
cmbmain.f90:            exit !break when getting  exponentially small in dissipative region
cmbmain.f90:    ! differential equation from initial values for calculating ujl.
cmbmain.f90:    ! integration.
cmbmain.f90:    use precision
cmbmain.f90:    type(IntegrationVars), target :: IV
cmbmain.f90:    real(dl), dimension(:,:), pointer :: sourcep, ddsourcep
cmbmain.f90:    isgn=sign(1,nstart-nend)!direction of chi integration
cmbmain.f90:        ! One step in the ujl integration
cmbmain.f90:        ! fourth-order Runge-Kutta method to integrate equation for ujl
cmbmain.f90:                !may save time, and prevents numerical error leading to access violation of zero index
cmbmain.f90:            exit  !break when getting  exponentially small in dissipative region
cmbmain.f90:                                        !Skip if the auto or cross-correlation is included in direct Limber result
cmbmain.f90:                !We put pix extra factors of l here to improve interpolation in CTrans%ls%l
cmbmain.f90:                !Cross-correlation is CTrans%ls%l^3 C_l^{\phi T}
cmbmain.f90:                !Cross-correlation is CTrans%ls%l^3 C_l^{\phi E}
cmbmain.f90:    integer, dimension(2,2), parameter :: ind = reshape( (/ 1,3,3,2 /), shape(ind))
cmbmain.f90:    !Note using log interpolation is worse
cmbmain.f90~:    !     See readme.html for documentation.
cmbmain.f90~:    !     REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPlIED.
cmbmain.f90~:    !     By way of example, but not limitation,
cmbmain.f90~:    !     M.I.T. AND C.f.A MAKE NO REPRESENTATIONS OR WARRANTIES OF
cmbmain.f90~:    !     THE USE OF THE lICENSED SOFTWARE OR DOCUMENTATION WIll NOT INFRINGE
cmbmain.f90~:    !     portions of this software are based on the COSMICS package of
cmbmain.f90~:    !     E. Bertschinger.  See the lICENSE file of the COSMICS distribution
cmbmain.f90~:    !     for restrictions on the modification and distribution of this software.
cmbmain.f90~:    !     This code evolves the linearized perturbation equations of general relativity,
cmbmain.f90~:    !     the Boltzmann equations and the fluid equations for perturbations
cmbmain.f90~:    !     of a Friedmann-Robertson-Walker universe with a supplied system of gauge-dependent equation
cmbmain.f90~:    !     computed at sampled times during the evolution for various of wavenumbers. The sources
cmbmain.f90~:    !     For CP%flat models the bessel functions are interpolated from a pre-computed table, for
cmbmain.f90~:    !     non-CP%flat models the hyperspherical Bessel functions are computed by integrating their
cmbmain.f90~:    !     differential equation. Both phases ('Evolution' and 'Integration') can do separate
cmbmain.f90~:    !    EV = Time evolution variables
cmbmain.f90~:    !    IV = Source integration variables
cmbmain.f90~:    ! perturbation equations, and InitialPower which provides the initial power spectrum.
cmbmain.f90~:    use precision
cmbmain.f90~:    use EFTinitialization
cmbmain.f90~:    !Variables for integrating the sources with the bessel functions for each wavenumber
cmbmain.f90~:    type IntegrationVars
cmbmain.f90~:        !        real(dl), dimension(:,:), pointer :: Delta_l_q
cmbmain.f90~:        !Contribution to C_l integral from this k
cmbmain.f90~:        real(dl), dimension(:,:), pointer :: Source_q, ddSource_q
cmbmain.f90~:    end type IntegrationVars
cmbmain.f90~:    real(dl), dimension(:,:,:), allocatable :: Src, ddSrc !Sources and second derivs
cmbmain.f90~:    real(dl), dimension(:,:,:), allocatable :: iCl_scalar, iCl_vector, iCl_tensor
cmbmain.f90~:    real(dl), dimension(:,:,:,:), allocatable :: iCl_Array
cmbmain.f90~:    ! values of q to evolve the propagation equations to compute the sources
cmbmain.f90~:    Type(Regions) :: Evolve_q
cmbmain.f90~:    integer :: l_smooth_sample = 3000 !assume transfer functions effectively small for k>2*l_smooth_sample
cmbmain.f90~:    type(EvolutionVars) EV
cmbmain.f90~:            call EFTCAMB_initialization(EFTsuccess)
cmbmain.f90~:            !I HAVE ALREADY CALLED IT IN EQUATIONS_EFT.F90
cmbmain.f90~:    !Calculation of the CMB sources.
cmbmain.f90~:    !***note that !$ is the prefix for conditional multi-processor compilation***
cmbmain.f90~:            write(*,*) actual-timeprev,' Timing for source calculation'
cmbmain.f90~:    ! If transfer functions are requested, set remaining k values and output
cmbmain.f90~:    !     if CMB calculations are requested, calculate the Cl by
cmbmain.f90~:            call InitSourceInterpolation
cmbmain.f90~:            if (DebugMsgs .and. Feedbacklevel > 0) write(*,*) 'Set ',ThisCT%q%npoints,' integration k values'
cmbmain.f90~:                write(*,*)actual-timeprev,' Timing For Integration'
cmbmain.f90~:        !Final calculations for CMB output unless want the Cl transfer functions only.
cmbmain.f90~:    if (CP%OutputNormalization >=2) call NormalizeClsAtl(CP%OutputNormalization)
cmbmain.f90~:    !Normalize to C_l=1 at l=OutputNormalization
cmbmain.f90~:    type(IntegrationVars) :: IV
cmbmain.f90~:    call IntegrationVars_init(IV)
cmbmain.f90~:    call DoSourceIntegration(IV)
cmbmain.f90~:    real(dl), dimension(:), allocatable :: q_transfer
cmbmain.f90~:        !Linear spacing for horizon scales and first few baryon osciallations
cmbmain.f90~:        !Log spacing for last few oscillations
cmbmain.f90~:        if (CP%Transfer%high_precision) boost = boost*1.5
cmbmain.f90~:    function GetTauStart(q)
cmbmain.f90~:    !     Conformal time (in Mpc) in the radiation era, for photons plus 3 species
cmbmain.f90~:    !     Make sure to start early in the radiation era.
cmbmain.f90~:    end function GetTauStart
cmbmain.f90~:    type(EvolutionVars) EV
cmbmain.f90~:    use precision
cmbmain.f90~:    !     Timesteps during recombination (tentative, the actual
cmbmain.f90~:    !     where taurst is the time when recombination starts - see inithermo
cmbmain.f90~:    !AL:Changed Dec 2003, dtaurec feeds back into the non-flat integration via the step size
cmbmain.f90~:    !     Initialize baryon temperature and ionization fractions vs. time.
cmbmain.f90~:    !     saved in order to do the integration. So TimeSteps is set here.
cmbmain.f90~:    !Do any array initialization for propagation equations
cmbmain.f90~:    !     Calculating the times for the outputs of the transfer functions.
cmbmain.f90~:    !     polarization will be calculated. For low values of k we
cmbmain.f90~:    if (CP%WantScalars .and. CP%Reion%Reionization .and. CP%AccuratePolarization) then
cmbmain.f90~:        !Need this to get accurate low l polarization
cmbmain.f90~:    if (CP%AccurateReionization) dlnk0 = dlnk0/2
cmbmain.f90~:    if (CP%Want_CMB .and. maximum_l > 5000 .and. CP%AccuratePolarization) q_cmb = q_cmb*1.4
cmbmain.f90~:    Type(Regions) :: R
cmbmain.f90~:        !quantization is important
cmbmain.f90~:    type(EvolutionVars) EV
cmbmain.f90~:        !evolution output
cmbmain.f90~:        ! EFTCAMB MOD START: It's always nice to plot the evolution of perturbations in DE/MG models!
cmbmain.f90~:            call CreateTxtFile('Results/Debug_Evolution/Files/1_FRW.dat',1)
cmbmain.f90~:            call CreateTxtFile('Results/Debug_Evolution/Files/2_EFTfunctions.dat',2)
cmbmain.f90~:            call CreateTxtFile('Results/Debug_Evolution/Files/3_EFTBackground.dat',3)
cmbmain.f90~:            call CreateTxtFile('Results/Debug_Evolution/Files/4_PiFieldSolution.dat',4)
cmbmain.f90~:            call CreateTxtFile('Results/Debug_Evolution/Files/5_MetricSolution.dat',5)
cmbmain.f90~:            call CreateTxtFile('Results/Debug_Evolution/Files/6_DensitySolution.dat',6)
cmbmain.f90~:            call CreateTxtFile('Results/Debug_Evolution/Files/7_EinsteinEqFactors.dat',7)
cmbmain.f90~:            call CreateTxtFile('Results/Debug_Evolution/Files/8_PiEqFactors.dat',8)
cmbmain.f90~:            call CreateTxtFile('Results/Debug_Evolution/Files/9_Sources.dat',9)
cmbmain.f90~:            call CreateTxtFile('Results/Debug_Evolution/Files/10_MuGamma.dat',10)
cmbmain.f90~:        !!Example code for plotting out variable evolution
cmbmain.f90~:    if (CP%WantTransfer .and. CP%Transfer%high_precision) tol1=tol1/100
cmbmain.f90~:        if (.not. DebugEvolution .and. (EV%q*tauend > max_etak_scalar .and. tauend > taurend) &
cmbmain.f90~:            !     Calculation of transfer functions.
cmbmain.f90~:                !     output transfer functions for this k-value.
cmbmain.f90~:    type(EvolutionVars) EV
cmbmain.f90~:    type(EvolutionVars) EV
cmbmain.f90~:    !!Example code for plotting out variable evolution
cmbmain.f90~:    !Output transfer functions for k larger than used for C_l computation
cmbmain.f90~:    type(EvolutionVars) EV
cmbmain.f90~:    type(EvolutionVars) EV
cmbmain.f90~:            if (CP%Transfer%high_precision) atol=atol
cmbmain.f90~:            if (CP%Transfer%high_precision) atol=atol/10000
cmbmain.f90~:        ! if (CP%Transfer%high_precision) atol=atol/10000
cmbmain.f90~:    subroutine InitSourceInterpolation
cmbmain.f90~:    !     get the interpolation matrix for the sources to interpolate them
cmbmain.f90~:    end subroutine InitSourceInterpolation
cmbmain.f90~:    !     Fixing the # of k for the integration.
cmbmain.f90~:                !This allows inclusion of high k modes for computing BB lensed spectrum accurately
cmbmain.f90~:    type(IntegrationVars) IV
cmbmain.f90~:    !     finding position of k in table Evolve_q to do the interpolation.
cmbmain.f90~:    !Can't use the following in closed case because regions are not set up (only points)
cmbmain.f90~:    !     Interpolating the source as a function of time for the present
cmbmain.f90~:            if ((DebugEvolution .or. WantLateTime .or. IV%q*TimeSteps%points(i) < max_etak_scalar) &
cmbmain.f90~:    subroutine IntegrationVars_Init(IV)
cmbmain.f90~:    type(IntegrationVars), intent(INOUT) :: IV
cmbmain.f90~:    end  subroutine IntegrationVars_Init
cmbmain.f90~:    subroutine DoSourceIntegration(IV) !for particular wave number q
cmbmain.f90~:    type(IntegrationVars) IV
cmbmain.f90~:        call DoFlatIntegration(IV,llmax)
cmbmain.f90~:    end subroutine DoSourceIntegration
cmbmain.f90~:    function UseLimber(l,k)
cmbmain.f90~:    !Calculate lensing potential power using Limber rather than j_l integration
cmbmain.f90~:    !even when sources calculated as part of temperature calculation
cmbmain.f90~:    !Could be lower but care with phi-T correlation at lower L
cmbmain.f90~:    end function UseLimber
cmbmain.f90~:    !flat source integration
cmbmain.f90~:    subroutine DoFlatIntegration(IV, llmax)
cmbmain.f90~:    type(IntegrationVars) IV
cmbmain.f90~:    !     Find the position in the xx table for the x correponding to each
cmbmain.f90~:        !Precomputed values for the interpolation
cmbmain.f90~:        if (full_bessel_integration .or. do_bispectrum) then
cmbmain.f90~:        !interpolate the Bessel functions only
cmbmain.f90~:                    !Full Bessel integration
cmbmain.f90~:                !Limber approximation for small scale lensing (better than poor version of above integral)
cmbmain.f90~:    end subroutine DoFlatIntegration
cmbmain.f90~:    !non-flat source integration
cmbmain.f90~:    type(IntegrationVars) IV
cmbmain.f90~:        !Integrate chi down in dissipative region
cmbmain.f90~:            !Integrate chi up in oscillatory region
cmbmain.f90~:                        if (chi==0) exit !small for remaining region
cmbmain.f90~:            !Limber approximation for small scale lensing (better than poor version of above integral)
cmbmain.f90~:        !Integrate chi down in dissipative region
cmbmain.f90~:        !Integrate chi up in oscillatory region
cmbmain.f90~:                    if (chi==0) exit !small for remaining region
cmbmain.f90~:    !Non-flat version
cmbmain.f90~:    ! differential equation from initial values.
cmbmain.f90~:    use precision
cmbmain.f90~:    type(IntegrationVars) IV
cmbmain.f90~:    isgn=sign(1,Startn-nend)!direction of chi integration
cmbmain.f90~:        ! One step in the ujl integration
cmbmain.f90~:        ! fourth-order Runge-Kutta method to integrate equation for ujl
cmbmain.f90~:            exit   !If this happens we are small, so stop integration
cmbmain.f90~:                !may save time, and prevents numerical error leading to access violation of IV%Source_q(0)
cmbmain.f90~:            exit !break when getting  exponentially small in dissipative region
cmbmain.f90~:    ! differential equation from initial values for calculating ujl.
cmbmain.f90~:    ! integration.
cmbmain.f90~:    use precision
cmbmain.f90~:    type(IntegrationVars), target :: IV
cmbmain.f90~:    real(dl), dimension(:,:), pointer :: sourcep, ddsourcep
cmbmain.f90~:    isgn=sign(1,nstart-nend)!direction of chi integration
cmbmain.f90~:        ! One step in the ujl integration
cmbmain.f90~:        ! fourth-order Runge-Kutta method to integrate equation for ujl
cmbmain.f90~:                !may save time, and prevents numerical error leading to access violation of zero index
cmbmain.f90~:            exit  !break when getting  exponentially small in dissipative region
cmbmain.f90~:                                        !Skip if the auto or cross-correlation is included in direct Limber result
cmbmain.f90~:                !We put pix extra factors of l here to improve interpolation in CTrans%ls%l
cmbmain.f90~:                !Cross-correlation is CTrans%ls%l^3 C_l^{\phi T}
cmbmain.f90~:                !Cross-correlation is CTrans%ls%l^3 C_l^{\phi E}
cmbmain.f90~:    integer, dimension(2,2), parameter :: ind = reshape( (/ 1,3,3,2 /), shape(ind))
cmbmain.f90~:    !Note using log interpolation is worse
Binary file cmb_ttcomp_full_wbd_10.pdf matches
Binary file cmb_ttcomp_full_wbd_75.pdf matches
Binary file cmb_ttcomp_wbd_10.pdf matches
Binary file cmb_ttcomp_wbd_75.pdf matches
Binary file COM_PowerSpect_CMB_R2.02.fits matches
constants.f90:   module Precision
constants.f90:   end module Precision
constants.f90:       use precision
constants.f90:       real(dl), parameter :: Mpc = 3.085678e22_dl !seem to be different definitions of this?
constants.f90:                !7.565914e-16_dl !radiation constant for u=aT^4
constants.f90:        !Used to get evolution of matter temperature
constants.f90:     integer, parameter :: error_reionization=1
constants.f90:     integer, parameter :: error_recombination=2
constants.f90:     integer, parameter :: error_evolution=4
constants.f90:       character(LEN=*), intent(IN), optional :: message
constants.f90:       integer, intent(in), optional :: id
cosmorec.F90:    ! Recombination module for CAMB, using CosmoRec 
cosmorec.F90:    ! 12.06.2012: AL, changed interface to pass nnu directly; fixed spline extrapolation
cosmorec.F90:    module Recombination
cosmorec.F90:    type RecombinationParams
cosmorec.F90:        real(dl) :: fdm  ! Dark matter annihilation efficiency
cosmorec.F90:    end type RecombinationParams
cosmorec.F90:    character(LEN=*), parameter :: Recombination_Name = 'CosmoRec'
cosmorec.F90:    real(dl), dimension(Nz) :: zrec, arec, Hz
cosmorec.F90:    real(dl), dimension(Nz) :: xrec, tmrec, x2rec, tm2rec
cosmorec.F90:    public RecombinationParams, Recombination_xe, Recombination_tm, Recombination_init,   &
cosmorec.F90:    Recombination_ReadParams, Recombination_SetDefParams, &
cosmorec.F90:    Recombination_Validate, Recombination_Name
cosmorec.F90:    subroutine Recombination_ReadParams(R, Ini)
cosmorec.F90:    Type(RecombinationParams) :: R
cosmorec.F90:    end subroutine Recombination_ReadParams
cosmorec.F90:    subroutine Recombination_SetDefParams(R)
cosmorec.F90:    type (RecombinationParams) ::R
cosmorec.F90:    end subroutine Recombination_SetDefParams
cosmorec.F90:    subroutine Recombination_Validate(R, OK)
cosmorec.F90:    Type(RecombinationParams), intent(in) :: R
cosmorec.F90:        write(*,*) "Dark matter annihilation rate too high. Will crash CosmoRec."
cosmorec.F90:    end subroutine Recombination_Validate
cosmorec.F90:    function Recombination_tm(a)
cosmorec.F90:    real(dl) Recombination_tm
cosmorec.F90:    Recombination_tm = spline_val(a, arec, tmrec, tm2rec, Nz)
cosmorec.F90:    end function Recombination_tm
cosmorec.F90:    function Recombination_xe(a)
cosmorec.F90:    real(dl) Recombination_xe
cosmorec.F90:    Recombination_xe = spline_val(a, arec, xrec, x2rec, Nz)
cosmorec.F90:    end function Recombination_xe
cosmorec.F90:    subroutine Recombination_init(Recomb, OmegaC, OmegaB, OmegaN, Omegav, h0inp, tcmb, yp, num_nu)
cosmorec.F90:    Type (RecombinationParams), intent(in) :: Recomb
cosmorec.F90:    real(dl), dimension(5) :: runpars
cosmorec.F90:    runpars(1) = Recomb%fdm ! Set dark matter annihilation efficiency
cosmorec.F90:    ! internal Hubble function of CosmoRec is used
cosmorec.F90:    ! version which uses camb Hubble function
cosmorec.F90:    end subroutine Recombination_init
cosmorec.F90:    ! General routine for cubic spline interpolation (see NR)
cosmorec.F90:    real(dl) function spline_val(x, xv, yv, y2, n)
cosmorec.F90:        ! Bisection to find correct interval
cosmorec.F90:    end function spline_val
cosmorec.F90:    end module Recombination
EFT_def.f90:!   Compile time EFTCAMB options and Dark Energy equation of state module.
EFT_def.f90:!   For more informations about the methods contained in this file see
EFT_def.f90:!   the documentation: arXiv:1405.3590
EFT_def.f90:! Definition of all the EFTCAMB compile time flags and physical constants later used by the code.
EFT_def.f90:    use Precision
EFT_def.f90:    !    At times earlier than these the code evolves perturbations as in GR.
EFT_def.f90:    !    is viable during radiation, matter and DE eras.
EFT_def.f90:    !    These flag will decide wether to impose a prior or not. For a detailed explanation refer to
EFT_def.f90:    !    the documentation: arXiv:1405.3590
EFT_def.f90:    !    1- Decides wether to use the old stability ghost and gradient conditions or the new ones.
EFT_def.f90:    !       the propagation speed of pi should be smaller than the speed of light.
EFT_def.f90:    !    These flags have to be used in conjunction with two other changes.
EFT_def.f90:    !    If EFTCAMB is used inside CosmoMC then the initialization subroutine has to be called
EFT_def.f90:! Definition of the dark energy equation of state (w_DE) used by the designer and pure EFT code.
EFT_def.f90:    function EFTw(a,deriv)
EFT_def.f90:        !Protection against numerical errors at very early times
EFT_def.f90:        ! Definition of the function itself
EFT_def.f90:        !   deriv= 0: the function w(a) itself;
EFT_def.f90:            case (4) ! Inflection model
EFT_def.f90:            case (5) ! Taylor expansion
EFT_def.f90:    end function EFTw
EFT_def.f90~:!   Compile time EFTCAMB options and Dark Energy equation of state module.
EFT_def.f90~:!   For more informations about the methods contained in this file see
EFT_def.f90~:!   the documentation: arXiv:1405.3590
EFT_def.f90~:! Definition of all the EFTCAMB compile time flags and physical constants later used by the code.
EFT_def.f90~:    use Precision
EFT_def.f90~:    !    At times earlier than these the code evolves perturbations as in GR.
EFT_def.f90~:    !    is viable during radiation, matter and DE eras.
EFT_def.f90~:    !    These flag will decide wether to impose a prior or not. For a detailed explanation refer to
EFT_def.f90~:    !    the documentation: arXiv:1405.3590
EFT_def.f90~:    !    1- Decides wether to use the old stability ghost and gradient conditions or the new ones.
EFT_def.f90~:    !       the propagation speed of pi should be smaller than the speed of light.
EFT_def.f90~:    !    These flags have to be used in conjunction with two other changes.
EFT_def.f90~:    !    If EFTCAMB is used inside CosmoMC then the initialization subroutine has to be called
EFT_def.f90~:! Definition of the dark energy equation of state (w_DE) used by the designer and pure EFT code.
EFT_def.f90~:    function EFTw(a,deriv)
EFT_def.f90~:        !Protection against numerical errors at very early times
EFT_def.f90~:        ! Definition of the function itself
EFT_def.f90~:        !   deriv= 0: the function w(a) itself;
EFT_def.f90~:            case (4) ! Inflection model
EFT_def.f90~:            case (5) ! Taylor expansion
EFT_def.f90~:    end function EFTw
EFT_designer.f90:!   For more informations about the methods contained in this file see
EFT_designer.f90:!   the documentation: arXiv:1405.3590
EFT_designer.f90:! Solve the designer differential equations for the chosen model and computes,
EFT_designer.f90:! from the solution, the values of the EFT functions
EFT_designer.f90:    ! 1) Definitions of the variables common to all the designer code.
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: xp_des   ! Array with the time sampling
EFT_designer.f90:    ! 2) Tables containing the sampled values of the EFT functions.
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: OmegaDes, OmegapDes, OmegappDes,Omega3pDes
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: EFT_Lambda_Des, EFT_Lambdadot_Des, EFT_c_Des, EFT_cdot_Des
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: Des_Gamma1, Des_Gamma1p, Des_Gamma2, Des_Gamma2p
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: Des_Gamma3, Des_Gamma3p, Des_Gamma4, Des_Gamma4p
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: Des_Gamma5, Des_Gamma5p, Des_Gamma6, Des_Gamma6p
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: Des_Gamma4pp
EFT_designer.f90:    ! 3) Definitions used by a specific model.
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: BFunc, BPrime, fRFunc
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: zp_fR ! zp_fR = Ricci/H0^2
EFT_designer.f90:    real(dl), save, dimension(nvar_fR, des_nstep+DesignerInFuture+1) :: yp_fR, dyp_fR ! yp_fR = f(R)/H0^2
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: phibd, phiprimebd, phiprimeprimebd, a_evol
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: Eevol_bd, Eprimeevol_bd, Edprimeevol_bd
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: omegade, omegapresde, hubble, hubble_lam
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: omegadebara4, omegadepresbara4, omegadebara2
EFT_designer.f90:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: omegadepresbara2, omegadeweff, omegadeweffprime
EFT_designer.f90:    real(dl), parameter :: prec = 1.0e-8 !Precision for phi(a=1) = phi_0
EFT_designer.f90:    real(dl), parameter :: precflat = 1.0e-5 !Precision for flatness today
EFT_designer.f90:		!print*, 'You have to be within the range to determine the appropriate initial conditions'
EFT_designer.f90:		!print*, 'Please check the range of your initial conditions for the scalar field'
EFT_designer.f90:    print*, 'The flatness condition yieds', 1.0-(omegade(des_nstep)/(3.0*phibd(des_nstep)*(hubble(des_nstep))**2.0) + om/(3.0*phibd(des_nstep)*(hubble(des_nstep))**2.0))
EFT_designer.f90:!!!!ALPHA FUNCTIONS!!!!!
EFT_designer.f90:!!!!!ALPHA FUNCTIONS!!!!!
EFT_designer.f90:function Hubblebd(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90:end function  Hubblebd
EFT_designer.f90:function funcaobd(phi,phiprime,a,om,omr,H0,arglamda)
EFT_designer.f90:end function funcaobd
EFT_designer.f90:function Hubbleprimereduced(a,phi,phiprime,om,omr,H0,arglamda) !i.e., not containing the phidprime term. This is actually H*H'
EFT_designer.f90:    end function Hubbleprimereduced
EFT_designer.f90:function phidotdot(phi,phiprime,a,om,omr,H0,arglamda) !in physical time
EFT_designer.f90:end function phidotdot
EFT_designer.f90:function dedensitybara4(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90:end function dedensitybara4
EFT_designer.f90:function dedensitybara2(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90:end function dedensitybara2
EFT_designer.f90:function depresbara4(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90:end function depresbara4
EFT_designer.f90:function depresbara2(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90:end function depresbara2
EFT_designer.f90:function dedensitybd(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90:end function dedensitybd
EFT_designer.f90:function depresbd(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90:end function depresbd
EFT_designer.f90:function potbd(phi,deriv,arglamda) !arglamda plays the role of the 'weight' of the potential, that is searched for flatness
EFT_designer.f90:end function potbd
EFT_designer.f90:function Eom(a,om)
EFT_designer.f90:end function Eom
EFT_designer.f90:function Eomr(a,omr)
EFT_designer.f90:end function Eomr
EFT_designer.f90:        ! This subroutine finds the appropriate initial conditions and solves
EFT_designer.f90:        ! the designer equation for f(R) models.
EFT_designer.f90:        !  Find initial conditions for designer F(R).
EFT_designer.f90:        !  Initial conditions are found solving B0(A)=B0wanted.
EFT_designer.f90:        ! 6) Extablish on which side of the asyntote to look for the solution.
EFT_designer.f90:        ! 7) Solve the equation B0(A)=B0_wanted.
EFT_designer.f90:                write(*,*) 'f(R) designer: right side solution not found.'
EFT_designer.f90:                write(*,*) 'f(R) designer: right side solution not found'
EFT_designer.f90:        if (FeedbackLevel>2) write(*,*) 'f(R) designer: initial condition A =', realAp
EFT_designer.f90:            write(*,*)  'EFTCAMB: designer code unable to find appropriate initial conditions'
EFT_designer.f90:        ! 9) Finally: solve the F(R) background equation.
EFT_designer.f90:            ! 1) Prints the function B0(A). This is used to debug the initial conditions part.
EFT_designer.f90:    function DesFR_BfuncA(Ap)
EFT_designer.f90:        ! This function gives the present day value of B given the initial conditions.
EFT_designer.f90:    end function DesFR_BfuncA
EFT_designer.f90:        ! This subroutine solves the designer equation for f(R) models for a given value
EFT_designer.f90:        ! of the initial conditions (coefA).
EFT_designer.f90:        ! Variable definitions:
EFT_designer.f90:        ! 2) Growing mode solution:
EFT_designer.f90:        !    Construction of the particolar solution:
EFT_designer.f90:        !    Initial conditions:
EFT_designer.f90:        !    Function g(x) at initial time:
EFT_designer.f90:        !   Massive neutrinos at initial conditions:
EFT_designer.f90:                ! Compute the g(x) functions
EFT_designer.f90:                ! First compute massive neutrinos contribution:
EFT_designer.f90:                ! Add its contribution to E and E':
EFT_designer.f90:                ! Compute function B:
EFT_designer.f90:                ! Compute the EFT functions
EFT_designer.f90:        ! This subroutine computes the designer f(R) equation of motion.
EFT_designer.f90:        real(dl), dimension(n) :: y_fR,dydx_fR
EFT_designer.f90:        real(dl) :: EFunction, EFunPrime, EFunPrime2, EFunPrime3
EFT_designer.f90:        ! 2) Compute the function g(x) and its derivatives:
EFT_designer.f90:        ! First compute massive neutrinos contribution:
EFT_designer.f90:        ! Add its contribution to E and E':
EFT_designer.f90:        EFunction = +OmegaRad_EFT*exp(-4._dl*x)&
EFT_designer.f90:                adotoa = +a*H0_EFT*sqrt(EFunction)
EFT_designer.f90:                    & -grhormass_t*(presnudot -4._dl*adotoa*presnu)/H0_EFT**3/sqrt(EFunction)/a**3
EFT_designer.f90:        ! 4) Get the equation of motion:
EFT_designer.f90:        dydx_fR(2) = (1._dl+0.5_dl*EFunPrime/EFunction+(4._dl*EFunPrime2+EFunPrime3)/(4._dl*EFunPrime+EFunPrime2))*y_fR(2) &
EFT_designer.f90:            & -0.5_dl*(4._dl*EFunPrime+EFunPrime2)/EFunction*y_fR(1) &
EFT_designer.f90:            & -3._dl*Omegavac_EFT*exp(-3._dl*EFT_E_gfun)*(4._dl*EFunPrime+EFunPrime2)/EFunction
EFT_designer.f90:    function Designed_EFT_Function(EFTFunctionTable, a, GR_value)
EFT_designer.f90:        ! The designer code will provide a table of sampled values for the EFT functions.
EFT_designer.f90:        ! This function is called in the EFTfunctions module to interpolate those tables.
EFT_designer.f90:        real(dl) :: EFTFunctionTable(des_nstep+DesignerInFuture+1)
EFT_designer.f90:        real(dl) :: Designed_EFT_Function
EFT_designer.f90:                    yb(i)=EFTFunctionTable(des_nstep+DesignerInFuture-des_ninterpol+i)
EFT_designer.f90:                    yb(i)=EFTFunctionTable(i)
EFT_designer.f90:                    yb(i)=EFTFunctionTable(jlo-stint+i)
EFT_designer.f90:            temp = EFTFunctionTable(des_nstep+DesignerInFuture)
EFT_designer.f90:        Designed_EFT_Function = temp
EFT_designer.f90:    end function Designed_EFT_Function
EFT_designer.f90~:!   For more informations about the methods contained in this file see
EFT_designer.f90~:!   the documentation: arXiv:1405.3590
EFT_designer.f90~:! Solve the designer differential equations for the chosen model and computes,
EFT_designer.f90~:! from the solution, the values of the EFT functions
EFT_designer.f90~:    ! 1) Definitions of the variables common to all the designer code.
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: xp_des   ! Array with the time sampling
EFT_designer.f90~:    ! 2) Tables containing the sampled values of the EFT functions.
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: OmegaDes, OmegapDes, OmegappDes,Omega3pDes
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: EFT_Lambda_Des, EFT_Lambdadot_Des, EFT_c_Des, EFT_cdot_Des
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: Des_Gamma1, Des_Gamma1p, Des_Gamma2, Des_Gamma2p
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: Des_Gamma3, Des_Gamma3p, Des_Gamma4, Des_Gamma4p
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: Des_Gamma5, Des_Gamma5p, Des_Gamma6, Des_Gamma6p
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: Des_Gamma4pp
EFT_designer.f90~:    ! 3) Definitions used by a specific model.
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: BFunc, BPrime, fRFunc
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: zp_fR ! zp_fR = Ricci/H0^2
EFT_designer.f90~:    real(dl), save, dimension(nvar_fR, des_nstep+DesignerInFuture+1) :: yp_fR, dyp_fR ! yp_fR = f(R)/H0^2
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: phibd, phiprimebd, phiprimeprimebd, a_evol
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: Eevol_bd, Eprimeevol_bd, Edprimeevol_bd
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: omegade, omegapresde, hubble, hubble_lam
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: omegadebara4, omegadepresbara4, omegadebara2
EFT_designer.f90~:    real(dl), save, dimension(des_nstep+DesignerInFuture+1) :: omegadepresbara2, omegadeweff, omegadeweffprime
EFT_designer.f90~:    real(dl), parameter :: prec = 1.0e-8 !Precision for phi(a=1) = phi_0
EFT_designer.f90~:    real(dl), parameter :: precflat = 1.0e-5 !Precision for flatness today
EFT_designer.f90~:		!print*, 'You have to be within the range to determine the appropriate initial conditions'
EFT_designer.f90~:		!print*, 'Please check the range of your initial conditions for the scalar field'
EFT_designer.f90~:    print*, 'The flatness condition yieds', 1.0-(omegade(des_nstep)/(3.0*phibd(des_nstep)*(hubble(des_nstep))**2.0) + om/(3.0*phibd(des_nstep)*(hubble(des_nstep))**2.0))
EFT_designer.f90~:!!!!ALPHA FUNCTIONS!!!!!
EFT_designer.f90~:!!!!!ALPHA FUNCTIONS!!!!!
EFT_designer.f90~:function Hubblebd(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90~:end function  Hubblebd
EFT_designer.f90~:function funcaobd(phi,phiprime,a,om,omr,H0,arglamda)
EFT_designer.f90~:end function funcaobd
EFT_designer.f90~:function Hubbleprimereduced(a,phi,phiprime,om,omr,H0,arglamda) !i.e., not containing the phidprime term. This is actually H*H'
EFT_designer.f90~:    end function Hubbleprimereduced
EFT_designer.f90~:function phidotdot(phi,phiprime,a,om,omr,H0,arglamda) !in physical time
EFT_designer.f90~:end function phidotdot
EFT_designer.f90~:function dedensitybara4(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90~:end function dedensitybara4
EFT_designer.f90~:function dedensitybara2(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90~:end function dedensitybara2
EFT_designer.f90~:function depresbara4(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90~:end function depresbara4
EFT_designer.f90~:function depresbara2(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90~:end function depresbara2
EFT_designer.f90~:function dedensitybd(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90~:end function dedensitybd
EFT_designer.f90~:function depresbd(a,phi,phiprime,om,omr,H0,arglamda)
EFT_designer.f90~:end function depresbd
EFT_designer.f90~:function potbd(phi,deriv,arglamda) !arglamda plays the role of the 'weight' of the potential, that is searched for flatness
EFT_designer.f90~:end function potbd
EFT_designer.f90~:function Eom(a,om)
EFT_designer.f90~:end function Eom
EFT_designer.f90~:function Eomr(a,omr)
EFT_designer.f90~:end function Eomr
EFT_designer.f90~:        ! This subroutine finds the appropriate initial conditions and solves
EFT_designer.f90~:        ! the designer equation for f(R) models.
EFT_designer.f90~:        !  Find initial conditions for designer F(R).
EFT_designer.f90~:        !  Initial conditions are found solving B0(A)=B0wanted.
EFT_designer.f90~:        ! 6) Extablish on which side of the asyntote to look for the solution.
EFT_designer.f90~:        ! 7) Solve the equation B0(A)=B0_wanted.
EFT_designer.f90~:                write(*,*) 'f(R) designer: right side solution not found.'
EFT_designer.f90~:                write(*,*) 'f(R) designer: right side solution not found'
EFT_designer.f90~:        if (FeedbackLevel>2) write(*,*) 'f(R) designer: initial condition A =', realAp
EFT_designer.f90~:            write(*,*)  'EFTCAMB: designer code unable to find appropriate initial conditions'
EFT_designer.f90~:        ! 9) Finally: solve the F(R) background equation.
EFT_designer.f90~:            ! 1) Prints the function B0(A). This is used to debug the initial conditions part.
EFT_designer.f90~:    function DesFR_BfuncA(Ap)
EFT_designer.f90~:        ! This function gives the present day value of B given the initial conditions.
EFT_designer.f90~:    end function DesFR_BfuncA
EFT_designer.f90~:        ! This subroutine solves the designer equation for f(R) models for a given value
EFT_designer.f90~:        ! of the initial conditions (coefA).
EFT_designer.f90~:        ! Variable definitions:
EFT_designer.f90~:        ! 2) Growing mode solution:
EFT_designer.f90~:        !    Construction of the particolar solution:
EFT_designer.f90~:        !    Initial conditions:
EFT_designer.f90~:        !    Function g(x) at initial time:
EFT_designer.f90~:        !   Massive neutrinos at initial conditions:
EFT_designer.f90~:                ! Compute the g(x) functions
EFT_designer.f90~:                ! First compute massive neutrinos contribution:
EFT_designer.f90~:                ! Add its contribution to E and E':
EFT_designer.f90~:                ! Compute function B:
EFT_designer.f90~:                ! Compute the EFT functions
EFT_designer.f90~:        ! This subroutine computes the designer f(R) equation of motion.
EFT_designer.f90~:        real(dl), dimension(n) :: y_fR,dydx_fR
EFT_designer.f90~:        real(dl) :: EFunction, EFunPrime, EFunPrime2, EFunPrime3
EFT_designer.f90~:        ! 2) Compute the function g(x) and its derivatives:
EFT_designer.f90~:        ! First compute massive neutrinos contribution:
EFT_designer.f90~:        ! Add its contribution to E and E':
EFT_designer.f90~:        EFunction = +OmegaRad_EFT*exp(-4._dl*x)&
EFT_designer.f90~:                adotoa = +a*H0_EFT*sqrt(EFunction)
EFT_designer.f90~:                    & -grhormass_t*(presnudot -4._dl*adotoa*presnu)/H0_EFT**3/sqrt(EFunction)/a**3
EFT_designer.f90~:        ! 4) Get the equation of motion:
EFT_designer.f90~:        dydx_fR(2) = (1._dl+0.5_dl*EFunPrime/EFunction+(4._dl*EFunPrime2+EFunPrime3)/(4._dl*EFunPrime+EFunPrime2))*y_fR(2) &
EFT_designer.f90~:            & -0.5_dl*(4._dl*EFunPrime+EFunPrime2)/EFunction*y_fR(1) &
EFT_designer.f90~:            & -3._dl*Omegavac_EFT*exp(-3._dl*EFT_E_gfun)*(4._dl*EFunPrime+EFunPrime2)/EFunction
EFT_designer.f90~:    function Designed_EFT_Function(EFTFunctionTable, a, GR_value)
EFT_designer.f90~:        ! The designer code will provide a table of sampled values for the EFT functions.
EFT_designer.f90~:        ! This function is called in the EFTfunctions module to interpolate those tables.
EFT_designer.f90~:        real(dl) :: EFTFunctionTable(des_nstep+DesignerInFuture+1)
EFT_designer.f90~:        real(dl) :: Designed_EFT_Function
EFT_designer.f90~:                    yb(i)=EFTFunctionTable(des_nstep+DesignerInFuture-des_ninterpol+i)
EFT_designer.f90~:                    yb(i)=EFTFunctionTable(i)
EFT_designer.f90~:                    yb(i)=EFTFunctionTable(jlo-stint+i)
EFT_designer.f90~:            temp = EFTFunctionTable(des_nstep+DesignerInFuture)
EFT_designer.f90~:        Designed_EFT_Function = temp
EFT_designer.f90~:    end function Designed_EFT_Function
EFT_functions.f90:!   EFTCAMB module that defines the EFT functions for the choosen model.
EFT_functions.f90:!   For more informations about the methods contained in this file see
EFT_functions.f90:!   the documentation: arXiv:1405.3590
EFT_functions.f90:! Definitions of the EFT functions later used by the code.
EFT_functions.f90:! After the designer or mapping code have been called the EFT functions can be used directly from
EFT_functions.f90:module EFTfunctions
EFT_functions.f90:    function EFTOmega(a,deriv)
EFT_functions.f90:        !EFT function Omega
EFT_functions.f90:                        stop 'You have to define your model for EFTOmega first! Go to the file EFT_functions.f90.'
EFT_functions.f90:                            EFTOmega= Designed_EFT_Function(OmegaDes, a, 0._dl)
EFT_functions.f90:                            EFTOmega= Designed_EFT_Function(OmegapDes, a, 0._dl)
EFT_functions.f90:                            EFTOmega= Designed_EFT_Function(OmegappDes, a, 0._dl)
EFT_functions.f90:                            EFTOmega= Designed_EFT_Function(Omega3pDes, a, 0._dl)
EFT_functions.f90:                            EFTOmega= Designed_EFT_Function(OmegaDes, a, 0._dl)
EFT_functions.f90:                            EFTOmega= Designed_EFT_Function(OmegapDes, a, 0._dl)
EFT_functions.f90:                            EFTOmega= Designed_EFT_Function(OmegappDes, a, 0._dl)
EFT_functions.f90:                            EFTOmega= Designed_EFT_Function(Omega3pDes, a, 0._dl)
EFT_functions.f90:            case (3) ! EFT alternative parametrizations
EFT_functions.f90:    end function EFTOmega
EFT_functions.f90:    function EFTGamma1(a,deriv)
EFT_functions.f90:        ! EFT function Gamma_1
EFT_functions.f90:                        stop 'You have to define your model for EFTGamma1 first! Go to the file EFT_functions.f90.'
EFT_functions.f90:            case (3) ! EFT alternative parametrizations
EFT_functions.f90:    end function EFTGamma1
EFT_functions.f90:    function EFTGamma2(a,deriv)
EFT_functions.f90:        ! EFT function Gamma_2
EFT_functions.f90:                        stop 'You have to define your model for EFTGamma2 first! Go to the file EFT_functions.f90.'
EFT_functions.f90:            case (3) ! EFT alternative parametrizations
EFT_functions.f90:    end function EFTGamma2
EFT_functions.f90:    function EFTGamma3(a,deriv)
EFT_functions.f90:        ! EFT function Gamma_3
EFT_functions.f90:                        stop 'You have to define your model for EFTGamma3 first! Go to the file EFT_functions.f90.'
EFT_functions.f90:            case (3) ! EFT alternative parametrizations
EFT_functions.f90:    end function EFTGamma3
EFT_functions.f90:    function EFTGamma4(a,deriv)
EFT_functions.f90:        ! EFT function Gamma_4
EFT_functions.f90:                            stop 'You have to define your model for EFTGamma4 first! Go to the file EFT_functions.f90.'
EFT_functions.f90:            case (3) ! EFT alternative parametrizations
EFT_functions.f90:    end function EFTGamma4
EFT_functions.f90:    function EFTGamma5(a,deriv)
EFT_functions.f90:        ! EFT function Gamma_5
EFT_functions.f90:                            stop 'You have to define your model for EFTGamma5 first! Go to the file EFT_functions.f90.'
EFT_functions.f90:            case (3) ! EFT alternative parametrizations
EFT_functions.f90:    end function EFTGamma5
EFT_functions.f90:    function EFTGamma6(a,deriv)
EFT_functions.f90:        ! EFT function Gamma_6
EFT_functions.f90:                            stop 'You have to define your model for EFTGamma6 first! Go to the file EFT_functions.f90.'
EFT_functions.f90:            case (3) ! EFT alternative parametrizations
EFT_functions.f90:    end function EFTGamma6
EFT_functions.f90:    function EFTLambdaTemp(a,deriv)
EFT_functions.f90:        ! EFT function Lambda
EFT_functions.f90:        ! This function is defined as Lambda/Mpl*a^2
EFT_functions.f90:            case (1) ! Pure EFT: Lambda is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90:                            EFTLambdaTemp = Designed_EFT_Function(EFT_Lambda_Des, a, 0._dl)
EFT_functions.f90:                            EFTLambdaTemp = Designed_EFT_Function(EFT_Lambdadot_Des, a, 0._dl)
EFT_functions.f90:                    case (2) ! Designer mc quintessence: Lambda is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90:                            EFTLambdaTemp = Designed_EFT_Function(EFT_Lambda_Des, a, 0._dl)
EFT_functions.f90:                            EFTLambdaTemp = Designed_EFT_Function(EFT_Lambdadot_Des, a, 0._dl)
EFT_functions.f90:            case (3) ! EFT alternative parametrizations
EFT_functions.f90:                    case (1) ! RPH: Lambda is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90:    end function EFTLambdaTemp
EFT_functions.f90:    function EFTcTemp(a,deriv)
EFT_functions.f90:        ! EFT function c
EFT_functions.f90:        ! This function is defined as c/Mpl*a^2
EFT_functions.f90:            case (1) ! Pure EFT: c is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90:                    case (2) ! Designer mc quintessence: c is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90:                        EFTcTemp = Designed_EFT_Function(EFT_c_des, a, 0._dl)
EFT_functions.f90:                        EFTcTemp = Designed_EFT_Function(EFT_cdot_des, a, 0._dl) 
EFT_functions.f90:            case (3) ! EFT alternative parametrizations
EFT_functions.f90:                    case (1) ! RPH: c is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90:    end function EFTcTemp
EFT_functions.f90:end module EFTfunctions
EFT_functions.f90~:!   EFTCAMB module that defines the EFT functions for the choosen model.
EFT_functions.f90~:!   For more informations about the methods contained in this file see
EFT_functions.f90~:!   the documentation: arXiv:1405.3590
EFT_functions.f90~:! Definitions of the EFT functions later used by the code.
EFT_functions.f90~:! After the designer or mapping code have been called the EFT functions can be used directly from
EFT_functions.f90~:module EFTfunctions
EFT_functions.f90~:    function EFTOmega(a,deriv)
EFT_functions.f90~:        !EFT function Omega
EFT_functions.f90~:                        stop 'You have to define your model for EFTOmega first! Go to the file EFT_functions.f90.'
EFT_functions.f90~:                            EFTOmega= Designed_EFT_Function(OmegaDes, a, 0._dl)
EFT_functions.f90~:                            EFTOmega= Designed_EFT_Function(OmegapDes, a, 0._dl)
EFT_functions.f90~:                            EFTOmega= Designed_EFT_Function(OmegappDes, a, 0._dl)
EFT_functions.f90~:                            EFTOmega= Designed_EFT_Function(Omega3pDes, a, 0._dl)
EFT_functions.f90~:                            EFTOmega= Designed_EFT_Function(OmegaDes, a, 0._dl)
EFT_functions.f90~:                            EFTOmega= Designed_EFT_Function(OmegapDes, a, 0._dl)
EFT_functions.f90~:                            EFTOmega= Designed_EFT_Function(OmegappDes, a, 0._dl)
EFT_functions.f90~:                            EFTOmega= Designed_EFT_Function(Omega3pDes, a, 0._dl)
EFT_functions.f90~:            case (3) ! EFT alternative parametrizations
EFT_functions.f90~:    end function EFTOmega
EFT_functions.f90~:    function EFTGamma1(a,deriv)
EFT_functions.f90~:        ! EFT function Gamma_1
EFT_functions.f90~:                        stop 'You have to define your model for EFTGamma1 first! Go to the file EFT_functions.f90.'
EFT_functions.f90~:            case (3) ! EFT alternative parametrizations
EFT_functions.f90~:    end function EFTGamma1
EFT_functions.f90~:    function EFTGamma2(a,deriv)
EFT_functions.f90~:        ! EFT function Gamma_2
EFT_functions.f90~:                        stop 'You have to define your model for EFTGamma2 first! Go to the file EFT_functions.f90.'
EFT_functions.f90~:            case (3) ! EFT alternative parametrizations
EFT_functions.f90~:    end function EFTGamma2
EFT_functions.f90~:    function EFTGamma3(a,deriv)
EFT_functions.f90~:        ! EFT function Gamma_3
EFT_functions.f90~:                        stop 'You have to define your model for EFTGamma3 first! Go to the file EFT_functions.f90.'
EFT_functions.f90~:            case (3) ! EFT alternative parametrizations
EFT_functions.f90~:    end function EFTGamma3
EFT_functions.f90~:    function EFTGamma4(a,deriv)
EFT_functions.f90~:        ! EFT function Gamma_4
EFT_functions.f90~:                            stop 'You have to define your model for EFTGamma4 first! Go to the file EFT_functions.f90.'
EFT_functions.f90~:            case (3) ! EFT alternative parametrizations
EFT_functions.f90~:    end function EFTGamma4
EFT_functions.f90~:    function EFTGamma5(a,deriv)
EFT_functions.f90~:        ! EFT function Gamma_5
EFT_functions.f90~:                            stop 'You have to define your model for EFTGamma5 first! Go to the file EFT_functions.f90.'
EFT_functions.f90~:            case (3) ! EFT alternative parametrizations
EFT_functions.f90~:    end function EFTGamma5
EFT_functions.f90~:    function EFTGamma6(a,deriv)
EFT_functions.f90~:        ! EFT function Gamma_6
EFT_functions.f90~:                            stop 'You have to define your model for EFTGamma6 first! Go to the file EFT_functions.f90.'
EFT_functions.f90~:            case (3) ! EFT alternative parametrizations
EFT_functions.f90~:    end function EFTGamma6
EFT_functions.f90~:    function EFTLambdaTemp(a,deriv)
EFT_functions.f90~:        ! EFT function Lambda
EFT_functions.f90~:        ! This function is defined as Lambda/Mpl*a^2
EFT_functions.f90~:            case (1) ! Pure EFT: Lambda is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90~:                            EFTLambdaTemp = Designed_EFT_Function(EFT_Lambda_Des, a, 0._dl)
EFT_functions.f90~:                            EFTLambdaTemp = Designed_EFT_Function(EFT_Lambdadot_Des, a, 0._dl)
EFT_functions.f90~:                    case (2) ! Designer mc quintessence: Lambda is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90~:                            EFTLambdaTemp = Designed_EFT_Function(EFT_Lambda_Des, a, 0._dl)
EFT_functions.f90~:                            EFTLambdaTemp = Designed_EFT_Function(EFT_Lambdadot_Des, a, 0._dl)
EFT_functions.f90~:            case (3) ! EFT alternative parametrizations
EFT_functions.f90~:                    case (1) ! RPH: Lambda is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90~:    end function EFTLambdaTemp
EFT_functions.f90~:    function EFTcTemp(a,deriv)
EFT_functions.f90~:        ! EFT function c
EFT_functions.f90~:        ! This function is defined as c/Mpl*a^2
EFT_functions.f90~:            case (1) ! Pure EFT: c is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90~:                    case (2) ! Designer mc quintessence: c is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90~:            case (3) ! EFT alternative parametrizations
EFT_functions.f90~:                    case (1) ! RPH: c is obtained through EFT designer approach (in equations.f90).
EFT_functions.f90~:    end function EFTcTemp
EFT_functions.f90~:end module EFTfunctions
EFT_Horndeski.f90:!   For more informations about the methods contained in this file see
EFT_Horndeski.f90:!   the documentation: arXiv:1405.3590
EFT_Horndeski.f90:! Definitions of the RPH functions later used by the code.
EFT_Horndeski.f90:module RPHfunctions
EFT_Horndeski.f90:    function RPH_PlanckMass(a,deriv)
EFT_Horndeski.f90:        !RPH function Planck mass.
EFT_Horndeski.f90:    end function RPH_PlanckMass
EFT_Horndeski.f90:    function RPH_Kineticity(a,deriv)
EFT_Horndeski.f90:        !RPH function \alpha_K.
EFT_Horndeski.f90:    end function RPH_Kineticity
EFT_Horndeski.f90:    function RPH_Braiding(a,deriv)
EFT_Horndeski.f90:        !RPH function \alpha_B.
EFT_Horndeski.f90:    end function RPH_Braiding
EFT_Horndeski.f90:    function RPH_Tensor(a,deriv)
EFT_Horndeski.f90:        !RPH function \alpha_T.
EFT_Horndeski.f90:    end function RPH_Tensor
EFT_Horndeski.f90:end module RPHfunctions
EFT_Horndeski.f90:! Defines all the functions used to map the RPH approach to EFT.
EFT_Horndeski.f90:    use Precision
EFT_Horndeski.f90:    use RPHfunctions
EFT_Horndeski.f90:    function RPH_Hubble(a)
EFT_Horndeski.f90:        !Function that returns conformal H as a function of a
EFT_Horndeski.f90:    end function RPH_Hubble
EFT_Horndeski.f90:    function RPH_HubbleDot(a)
EFT_Horndeski.f90:        !Function that returns time derivative of conformal H as a function of a
EFT_Horndeski.f90:    end function RPH_HubbleDot
EFT_Horndeski.f90:    function RPH_EFT_Omega(a, deriv)
EFT_Horndeski.f90:        !Function that returns the function EFT c for designer approach.
EFT_Horndeski.f90:    end function RPH_EFT_Omega
EFT_Horndeski.f90:    function RPH_EFTc(a)
EFT_Horndeski.f90:        !Function that returns the function EFT c for designer approach.
EFT_Horndeski.f90:        ! 4) EFT functions:
EFT_Horndeski.f90:    end function RPH_EFTc
EFT_Horndeski.f90:    function RPH_EFTcdot(a)
EFT_Horndeski.f90:        !Function that returns the time derivative of the EFT function c for designer approach.
EFT_Horndeski.f90:        ! 4) EFT functions:
EFT_Horndeski.f90:    end function RPH_EFTcdot
EFT_Horndeski.f90:    function RPH_EFT_Gamma1(a, deriv)
EFT_Horndeski.f90:        !Function that returns the EFT function gamma1 for RPH.
EFT_Horndeski.f90:    end function RPH_EFT_Gamma1
EFT_Horndeski.f90:    function RPH_EFT_Gamma2(a, deriv)
EFT_Horndeski.f90:        !Function that returns the EFT function gamma2 for RPH.
EFT_Horndeski.f90:    end function RPH_EFT_Gamma2
EFT_Horndeski.f90:    function RPH_EFT_Gamma3(a, deriv)
EFT_Horndeski.f90:        !Function that returns the EFT function gamma3 for RPH.
EFT_Horndeski.f90:    end function RPH_EFT_Gamma3
EFT_main.f90:!   For more informations about the methods contained in this file see
EFT_main.f90:!   the documentation: arXiv:1405.3590
EFT_main.f90:    use EFTfunctions
EFT_main.f90:    !We need to define this to interface the EFT functions with the RGR code.
EFT_main.f90:        function EFTfunction(a,ind) result(y)
EFT_main.f90:            use precision
EFT_main.f90:        end function EFTfunction
EFT_main.f90:    ! This two variables stores the pointer to the specific EFT function which is considered
EFT_main.f90:    procedure(EFTfunction), pointer :: EFTfuncTemp
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, OmegaTime)
EFT_main.f90:        call EFTdetectionRGR(RGR_EFTOmegaDot, EFTturnonpiInitial, 1._dl, OmegaDotTime)
EFT_main.f90:        call EFTdetectionRGR(RGR_EFTc, EFTturnonpiInitial, 1._dl, EFTcTime)
EFT_main.f90:        call EFTdetectionRGR(RGR_EFTcDot, EFTturnonpiInitial, 1._dl, EFTcDotTime)
EFT_main.f90:        call EFTdetectionRGR(RGR_EFTLambda, EFTturnonpiInitial, 1._dl, EFTLambdaTime)
EFT_main.f90:        call EFTdetectionRGR(RGR_EFTLambdaDot, EFTturnonpiInitial, 1._dl, EFTLambdaDotTime)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma1Time)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma2Time)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma3Time)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma4Time)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma5Time)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma6Time)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma1DotTime)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma2DotTime)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma3DotTime)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma4DotTime)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma5DotTime)
EFT_main.f90:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma6DotTime)
EFT_main.f90:    function EFTfunctionRGR(a)
EFT_main.f90:        ! This function is needed to make the two input variable EFT functions into a single input functions.
EFT_main.f90:        real(dl) :: EFTfunctionRGR
EFT_main.f90:        EFTfunctionRGR = ABS(EFTfuncTemp(a,deriv))
EFT_main.f90:    end function EFTfunctionRGR
EFT_main.f90:    subroutine EFTdetectionRGR(EFTfunction,TimeStart, TimeEnd, RGRtime)
EFT_main.f90:        ! Subroutine that test the return to GR of the EFT functions.
EFT_main.f90:        external EFTfunction
EFT_main.f90:        real(dl) :: EFTfunction
EFT_main.f90:        temp1 = EFTfunction(TimeStart) - EFTtoGR
EFT_main.f90:        temp2 = EFTfunction(TimeEnd) - EFTtoGR
EFT_main.f90:        else if (temp1*temp2<0.and. temp2>0) then   ! There is a transition
EFT_main.f90:            RGRtime = zbrent(EFTfunction,TimeStart,TimeEnd,1.d-10,EFTtoGR,succes)
EFT_main.f90:    end subroutine EFTdetectionRGR
EFT_main.f90:    function RGR_EFTOmegaDot(a)
EFT_main.f90:        !Dummy function for the absolute value of EFTOmegaDot
EFT_main.f90:    end function RGR_EFTOmegaDot
EFT_main.f90:    function RGR_EFTc(a)
EFT_main.f90:        !Dummy function for the absolute value of EFTc
EFT_main.f90:        ! 4) EFT functions:
EFT_main.f90:            case (3) ! EFT alternative parametrizations
EFT_main.f90:                        stop 'Wrong selection of model'
EFT_main.f90:    end function RGR_EFTc
EFT_main.f90:    function RGR_EFTcDot(a)
EFT_main.f90:        ! Dummy function for the absolute value of EFTcdot
EFT_main.f90:        ! 4) EFT functions:
EFT_main.f90:            case (3) ! EFT alternative parametrizations
EFT_main.f90:                        stop 'Wrong selection of model'
EFT_main.f90:    end function RGR_EFTcDOT
EFT_main.f90:    function RGR_EFTLambda(a)
EFT_main.f90:        ! Dummy function for the absolute value of EFTLambda
EFT_main.f90:        ! 4) EFT functions:
EFT_main.f90:            case (3) ! EFT alternative parametrizations
EFT_main.f90:                        stop 'Wrong selection of model'
EFT_main.f90:    end function RGR_EFTLambda
EFT_main.f90:    function RGR_EFTLambdaDot(a)
EFT_main.f90:        ! Dummy function for the absolute value of EFTLambdaDot
EFT_main.f90:        ! 4) EFT functions:
EFT_main.f90:            case (3) ! EFT alternative parametrizations
EFT_main.f90:                        stop 'Wrong selection of model'
EFT_main.f90:    end function RGR_EFTLambdaDot
EFT_main.f90:    use EFTfunctions
EFT_main.f90:                if (.not.EFTStabilityComputation(Atest)) then
EFT_main.f90:                if (.not.EFTStabilityComputation(Atest)) then
EFT_main.f90:                if (.not.EFTStabilityComputation(Atest)) then
EFT_main.f90:    function EFTStabilityComputation(a)
EFT_main.f90:        !This function computes if the stability requirements are fullfilled in a given time.
EFT_main.f90:        ! 1) Definitions of variables:
EFT_main.f90:        logical :: EFTStabilityComputation, EFT_HaveNan
EFT_main.f90:	real(dl) :: EFTbd_weff, EFTbd_weffprime !Dummy variables for BD dark energy equation of state and its derivative w.r.t. lna
EFT_main.f90:        ! 1) Stability check initialization
EFT_main.f90:        EFTStabilityComputation = .true.
EFT_main.f90:        ! 2) Computation of various quantities:
EFT_main.f90:        EFTtemp_H0     = sqrt(Designed_EFT_Function(hubble, 1.0_dl, 0._dl)**2.0/(grhom/3.0))*100
EFT_main.f90:        grhov_t=Designed_EFT_Function(omegadebara2,a,0._dl)
EFT_main.f90:        gpres        = gpres_matter + Designed_EFT_function(omegadepresbara2,a,0._dl)
EFT_main.f90:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
EFT_main.f90:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
EFT_main.f90:        ! 4) EFT functions:
EFT_main.f90:        ! 6) Pi field equation coefficients:
EFT_main.f90:        !    This is if we want also (or only) transfer functions.
EFT_main.f90:        ! for which a division by zero may occur.
EFT_main.f90:            EFTStabilityComputation = .false.
EFT_main.f90:            !    consistency of the pi field equation.
EFT_main.f90:            !    The first condition is A1/=0. Implemented by detecting sign changes in A1.
EFT_main.f90:                EFTStabilityComputation = .false.
EFT_main.f90:            !    The second one is the condition on k.
EFT_main.f90:                EFTStabilityComputation = .false.
EFT_main.f90:            !    violate the mathematical consistency of the tensor perturbation equation.
EFT_main.f90:                EFTStabilityComputation = .false.
EFT_main.f90:            !    This condition prevents the pi field from growing exponentially and destroying everything.
EFT_main.f90:            !    Even though this condition is not completely related to physics not mathematics, violating it
EFT_main.f90:            !    This condition needs to be tested in k. Sample in k.
EFT_main.f90:                        EFTStabilityComputation = .false.
EFT_main.f90:                        EFTStabilityComputation = .false.
EFT_main.f90:        ! Additional priors:
EFT_main.f90:        if (CP%EFTAdditionalPriors) then
EFT_main.f90:            if (EFTw(a,0)>-1._dl/3._dl) EFTStabilityComputation = .false.
EFT_main.f90:                        EFTStabilityComputation = .false.
EFT_main.f90:                        EFTStabilityComputation = .false.
EFT_main.f90:                EFTStabilityComputation = .false.
EFT_main.f90:            ! 1- Positive gravitational constant:
EFT_main.f90:                EFTStabilityComputation = .false.
EFT_main.f90:                if (Feedbacklevel > 0) write(*,*) 'EFTCAMB: negative gravitational constant', 1._dl +EFTOmegaV
EFT_main.f90:            ! 2- Old ghost and gradient conditions:
EFT_main.f90:                    EFTStabilityComputation = .false.
EFT_main.f90:                    EFTStabilityComputation = .false.
EFT_main.f90:                    EFTStabilityComputation = .false.
EFT_main.f90:                ! New ghost and gradient conditions:
EFT_main.f90:                ! ghost condition:
EFT_main.f90:                    EFTStabilityComputation = .false.
EFT_main.f90:                    EFTStabilityComputation = .false.
EFT_main.f90:                EFTStabilityComputation = .false.
EFT_main.f90:                EFTStabilityComputation = .false.
EFT_main.f90:            ! 7- Sub-luminal propagation:
EFT_main.f90:                    EFTStabilityComputation = .false.
EFT_main.f90:                    if (Feedbacklevel > 0) write(*,*) 'EFTCAMB: tachion perturbations'
EFT_main.f90:                    EFTStabilityComputation = .false.
EFT_main.f90:                    if (Feedbacklevel > 0) write(*,*) 'EFTCAMB: tachion perturbations'
EFT_main.f90:            ! 1) F(R): for this model it is easy to show that the positive mass condition requires that OmegaPrime
EFT_main.f90:                if (EFTOmega(0.11_dl*EFTturnonpiInitial,1)*EFTOmegaP<0) EFTStabilityComputation = .false.
EFT_main.f90:    end function EFTStabilityComputation
EFT_main.f90:!Performs EFT initialization just after CAMB is called.
EFT_main.f90:module EFTinitialization
EFT_main.f90:    use EFTfunctions
EFT_main.f90:    subroutine EFTCAMB_initialization(success)
EFT_main.f90:        if (Feedbacklevel>0) write(*,*) 'EFTCAMB initialization'
EFT_main.f90:    end subroutine EFTCAMB_initialization
EFT_main.f90:        if (CP%Omegav<0._dl.and.CP%EFTAdditionalPriors) then
EFT_main.f90:        ! 2) Dark energy should source cosmic acceleration:
EFT_main.f90:        if (CP%EFTAdditionalPriors) then
EFT_main.f90:        ! 3) Protection against weird input from CosmoMC:
EFT_main.f90:        if ( ( CP%Omegav<0._dl .or. CP%Omegav>1.0_dl).and.CP%EFTAdditionalPriors) then
EFT_main.f90:        if ( ( CP%omegac<0._dl .or. CP%omegac>1.0_dl).and.CP%EFTAdditionalPriors) then
EFT_main.f90:        if ( ( CP%omegab<0._dl .or. CP%omegab>1.0_dl).and.CP%EFTAdditionalPriors) then
EFT_main.f90:        if ( ( CP%H0<1._dl ).and.CP%EFTAdditionalPriors ) then
EFT_main.f90:        ! 4) One Horava condition:
EFT_main.f90:                if ( ( CP%Omegav+(CP%Horava_eta +3._dl*CP%Horava_lambda-2._dl*CP%Horava_xi)/(2._dl*CP%Horava_xi+2._dl-CP%Horava_eta) < 0._dl ).and.CP%EFTAdditionalPriors ) then
EFT_main.f90:            !                if ( ( CP%Omegav+(CP%Horava_eta +3._dl*CP%Horava_lambda-2._dl*CP%Horava_xi)/(2._dl*CP%Horava_xi+2._dl-CP%Horava_eta) > 1._dl ).and.CP%EFTAdditionalPriors ) then
EFT_main.f90:        write(*,*) ' Additional priors      = ', CP%EFTAdditionalPriors
EFT_main.f90:        ! This subroutine enforces the consistency of the EFTCAMB selection flags.
EFT_main.f90:        ! check Horava gravity. If Horava is selected the equation of state for dark energy should be -1
EFT_main.f90:end module EFTinitialization
EFT_main.f90~:!   For more informations about the methods contained in this file see
EFT_main.f90~:!   the documentation: arXiv:1405.3590
EFT_main.f90~:    use EFTfunctions
EFT_main.f90~:    !We need to define this to interface the EFT functions with the RGR code.
EFT_main.f90~:        function EFTfunction(a,ind) result(y)
EFT_main.f90~:            use precision
EFT_main.f90~:        end function EFTfunction
EFT_main.f90~:    ! This two variables stores the pointer to the specific EFT function which is considered
EFT_main.f90~:    procedure(EFTfunction), pointer :: EFTfuncTemp
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, OmegaTime)
EFT_main.f90~:        call EFTdetectionRGR(RGR_EFTOmegaDot, EFTturnonpiInitial, 1._dl, OmegaDotTime)
EFT_main.f90~:        call EFTdetectionRGR(RGR_EFTc, EFTturnonpiInitial, 1._dl, EFTcTime)
EFT_main.f90~:        call EFTdetectionRGR(RGR_EFTcDot, EFTturnonpiInitial, 1._dl, EFTcDotTime)
EFT_main.f90~:        call EFTdetectionRGR(RGR_EFTLambda, EFTturnonpiInitial, 1._dl, EFTLambdaTime)
EFT_main.f90~:        call EFTdetectionRGR(RGR_EFTLambdaDot, EFTturnonpiInitial, 1._dl, EFTLambdaDotTime)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma1Time)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma2Time)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma3Time)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma4Time)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma5Time)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma6Time)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma1DotTime)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma2DotTime)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma3DotTime)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma4DotTime)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma5DotTime)
EFT_main.f90~:        call EFTdetectionRGR(EFTfunctionRGR, EFTturnonpiInitial, 1._dl, EFTGamma6DotTime)
EFT_main.f90~:    function EFTfunctionRGR(a)
EFT_main.f90~:        ! This function is needed to make the two input variable EFT functions into a single input functions.
EFT_main.f90~:        real(dl) :: EFTfunctionRGR
EFT_main.f90~:        EFTfunctionRGR = ABS(EFTfuncTemp(a,deriv))
EFT_main.f90~:    end function EFTfunctionRGR
EFT_main.f90~:    subroutine EFTdetectionRGR(EFTfunction,TimeStart, TimeEnd, RGRtime)
EFT_main.f90~:        ! Subroutine that test the return to GR of the EFT functions.
EFT_main.f90~:        external EFTfunction
EFT_main.f90~:        real(dl) :: EFTfunction
EFT_main.f90~:        temp1 = EFTfunction(TimeStart) - EFTtoGR
EFT_main.f90~:        temp2 = EFTfunction(TimeEnd) - EFTtoGR
EFT_main.f90~:        else if (temp1*temp2<0.and. temp2>0) then   ! There is a transition
EFT_main.f90~:            RGRtime = zbrent(EFTfunction,TimeStart,TimeEnd,1.d-10,EFTtoGR,succes)
EFT_main.f90~:    end subroutine EFTdetectionRGR
EFT_main.f90~:    function RGR_EFTOmegaDot(a)
EFT_main.f90~:        !Dummy function for the absolute value of EFTOmegaDot
EFT_main.f90~:    end function RGR_EFTOmegaDot
EFT_main.f90~:    function RGR_EFTc(a)
EFT_main.f90~:        !Dummy function for the absolute value of EFTc
EFT_main.f90~:        ! 4) EFT functions:
EFT_main.f90~:            case (3) ! EFT alternative parametrizations
EFT_main.f90~:                        stop 'Wrong selection of model'
EFT_main.f90~:    end function RGR_EFTc
EFT_main.f90~:    function RGR_EFTcDot(a)
EFT_main.f90~:        ! Dummy function for the absolute value of EFTcdot
EFT_main.f90~:        ! 4) EFT functions:
EFT_main.f90~:            case (3) ! EFT alternative parametrizations
EFT_main.f90~:                        stop 'Wrong selection of model'
EFT_main.f90~:    end function RGR_EFTcDOT
EFT_main.f90~:    function RGR_EFTLambda(a)
EFT_main.f90~:        ! Dummy function for the absolute value of EFTLambda
EFT_main.f90~:        ! 4) EFT functions:
EFT_main.f90~:            case (3) ! EFT alternative parametrizations
EFT_main.f90~:                        stop 'Wrong selection of model'
EFT_main.f90~:    end function RGR_EFTLambda
EFT_main.f90~:    function RGR_EFTLambdaDot(a)
EFT_main.f90~:        ! Dummy function for the absolute value of EFTLambdaDot
EFT_main.f90~:        ! 4) EFT functions:
EFT_main.f90~:            case (3) ! EFT alternative parametrizations
EFT_main.f90~:                        stop 'Wrong selection of model'
EFT_main.f90~:    end function RGR_EFTLambdaDot
EFT_main.f90~:    use EFTfunctions
EFT_main.f90~:                if (.not.EFTStabilityComputation(Atest)) then
EFT_main.f90~:                if (.not.EFTStabilityComputation(Atest)) then
EFT_main.f90~:                if (.not.EFTStabilityComputation(Atest)) then
EFT_main.f90~:    function EFTStabilityComputation(a)
EFT_main.f90~:        !This function computes if the stability requirements are fullfilled in a given time.
EFT_main.f90~:        ! 1) Definitions of variables:
EFT_main.f90~:        logical :: EFTStabilityComputation, EFT_HaveNan
EFT_main.f90~:	real(dl) :: EFTbd_weff, EFTbd_weffprime !Dummy variables for BD dark energy equation of state and its derivative w.r.t. lna
EFT_main.f90~:        ! 1) Stability check initialization
EFT_main.f90~:        EFTStabilityComputation = .true.
EFT_main.f90~:        ! 2) Computation of various quantities:
EFT_main.f90~:        EFTtemp_H0     = sqrt(Designed_EFT_Function(hubble, 1.0_dl, 0._dl)**2.0/(grhom/3.0))*100
EFT_main.f90~:        grhov_t=Designed_EFT_Function(omegadebara2,a,0._dl)
EFT_main.f90~:        gpres        = gpres_matter + Designed_EFT_function(omegadepresbara2,a,0._dl)
EFT_main.f90~:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
EFT_main.f90~:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
EFT_main.f90~:        ! 4) EFT functions:
EFT_main.f90~:        ! 6) Pi field equation coefficients:
EFT_main.f90~:        !    This is if we want also (or only) transfer functions.
EFT_main.f90~:        ! for which a division by zero may occur.
EFT_main.f90~:            EFTStabilityComputation = .false.
EFT_main.f90~:            !    consistency of the pi field equation.
EFT_main.f90~:            !    The first condition is A1/=0. Implemented by detecting sign changes in A1.
EFT_main.f90~:                EFTStabilityComputation = .false.
EFT_main.f90~:            !    The second one is the condition on k.
EFT_main.f90~:                EFTStabilityComputation = .false.
EFT_main.f90~:            !    violate the mathematical consistency of the tensor perturbation equation.
EFT_main.f90~:                EFTStabilityComputation = .false.
EFT_main.f90~:            !    This condition prevents the pi field from growing exponentially and destroying everything.
EFT_main.f90~:            !    Even though this condition is not completely related to physics not mathematics, violating it
EFT_main.f90~:            !    This condition needs to be tested in k. Sample in k.
EFT_main.f90~:                        EFTStabilityComputation = .false.
EFT_main.f90~:                        EFTStabilityComputation = .false.
EFT_main.f90~:        ! Additional priors:
EFT_main.f90~:        if (CP%EFTAdditionalPriors) then
EFT_main.f90~:            if (EFTw(a,0)>-1._dl/3._dl) EFTStabilityComputation = .false.
EFT_main.f90~:                        EFTStabilityComputation = .false.
EFT_main.f90~:                        EFTStabilityComputation = .false.
EFT_main.f90~:                EFTStabilityComputation = .false.
EFT_main.f90~:            ! 1- Positive gravitational constant:
EFT_main.f90~:                EFTStabilityComputation = .false.
EFT_main.f90~:                if (Feedbacklevel > 0) write(*,*) 'EFTCAMB: negative gravitational constant', 1._dl +EFTOmegaV
EFT_main.f90~:            ! 2- Old ghost and gradient conditions:
EFT_main.f90~:                    EFTStabilityComputation = .false.
EFT_main.f90~:                    EFTStabilityComputation = .false.
EFT_main.f90~:                    EFTStabilityComputation = .false.
EFT_main.f90~:                ! New ghost and gradient conditions:
EFT_main.f90~:                ! ghost condition:
EFT_main.f90~:                    EFTStabilityComputation = .false.
EFT_main.f90~:                    EFTStabilityComputation = .false.
EFT_main.f90~:                EFTStabilityComputation = .false.
EFT_main.f90~:                EFTStabilityComputation = .false.
EFT_main.f90~:            ! 7- Sub-luminal propagation:
EFT_main.f90~:                    EFTStabilityComputation = .false.
EFT_main.f90~:                    if (Feedbacklevel > 0) write(*,*) 'EFTCAMB: tachion perturbations'
EFT_main.f90~:                    EFTStabilityComputation = .false.
EFT_main.f90~:                    if (Feedbacklevel > 0) write(*,*) 'EFTCAMB: tachion perturbations'
EFT_main.f90~:            ! 1) F(R): for this model it is easy to show that the positive mass condition requires that OmegaPrime
EFT_main.f90~:                if (EFTOmega(0.11_dl*EFTturnonpiInitial,1)*EFTOmegaP<0) EFTStabilityComputation = .false.
EFT_main.f90~:    end function EFTStabilityComputation
EFT_main.f90~:!Performs EFT initialization just after CAMB is called.
EFT_main.f90~:module EFTinitialization
EFT_main.f90~:    use EFTfunctions
EFT_main.f90~:    subroutine EFTCAMB_initialization(success)
EFT_main.f90~:        if (Feedbacklevel>0) write(*,*) 'EFTCAMB initialization'
EFT_main.f90~:    end subroutine EFTCAMB_initialization
EFT_main.f90~:        if (CP%Omegav<0._dl.and.CP%EFTAdditionalPriors) then
EFT_main.f90~:        ! 2) Dark energy should source cosmic acceleration:
EFT_main.f90~:        if (CP%EFTAdditionalPriors) then
EFT_main.f90~:        ! 3) Protection against weird input from CosmoMC:
EFT_main.f90~:        if ( ( CP%Omegav<0._dl .or. CP%Omegav>1.0_dl).and.CP%EFTAdditionalPriors) then
EFT_main.f90~:        if ( ( CP%omegac<0._dl .or. CP%omegac>1.0_dl).and.CP%EFTAdditionalPriors) then
EFT_main.f90~:        if ( ( CP%omegab<0._dl .or. CP%omegab>1.0_dl).and.CP%EFTAdditionalPriors) then
EFT_main.f90~:        if ( ( CP%H0<1._dl ).and.CP%EFTAdditionalPriors ) then
EFT_main.f90~:        ! 4) One Horava condition:
EFT_main.f90~:                if ( ( CP%Omegav+(CP%Horava_eta +3._dl*CP%Horava_lambda-2._dl*CP%Horava_xi)/(2._dl*CP%Horava_xi+2._dl-CP%Horava_eta) < 0._dl ).and.CP%EFTAdditionalPriors ) then
EFT_main.f90~:            !                if ( ( CP%Omegav+(CP%Horava_eta +3._dl*CP%Horava_lambda-2._dl*CP%Horava_xi)/(2._dl*CP%Horava_xi+2._dl-CP%Horava_eta) > 1._dl ).and.CP%EFTAdditionalPriors ) then
EFT_main.f90~:        write(*,*) ' Additional priors      = ', CP%EFTAdditionalPriors
EFT_main.f90~:        ! This subroutine enforces the consistency of the EFTCAMB selection flags.
EFT_main.f90~:        ! check Horava gravity. If Horava is selected the equation of state for dark energy should be -1
EFT_main.f90~:end module EFTinitialization
EFT_stabilitySpace.f90:!   For more informations about the methods contained in this file see
EFT_stabilitySpace.f90:!   the documentation: arXiv:1405.3590
EFT_stabilitySpace.f90:module StabilityFunctions
EFT_stabilitySpace.f90:    use precision
EFT_stabilitySpace.f90:    function Test1D(param)
EFT_stabilitySpace.f90:        ! Step function for 1D test purposes.
EFT_stabilitySpace.f90:    end function Test1D
EFT_stabilitySpace.f90:    function Test2D(param1, param2)
EFT_stabilitySpace.f90:        ! Step function for 2D test purposes.
EFT_stabilitySpace.f90:    end function Test2D
EFT_stabilitySpace.f90:    function Test3D(param1, param2, param3)
EFT_stabilitySpace.f90:        ! Step function for 3D test purposes.
EFT_stabilitySpace.f90:    end function Test3D
EFT_stabilitySpace.f90:    function Stability1D(param)
EFT_stabilitySpace.f90:        ! Binary function that gives the stability varying 1 parameter.
EFT_stabilitySpace.f90:        use EFTinitialization
EFT_stabilitySpace.f90:        ! 3) Call the EFT initialization module to check the stability:
EFT_stabilitySpace.f90:        call EFTCAMB_initialization(success)
EFT_stabilitySpace.f90:    end function Stability1D
EFT_stabilitySpace.f90:    function Stability2D(param1, param2)
EFT_stabilitySpace.f90:        ! Binary function that gives the stability varying 2 parameters.
EFT_stabilitySpace.f90:        use EFTinitialization
EFT_stabilitySpace.f90:        ! 3) Call the EFT initialization module to check the stability:
EFT_stabilitySpace.f90:        call EFTCAMB_initialization(success)
EFT_stabilitySpace.f90:    end function Stability2D
EFT_stabilitySpace.f90:    function Stability3D(param1, param2, param3)
EFT_stabilitySpace.f90:        ! Binary function that gives the stability varying 2 parameters.
EFT_stabilitySpace.f90:        use EFTinitialization
EFT_stabilitySpace.f90:        ! 3) Call the EFT initialization module to check the stability:
EFT_stabilitySpace.f90:        call EFTCAMB_initialization(success)
EFT_stabilitySpace.f90:    end function Stability3D
EFT_stabilitySpace.f90:end module StabilityFunctions
EFT_stabilitySpace.f90:    use precision
EFT_stabilitySpace.f90:    subroutine Grid_Sampling1D(function, IntMin, IntMax, Points, Results)
EFT_stabilitySpace.f90:        ! Subroutine that performs sampling of a 1D function on a grid of points.
EFT_stabilitySpace.f90:        ! function = function to be sampled                                     (in)
EFT_stabilitySpace.f90:        ! IntMin   = minimum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        ! IntMax   = maximum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        !            dimension (2,Points) containing the points of the form
EFT_stabilitySpace.f90:        !            (x,function(x))
EFT_stabilitySpace.f90:            function function(x)
EFT_stabilitySpace.f90:                use precision
EFT_stabilitySpace.f90:                real(dl) ::  function
EFT_stabilitySpace.f90:            end function function
EFT_stabilitySpace.f90:            y = function(x)
EFT_stabilitySpace.f90:    subroutine Adaptive_Sampling1D(function, IntMin, IntMax, Points, Results, Recursions)
EFT_stabilitySpace.f90:        ! Subroutine that performs an adaptively refined sampling of a 1D function.
EFT_stabilitySpace.f90:        ! function   = function to be sampled                                     (in)
EFT_stabilitySpace.f90:        ! IntMin     = minimum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        ! IntMax     = maximum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        !              containing the points of the form (x,function(x))
EFT_stabilitySpace.f90:        ! Recursions = (OPTIONAL) maximum number of points in which               (in)
EFT_stabilitySpace.f90:            function function(x)
EFT_stabilitySpace.f90:                use precision
EFT_stabilitySpace.f90:                real(dl) ::  function
EFT_stabilitySpace.f90:            end function function
EFT_stabilitySpace.f90:        integer , optional    :: Recursions
EFT_stabilitySpace.f90:        ! 1) If the maximum number of recursions is not in input set it to 5
EFT_stabilitySpace.f90:        if (.not.present(Recursions)) Recursions = 5
EFT_stabilitySpace.f90:        ! 2) Allocate Temp as the maximum number of points possible given Recursions
EFT_stabilitySpace.f90:        allocate(Temp(2,Points*(Recursions+1)),Temp2(2,Points))
EFT_stabilitySpace.f90:            y = function(x)
EFT_stabilitySpace.f90:                call Interval_Recursive_Sampler(function, x1, x2, y1, y2, LocalCounter, Recursions,&
EFT_stabilitySpace.f90:                    & Temp, Points*(Recursions+1), GlobalCounter)
EFT_stabilitySpace.f90:    recursive subroutine Interval_Recursive_Sampler(function, x1, x2, y1, y2, counter, MaxRecursion,&
EFT_stabilitySpace.f90:        ! This works good for our purposes but not so well for a generic function.
EFT_stabilitySpace.f90:        ! The criterium for refining is based on a combination of first and second derivatives.
EFT_stabilitySpace.f90:        external function
EFT_stabilitySpace.f90:        real(dl) :: function
EFT_stabilitySpace.f90:        integer , intent(in)    :: MaxRecursion
EFT_stabilitySpace.f90:        if (counter >= MaxRecursion) return
EFT_stabilitySpace.f90:            ym = function(xm)
EFT_stabilitySpace.f90:                call Interval_Recursive_Sampler(function, x1, xm, y1, ym, counter, MaxRecursion,&
EFT_stabilitySpace.f90:                call Interval_Recursive_Sampler(function, xm, x2, ym, y2, counter, MaxRecursion,&
EFT_stabilitySpace.f90:    subroutine Grid_Sampling2D(function, IntMin1, IntMax1, IntMin2, IntMax2, Points, Results)
EFT_stabilitySpace.f90:        ! function = function to be sampled                                     (in)
EFT_stabilitySpace.f90:        ! IntMin1  = minimum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        ! IntMax1  = maximum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        ! IntMin2  = minimum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        ! IntMax2  = maximum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        !            dimension (2,Points) containing the points of the form
EFT_stabilitySpace.f90:        !            (x,function(x))
EFT_stabilitySpace.f90:        external function
EFT_stabilitySpace.f90:        real(dl) :: function
EFT_stabilitySpace.f90:                z = function(x,y)
EFT_stabilitySpace.f90:    subroutine Grid_Sampling3D(function, IntMin1, IntMax1, IntMin2, IntMax2, IntMin3, IntMax3, Points, Results)
EFT_stabilitySpace.f90:        ! function = function to be sampled                                     (in)
EFT_stabilitySpace.f90:        ! IntMin1  = minimum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        ! IntMax1  = maximum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        ! IntMin2  = minimum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        ! IntMax2  = maximum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        ! IntMin3  = minimum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        ! IntMax3  = maximum of the interval in which the function is sampled   (in)
EFT_stabilitySpace.f90:        !            dimension (2,Points) containing the points of the form
EFT_stabilitySpace.f90:        !            (x,function(x))
EFT_stabilitySpace.f90:        external function
EFT_stabilitySpace.f90:        real(dl) :: function
EFT_stabilitySpace.f90:                    f = function(x,y,z)
EFT_stabilitySpace.f90:    use EFTinitialization
EFT_stabilitySpace.f90:    use StabilityFunctions
EFT_stabilitySpace.f90:    subroutine SamplePureEFT1D(NumPoints, IntMin, IntMax, OutRoot, MaxRecursions)
EFT_stabilitySpace.f90:        ! Subroutine to test at once every 1 parameter, pure EFT, extension of the standard model.
EFT_stabilitySpace.f90:        integer, optional :: MaxRecursions
EFT_stabilitySpace.f90:        ! 1) Set MaxRecursions
EFT_stabilitySpace.f90:        if (.not.present(MaxRecursions)) MaxRecursions = 5
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        ! Subroutine to test at once every 1 parameter, pure EFT, extension of the standard model
EFT_stabilitySpace.f90:    subroutine SampleDesigner1D(NumPoints, OutRoot, MaxRecursions)
EFT_stabilitySpace.f90:        integer, optional    :: MaxRecursions
EFT_stabilitySpace.f90:        ! 1) Set MaxRecursions
EFT_stabilitySpace.f90:        if (.not.present(MaxRecursions)) MaxRecursions = 5
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, -2._dl, 2._dl, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, -2._dl, 0._dl, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:    subroutine SampleRPH1D(NumPoints, IntMin, IntMax, OutRoot, MaxRecursions)
EFT_stabilitySpace.f90:        ! Subroutine to test at once every 1 parameter RPH extension of the standard model.
EFT_stabilitySpace.f90:        integer, optional :: MaxRecursions
EFT_stabilitySpace.f90:        ! 1) Set MaxRecursions
EFT_stabilitySpace.f90:        if (.not.present(MaxRecursions)) MaxRecursions = 5
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        ! Subroutine to test at once every 2 parameter RPH extension of the standard model.
EFT_stabilitySpace.f90:        ! Subroutine to test at once every combination of constant RPH functions.
EFT_stabilitySpace.f90:        write(*,*) 'RPH constant combinations stability check done.'
EFT_stabilitySpace.f90:    subroutine SamplePureEFT_Hordenski_1D(NumPoints, IntMin, IntMax, OutRoot, MaxRecursions)
EFT_stabilitySpace.f90:        ! Subroutine to test at once every 1 parameter RPH extension of the standard model.
EFT_stabilitySpace.f90:        integer, optional :: MaxRecursions
EFT_stabilitySpace.f90:        ! 1) Set MaxRecursions
EFT_stabilitySpace.f90:        if (.not.present(MaxRecursions)) MaxRecursions = 5
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:    subroutine Sample_EFT_Horava_1D(NumPoints, IntMin, IntMax, OutRoot, MaxRecursions)
EFT_stabilitySpace.f90:        ! Subroutine to test at once every 1 parameter Horava extensions of the standard model.
EFT_stabilitySpace.f90:        integer, optional :: MaxRecursions
EFT_stabilitySpace.f90:        ! 1) Set MaxRecursions
EFT_stabilitySpace.f90:        if (.not.present(MaxRecursions)) MaxRecursions = 5
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        call Adaptive_Sampling1D(Stability1D, IntMin, IntMax, NumPoints, res, Recursions = MaxRecursions)
EFT_stabilitySpace.f90:        ! Subroutine to test at once every 2 parameter Horava extension of the standard model.
EFT_stabilitySpace.f90:    use EFTinitialization
EFT_stabilitySpace.f90:    use StabilityFunctions
EFT_stabilitySpace.f90:    integer  :: counter, MaxRecursion, num, rec
EFT_stabilitySpace.f90:    P%EFTAdditionalPriors        = .true.
EFT_stabilitySpace.f90:        P%OutputNormalization = outNone
EFT_stabilitySpace.f90:        P%AccuratePolarization = .true.
EFT_stabilitySpace.f90:        P%Transfer%high_precision=.false.
EFT_stabilitySpace.f90:    call SamplePureEFT1D(num, -2._dl, 2._dl, OutRoot, MaxRecursions = rec)
EFT_stabilitySpace.f90:    call SampleDesigner1D(num, OutRoot, MaxRecursions = rec)
EFT_stabilitySpace.f90:    call SampleRPH1D(num, -2._dl, 2._dl, OutRoot, MaxRecursions = rec)
EFT_stabilitySpace.f90:    call SamplePureEFT_Hordenski_1D(num, -2._dl, 2._dl, OutRoot, MaxRecursions = rec)
EFT_stabilitySpace.f90:    call Sample_EFT_Horava_1D(num, -2._dl, 2._dl, OutRoot, MaxRecursions = rec)
equations_EFT.f90:    ! Equations module for dark energy with constant equation of state parameter w
equations_EFT.f90:    ! allowing for perturbations based on a quintessence model
equations_EFT.f90:    ! Changes to tight coupling approximation
equations_EFT.f90:    ! August 2004, fixed reionization term in lensing potential
equations_EFT.f90:    ! Apr 2005, added DoLateRadTruncation option
equations_EFT.f90:    ! Nov 2006, tweak to high_precision transfer function accuracy at lowish k
equations_EFT.f90:    ! June 2011, improved radiation approximations from arXiv: 1104.2933; Some 2nd order tight coupling terms
equations_EFT.f90:    !            merged fderivs and derivs so flat and non-flat use same equations; more precomputed arrays
equations_EFT.f90:    !            optimized neutrino sampling, and reorganised neutrino integration functions
equations_EFT.f90:    use precision
equations_EFT.f90:    function GetOmegak()
equations_EFT.f90:    use precision
equations_EFT.f90:    end function GetOmegak
equations_EFT.f90:        use EFTFunctions
equations_EFT.f90:    H0 = sqrt(Designed_EFT_Function(hubble, 1.0_dl, 0._dl)**2.0/(grhom/3.0))*100
equations_EFT.f90:        !This is only called once per model, and is a good point to do any extra initialization.
equations_EFT.f90:	use EFTInitialization
equations_EFT.f90:        ! EFTCAMB MOD START: impose Horava conditions for Solar System free models
equations_EFT.f90:    	call EFTCAMB_initialization(EFTsuccess)
equations_EFT.f90:    !Background evolution
equations_EFT.f90:    function dtauda(a)
equations_EFT.f90:    use precision
equations_EFT.f90:    use EFTfunctions
equations_EFT.f90:		grhoa2 = (grhog+grhornomass)*(1._dl/Designed_EFT_function(phibd,a_aux,0.0_dl))
equations_EFT.f90:		grhoa2 = grhok*a2 + (grhoc+grhob)*a_aux+ grhog + grhornomass + Designed_EFT_function(omegadebara4,a_aux,0.0_dl)
equations_EFT.f90:    end function dtauda
equations_EFT.f90:    !Gauge-dependent perturbation equations
equations_EFT.f90:    use precision
equations_EFT.f90:    use EFTfunctions
equations_EFT.f90:    !Description of this file. Change if you make modifications.
equations_EFT.f90:    logical :: DoLateRadTruncation = .true.
equations_EFT.f90:    !if true, use smooth approx to radition perturbations after decoupling on
equations_EFT.f90:    !small scales, saving evolution of irrelevant osciallatory multipole equations
equations_EFT.f90:    !Note higher values increase size of Evolution vars, hence memory
equations_EFT.f90:    !Supported scalar initial condition flags
equations_EFT.f90:    type EvolutionVars
equations_EFT.f90:        integer w_ix !Index of two quintessence equations
equations_EFT.f90:        !       nvar  - number of scalar (tensor) equations for this k
equations_EFT.f90:        integer polind  !index into scalar array of polarization hierarchy
equations_EFT.f90:        !array indices for massive neutrino equations
equations_EFT.f90:        !True when using non-relativistic approximation
equations_EFT.f90:        !True when using tight-coupling approximation (required for stability at early times)
equations_EFT.f90:        !Numer of scalar equations we are propagating
equations_EFT.f90:        integer E_ix, B_ix !tensor polarization indices
equations_EFT.f90:    end type EvolutionVars
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:        //'compiling with bounds checking may (or may not) help find the problem.',error_evolution)
equations_EFT.f90:    function next_nu_nq(nq) result (next_nq)
equations_EFT.f90:    end function next_nu_nq
equations_EFT.f90:    type(EvolutionVars) EV, EVout
equations_EFT.f90:    !Evolve equations from tau to tauend, performing switches in equations if necessary.
equations_EFT.f90:    if (DoLateRadTruncation) then
equations_EFT.f90:                call EFTpiInitialConditions(y,EV,tau)
equations_EFT.f90:    type(EvolutionVars) EV, EVOut
equations_EFT.f90:    function DeltaTimeMaxed(a1,a2, tol) result(t)
equations_EFT.f90:    real(dl), optional :: tol
equations_EFT.f90:    end function DeltaTimeMaxed
equations_EFT.f90:    !Set the numer of equations in each hierarchy, and get total number of equations for this k
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    integer, intent(out), optional :: max_num_eqns
equations_EFT.f90:            !Polarization multipoles
equations_EFT.f90:            EV%polind = neq -1 !polind+2 is L=2, for polarizationthe first calculated
equations_EFT.f90:            if (nu_masses(nu_i) > 5000 .and. CP%Transfer%high_precision) EV%lmaxnu_tau(nu_i) = EV%lmaxnu_tau(nu_i)*2 !megadamping
equations_EFT.f90:    type(EvolutionVars) EV, EVOut
equations_EFT.f90:                    !Add leading correction for the mass
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    integer, optional, intent(out) :: maxeq
equations_EFT.f90:    type(EvolutionVars) EV, EVOut
equations_EFT.f90:    !Set the numer of equations in each hierarchy, and get total number of equations for this k
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:        if (CP%Transfer%high_precision) then
equations_EFT.f90:        if (HighAccuracyDefault .and. CP%AccuratePolarization) then
equations_EFT.f90:        if (.not.CP%AccuratePolarization) EV%lmaxgpol=max(nint(4*lAccuracyBoost),3)
equations_EFT.f90:            !Large scales need fewer equations
equations_EFT.f90:            if (CP%AccuratePolarization) scal = 4  !But need more to get polarization right
equations_EFT.f90:            if (CP%AccurateReionization) then
equations_EFT.f90:        if (CP%Transfer%high_precision) then
equations_EFT.f90:            if (EV%q > 0.04 .and. EV%q < 0.5) then !baryon oscillation scales
equations_EFT.f90:    !energy-integrated hierarchy going up to third order in velocity dispersion
equations_EFT.f90:    type(EvolutionVars) EV, EVout
equations_EFT.f90:    !Get density and pressure as ratio to massles by interpolation from table
equations_EFT.f90:    !Analytic solution for higher moments, proportional to a^{-3}
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    real(dl), optional :: grho,gpres,dgrho,dgq,dgpi, gdpi_diff,pidot_sum,clxnu_all
equations_EFT.f90:        !Get density and pressure as ratio to massless by interpolation from table
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    !  Compute the perturbations of density and energy flux
equations_EFT.f90:    real(dl), optional, intent(OUT) :: dpnu,pinu
equations_EFT.f90:        !Get the rest from perturbatively relativistic expansion
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    !  and the shear perturbation.
equations_EFT.f90:    function Nu_pi(EV, y, a, nu_i) result(pinu)
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    end function Nu_pi
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    !  Compute the third order variables (in velocity dispersion)
equations_EFT.f90:        type(EvolutionVars) EV
equations_EFT.f90:        real(dl), intent(out), optional :: wnu_arr(max_nu)
equations_EFT.f90:        real(dl), intent(out), optional :: dgp
equations_EFT.f90:        !Get density and pressure as ratio to massless by interpolation from table
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    real(dl), dimension(:),pointer :: ypol,ypolprime
equations_EFT.f90:        ! EFTCAMB MOD START: definitions of EFTCAMB quantities
equations_EFT.f90:        ! storage for EFT functions.
equations_EFT.f90:        ! perturbations quantities.
equations_EFT.f90:        real(dl) EFTpiA, EFTpiB, EFTpiC, EFTpiD, EFTpiE                 ! pi field equations
equations_EFT.f90:        real(dl) EFTeomF, EFTeomN, EFTeomX, EFTeomY, EFTeomG, EFTeomU   ! equations of motion
equations_EFT.f90:        real(dl)  EFT_Psi, EFT_Phi, EFT_function_mu, EFT_function_gamma, EFT_xi
equations_EFT.f90:    !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90:        ! EFTCAMB MOD START: Computation of DE background density.
equations_EFT.f90:	    	grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90:        ! EFTCAMB MOD START: computation of gpres.
equations_EFT.f90:	    gpres=(grhog_t+grhor_t)/3._dl +Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90:    !  8*pi*a*a*SUM[rho_i*clx_i] add radiation later
equations_EFT.f90:        ! EFTCAMB MOD START: initialization of DE perturbations.
equations_EFT.f90:    ! EFTCAMB MOD START: full mapping models expansion history:
equations_EFT.f90:        ! EFTCAMB MOD START: Computation of background quantities:
equations_EFT.f90:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90:        ! 2) Compute and write once for all the values of the EFT functions.
equations_EFT.f90:        ! 3) Computation of EFT background quantities.
equations_EFT.f90:        ! EFTCAMB MOD START: computation of Einstein equations factors.
equations_EFT.f90:        ! Debug code. Prints Einstein equations factors.
equations_EFT.f90:        ! EFTCAMB MOD START: compute z,dz before loading radiation and photon
equations_EFT.f90:            ! RSA approximation.
equations_EFT.f90:        !equations of motion 1.
equations_EFT.f90:        ! EFTCAMB MOD START: equation of motion 3.
equations_EFT.f90:        ! EFTCAMB MOD START: computation of quantities used to construct the sources.
equations_EFT.f90:        !E polarization source
equations_EFT.f90:        ! EFTCAMB MOD START: computation of mu and gamma. These are not used but it's nice to have the possibility to plot them...
equations_EFT.f90:            EFT_function_mu = -2._dl*k*(EFTsigmadot+adotoa*sigma)/(dgrho)
equations_EFT.f90:            EFT_function_gamma = (etak - adotoa*sigma)/(EFTsigmadot + adotoa*sigma)
equations_EFT.f90:                write (10,'(10e15.5)') a, tau, 1._dl/a-1._dl, k, EFT_function_mu, EFT_function_gamma, EFT_xi
equations_EFT.f90:    type(EvolutionVars) :: EV
equations_EFT.f90:    real(dl), dimension(:),pointer :: E,Bprime,Eprime
equations_EFT.f90:        !  Use the full expression for pigdt
equations_EFT.f90:        !  Use the tight-coupling approximation
equations_EFT.f90:    type(EvolutionVars) :: EV
equations_EFT.f90:    real(dl), dimension(:),pointer :: E,Eprime
equations_EFT.f90:    !  Initial conditions.
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    if (CP%Scalar_initial_condition > initial_nummodes) &
equations_EFT.f90:    stop 'Invalid initial condition for scalar modes'
equations_EFT.f90:    !  Set adiabatic initial conditions
equations_EFT.f90:    chi=1  !Get transfer function for chi
equations_EFT.f90:    if (CP%Scalar_initial_condition/= initial_adiabatic) then
equations_EFT.f90:        if (Rc==0) stop 'Isocurvature initial conditions assume non-zero dark matter'
equations_EFT.f90:    if (CP%Scalar_initial_condition==initial_vector) then
equations_EFT.f90:            InitVec = InitVec+ initv(i,:)*CP%InitialConditionVector(i)
equations_EFT.f90:        InitVec = initv(CP%Scalar_initial_condition,:)
equations_EFT.f90:        if (CP%Scalar_initial_condition==initial_adiabatic) InitVec = -InitVec
equations_EFT.f90:    !  Initial conditions for tensors
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:        EV%denlkt(3,l)=k*denl(l)*tensfac**2/(l+1)*EV%Kft(l) !term for polarization
equations_EFT.f90:        EV%denlkt(4,l)=k*4._dl/(l*(l+1))*EV%aux_buf !other for polarization
equations_EFT.f90:    !  Initial conditions for vectors
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    !  Evaluate the time derivatives of the perturbations
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:        ! EFTCAMB MOD START: definition of variables
equations_EFT.f90:        ! storage for EFT functions.
equations_EFT.f90:        ! perturbations quantities.
equations_EFT.f90:        real(dl) EFTpiA, EFTpiB, EFTpiC, EFTpiD, EFTpiE                 ! pi field equations
equations_EFT.f90:        real(dl) EFTeomF, EFTeomN, EFTeomX, EFTeomY, EFTeomG, EFTeomU   ! equations of motion
equations_EFT.f90:    !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90:	    	grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90:    !  Get sound speed and ionisation fraction.
equations_EFT.f90:    !total perturbations: matter terms first, then add massive nu, de and radiation
equations_EFT.f90:        ! EFTCAMB MOD START: protection against non flatness.
equations_EFT.f90:        ! EFTCAMB MOD START: full mapping models expansion history:
equations_EFT.f90:        ! EFTCAMB MOD START: Computation of background quantities:
equations_EFT.f90:        ! 1) Computation of FRW background quantities.
equations_EFT.f90:            gpres=gpres + (grhog_t+grhor_t)/3._dl +Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90:        ! 2) Compute and write once for all the values of the EFT functions.
equations_EFT.f90:        ! 3) Computation of EFT background quantities.
equations_EFT.f90:        ! EFTCAMB MOD START: initialization of DE perturbations.
equations_EFT.f90:        ! EFTCAMB MOD START: computation of Einstein equations factors.
equations_EFT.f90:        ! Debug code. Prints EFT Einstein equations factors.
equations_EFT.f90:        ! EFTCAMB MOD START: compute z,dz before loading radiation and photon
equations_EFT.f90:        !RSA approximation of arXiv:1104.2933, dropping opactity terms in the velocity
equations_EFT.f90:    !  8*pi*a*a*SUM[rho_i*clx_i] - radiation terms
equations_EFT.f90:        ! EFTCAMB MOD START: equation of motion. Now we use the non-RSA expression for dz.
equations_EFT.f90:        !  !eta*k equation
equations_EFT.f90:        ! EFTCAMB MOD START: Pi field equation.
equations_EFT.f90:        ! 1) Computation of pi field equation prefactors.
equations_EFT.f90:        ! 2) Solution of the pi field equation of motion.
equations_EFT.f90:            ! strategies to adopt if the theory does not propagate an additional dof
equations_EFT.f90:    !  CDM equation of motion
equations_EFT.f90:    !  Baryon equation of motion.
equations_EFT.f90:    !  Photon equation of motion
equations_EFT.f90:    ! old comment:Small k: potential problem with stability, using full equations earlier is NOT more accurate in general
equations_EFT.f90:    ! Easy to see instability in k \sim 1e-3 by tracking evolution of vb
equations_EFT.f90:    !  Use explicit equation for vb if appropriate
equations_EFT.f90:        !  First-order approximation to baryon-photon splip
equations_EFT.f90:        !  Use tight-coupling approximation for vb
equations_EFT.f90:        !  zeroth order approximation to vbdot + the pig term
equations_EFT.f90:        !  Photon equations of motion
equations_EFT.f90:        !  Use explicit equations for photon moments if appropriate
equations_EFT.f90:                !  Truncate the photon moment expansion
equations_EFT.f90:            !  Polarization
equations_EFT.f90:        !  Massless neutrino equations of motion.
equations_EFT.f90:            !ufa approximation for k*tau>>1, more accurate when there are reflections from lmax
equations_EFT.f90:                !  Truncate the neutrino expansion
equations_EFT.f90:    !  Massive neutrino equations of motion.
equations_EFT.f90:                    !  Truncate moment expansion.
equations_EFT.f90:    !  Evaluate the time derivatives of the vector perturbations, flat case
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    real(dl), dimension(:),pointer :: neut,neutprime,E,B,Eprime,Bprime
equations_EFT.f90:    ! Compute expansion rate from: grho=8*pi*rho*a**2
equations_EFT.f90:    !for non-large k this expression for sigma is unstable at early times
equations_EFT.f90:    !so propagate sigma equation separately (near total cancellation in rhoq)
equations_EFT.f90:        !  Use explicit equations:
equations_EFT.f90:        !  Equation for the photon heat flux stress
equations_EFT.f90:        !  Equation for the photon anisotropic stress
equations_EFT.f90:        !E equations
equations_EFT.f90:        !B-bar equations
equations_EFT.f90:        !Tight coupling expansion results
equations_EFT.f90:        !  Equation for the photon heat flux
equations_EFT.f90:        ! Get drag from vbdot expression
equations_EFT.f90:    !  Neutrino equations:
equations_EFT.f90:    !  Get the propagation equation for the shear
equations_EFT.f90:    !  Evaluate the time derivatives of the tensor perturbations.
equations_EFT.f90:    type(EvolutionVars) EV
equations_EFT.f90:    real(dl), dimension(:),pointer :: neut,neutprime,E,B,Eprime,Bprime
equations_EFT.f90:    ! Compute expansion rate from: grho=8*pi*rho*a**2
equations_EFT.f90:	    	grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90:    ! EFTCAMB MOD START: full mapping models expansion history:
equations_EFT.f90:        !  Don't use tight coupling approx - use explicit equations:
equations_EFT.f90:        !  Equation for the photon anisotropic stress
equations_EFT.f90:            !E and B-bar equations
equations_EFT.f90:    !  Neutrino equations:
equations_EFT.f90:        !  Massive neutrino equations of motion and contributions to anisotropic stress.
equations_EFT.f90:                            !Truncate moment expansion.
equations_EFT.f90:    !  Get the propagation equation for the shear
equations_EFT.f90:        ! EFTCAMB MOD START: modified tensor equation of motion:
equations_EFT.f90:    ! EFTCAMB MOD START: subroutine which sets initial conditions for pi.
equations_EFT.f90:    subroutine EFTpiInitialConditions(y,EV,tau)
equations_EFT.f90:        type(EvolutionVars) EV
equations_EFT.f90:        ! storage for EFT functions.
equations_EFT.f90:        ! perturbations quantities.
equations_EFT.f90:        real(dl) EFTpiA, EFTpiB, EFTpiC, EFTpiD, EFTpiE, EFTpiAdot, EFTpiEdot ! pi field equation.
equations_EFT.f90:        !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90:	    grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90:        !  Get sound speed and ionisation fraction.
equations_EFT.f90:	gpres = gpres + (grhog_t+grhor_t)/3._dl +Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90:            !RSA approximation of arXiv:1104.2933, dropping opactity terms in the velocity
equations_EFT.f90:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90:        ! Write initial conditions for pi and pidot
equations_EFT.f90:        ! 1- Test initial conditions
equations_EFT.f90:        ! 2- Initial conditions on the source
equations_EFT.f90:        if (EFTpiCfunction(a,k)+k*k*EFTpiDfunction(a,k)/=0) then
equations_EFT.f90:            y(EV%w_ix)= -EFT_H0*EFTpiE/(EFTpiCfunction(a,k)+k*k*EFTpiDfunction(a,k))
equations_EFT.f90:            y(EV%w_ix+1)= EFT_H0*(EFTpiE/(EFTpiCfunction(a,k)+k*k*EFTpiDfunction(a,k))**2*a*adotoa*(EFTpiCdotFunction(a,k)+k2*EFTpiDdotFunction(a,k))&
equations_EFT.f90:                & - EFTpiEdot/(EFTpiCfunction(a,k)+k2*EFTpiDfunction(a,k)))
equations_EFT.f90:    end subroutine EFTpiInitialConditions
equations_EFT.f90:    function EFTpiAfunction(a,k)
equations_EFT.f90:        real(dl) EFTpiAfunction
equations_EFT.f90:        ! storage for EFT functions.
equations_EFT.f90:        !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90:	    grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90:        gpres = +EFT_gpinu_tot +(grhog_t+grhor_t)/3._dl + Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90:        EFTpiAfunction = EFTpiA
equations_EFT.f90:    end function EFTpiAfunction
equations_EFT.f90:    function EFTpiBfunction(a,k)
equations_EFT.f90:        real(dl) EFTpiBfunction
equations_EFT.f90:        ! storage for EFT functions.
equations_EFT.f90:        ! perturbations quantities.
equations_EFT.f90:        !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90:	    grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90:	gpres = +EFT_gpinu_tot +(grhog_t+grhor_t)/3._dl + Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90:        EFTpiBfunction = EFTpiB
equations_EFT.f90:    end function EFTpiBfunction
equations_EFT.f90:    function EFTpiCfunction(a,k)
equations_EFT.f90:        real(dl) EFTpiCfunction
equations_EFT.f90:        ! storage for EFT functions.
equations_EFT.f90:        ! perturbations quantities.
equations_EFT.f90:        !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90:	    grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90:	gpres = +EFT_gpinu_tot +(grhog_t+grhor_t)/3._dl +Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90:        EFTpiCfunction = EFTpiC
equations_EFT.f90:    end function EFTpiCfunction
equations_EFT.f90:    function EFTpiDfunction(a,k)
equations_EFT.f90:        real(dl) EFTpiDfunction
equations_EFT.f90:        ! storage for EFT functions.
equations_EFT.f90:        ! perturbations quantities.
equations_EFT.f90:        !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90:	    grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90:        gpres = +EFT_gpinu_tot +(grhog_t+grhor_t)/3._dl +Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90:        EFTpiDfunction = EFTpiD
equations_EFT.f90:    end function EFTpiDfunction
equations_EFT.f90:    ! EFTCAMB: now we take the numerical derivative of the functions appearing in the pi field equation
equations_EFT.f90:    !          to set up initial conditions. This part of code is called just once also because the accuracy
equations_EFT.f90:    !          of initial conditions is not an issue.
equations_EFT.f90:    ! EFTCAMB: numerical derivative of the function A
equations_EFT.f90:    function EFTpiAdotFunction(a,k)
equations_EFT.f90:        real(dl) EFTpiAdotFunction, temp, err
equations_EFT.f90:        EFTpiAdotfunction = dfridr(EFTpiAfunction,a,k,0.1_dl*EFTturnonpi,err)
equations_EFT.f90:    end function EFTpiAdotFunction
equations_EFT.f90:    ! EFTCAMB: numerical derivative of the function B
equations_EFT.f90:    function EFTpiBdotFunction(a,k)
equations_EFT.f90:        real(dl) EFTpiBdotFunction, temp, err
equations_EFT.f90:        EFTpiBdotfunction = dfridr(EFTpiBfunction,a,k,0.1_dl*EFTturnonpi,err)
equations_EFT.f90:    end function EFTpiBdotFunction
equations_EFT.f90:    ! EFTCAMB: numerical derivative of the function C
equations_EFT.f90:    function EFTpiCdotFunction(a,k)
equations_EFT.f90:        real(dl) EFTpiCdotFunction, temp, err
equations_EFT.f90:        EFTpiCdotfunction = dfridr(EFTpiCfunction,a,k,0.1_dl*EFTturnonpi,err)
equations_EFT.f90:    end function EFTpiCdotFunction
equations_EFT.f90:    ! EFTCAMB: numerical derivative of the function D
equations_EFT.f90:    function EFTpiDdotFunction(a,k)
equations_EFT.f90:        real(dl) EFTpiDdotFunction, temp, err
equations_EFT.f90:        EFTpiDdotfunction = dfridr(EFTpiDfunction,a,k,0.1_dl*EFTturnonpi,err)
equations_EFT.f90:    end function EFTpiDdotFunction
equations_EFT.f90:    ! EFTCAMB: algorithm to compute the numerical derivative. Modified to accept two function arguments.
equations_EFT.f90:    function dfridr(func,x,k,h,err)
equations_EFT.f90:        real(dl), dimension(ntab,ntab) :: a
equations_EFT.f90:    end function dfridr
equations_EFT.f90~:    ! Equations module for dark energy with constant equation of state parameter w
equations_EFT.f90~:    ! allowing for perturbations based on a quintessence model
equations_EFT.f90~:    ! Changes to tight coupling approximation
equations_EFT.f90~:    ! August 2004, fixed reionization term in lensing potential
equations_EFT.f90~:    ! Apr 2005, added DoLateRadTruncation option
equations_EFT.f90~:    ! Nov 2006, tweak to high_precision transfer function accuracy at lowish k
equations_EFT.f90~:    ! June 2011, improved radiation approximations from arXiv: 1104.2933; Some 2nd order tight coupling terms
equations_EFT.f90~:    !            merged fderivs and derivs so flat and non-flat use same equations; more precomputed arrays
equations_EFT.f90~:    !            optimized neutrino sampling, and reorganised neutrino integration functions
equations_EFT.f90~:    use precision
equations_EFT.f90~:    function GetOmegak()
equations_EFT.f90~:    use precision
equations_EFT.f90~:    end function GetOmegak
equations_EFT.f90~:        use EFTFunctions
equations_EFT.f90~:    H0 = sqrt(Designed_EFT_Function(hubble, 1.0_dl, 0._dl)**2.0/(grhom/3.0))*100
equations_EFT.f90~:        !This is only called once per model, and is a good point to do any extra initialization.
equations_EFT.f90~:	use EFTInitialization
equations_EFT.f90~:        ! EFTCAMB MOD START: impose Horava conditions for Solar System free models
equations_EFT.f90~:    	call EFTCAMB_initialization(EFTsuccess)
equations_EFT.f90~:    !Background evolution
equations_EFT.f90~:    function dtauda(a)
equations_EFT.f90~:    use precision
equations_EFT.f90~:    use EFTfunctions
equations_EFT.f90~:		!grhoa2 = (grhog+grhornomass)*(1._dl/Designed_EFT_function(phibd,a_aux,0.0_dl))
equations_EFT.f90~:		!grhoa2 = grhok*a2 + (grhoc+grhob)*a_aux+ grhog + grhornomass + Designed_EFT_function(omegadebara4,a_aux,0.0_dl)
equations_EFT.f90~:    end function dtauda
equations_EFT.f90~:    !Gauge-dependent perturbation equations
equations_EFT.f90~:    use precision
equations_EFT.f90~:    use EFTfunctions
equations_EFT.f90~:    !Description of this file. Change if you make modifications.
equations_EFT.f90~:    logical :: DoLateRadTruncation = .true.
equations_EFT.f90~:    !if true, use smooth approx to radition perturbations after decoupling on
equations_EFT.f90~:    !small scales, saving evolution of irrelevant osciallatory multipole equations
equations_EFT.f90~:    !Note higher values increase size of Evolution vars, hence memory
equations_EFT.f90~:    !Supported scalar initial condition flags
equations_EFT.f90~:    type EvolutionVars
equations_EFT.f90~:        integer w_ix !Index of two quintessence equations
equations_EFT.f90~:        !       nvar  - number of scalar (tensor) equations for this k
equations_EFT.f90~:        integer polind  !index into scalar array of polarization hierarchy
equations_EFT.f90~:        !array indices for massive neutrino equations
equations_EFT.f90~:        !True when using non-relativistic approximation
equations_EFT.f90~:        !True when using tight-coupling approximation (required for stability at early times)
equations_EFT.f90~:        !Numer of scalar equations we are propagating
equations_EFT.f90~:        integer E_ix, B_ix !tensor polarization indices
equations_EFT.f90~:    end type EvolutionVars
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:        //'compiling with bounds checking may (or may not) help find the problem.',error_evolution)
equations_EFT.f90~:    function next_nu_nq(nq) result (next_nq)
equations_EFT.f90~:    end function next_nu_nq
equations_EFT.f90~:    type(EvolutionVars) EV, EVout
equations_EFT.f90~:    !Evolve equations from tau to tauend, performing switches in equations if necessary.
equations_EFT.f90~:    if (DoLateRadTruncation) then
equations_EFT.f90~:                call EFTpiInitialConditions(y,EV,tau)
equations_EFT.f90~:    type(EvolutionVars) EV, EVOut
equations_EFT.f90~:    function DeltaTimeMaxed(a1,a2, tol) result(t)
equations_EFT.f90~:    real(dl), optional :: tol
equations_EFT.f90~:    end function DeltaTimeMaxed
equations_EFT.f90~:    !Set the numer of equations in each hierarchy, and get total number of equations for this k
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    integer, intent(out), optional :: max_num_eqns
equations_EFT.f90~:            !Polarization multipoles
equations_EFT.f90~:            EV%polind = neq -1 !polind+2 is L=2, for polarizationthe first calculated
equations_EFT.f90~:            if (nu_masses(nu_i) > 5000 .and. CP%Transfer%high_precision) EV%lmaxnu_tau(nu_i) = EV%lmaxnu_tau(nu_i)*2 !megadamping
equations_EFT.f90~:    type(EvolutionVars) EV, EVOut
equations_EFT.f90~:                    !Add leading correction for the mass
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    integer, optional, intent(out) :: maxeq
equations_EFT.f90~:    type(EvolutionVars) EV, EVOut
equations_EFT.f90~:    !Set the numer of equations in each hierarchy, and get total number of equations for this k
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:        if (CP%Transfer%high_precision) then
equations_EFT.f90~:        if (HighAccuracyDefault .and. CP%AccuratePolarization) then
equations_EFT.f90~:        if (.not.CP%AccuratePolarization) EV%lmaxgpol=max(nint(4*lAccuracyBoost),3)
equations_EFT.f90~:            !Large scales need fewer equations
equations_EFT.f90~:            if (CP%AccuratePolarization) scal = 4  !But need more to get polarization right
equations_EFT.f90~:            if (CP%AccurateReionization) then
equations_EFT.f90~:        if (CP%Transfer%high_precision) then
equations_EFT.f90~:            if (EV%q > 0.04 .and. EV%q < 0.5) then !baryon oscillation scales
equations_EFT.f90~:    !energy-integrated hierarchy going up to third order in velocity dispersion
equations_EFT.f90~:    type(EvolutionVars) EV, EVout
equations_EFT.f90~:    !Get density and pressure as ratio to massles by interpolation from table
equations_EFT.f90~:    !Analytic solution for higher moments, proportional to a^{-3}
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    real(dl), optional :: grho,gpres,dgrho,dgq,dgpi, gdpi_diff,pidot_sum,clxnu_all
equations_EFT.f90~:        !Get density and pressure as ratio to massless by interpolation from table
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    !  Compute the perturbations of density and energy flux
equations_EFT.f90~:    real(dl), optional, intent(OUT) :: dpnu,pinu
equations_EFT.f90~:        !Get the rest from perturbatively relativistic expansion
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    !  and the shear perturbation.
equations_EFT.f90~:    function Nu_pi(EV, y, a, nu_i) result(pinu)
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    end function Nu_pi
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    !  Compute the third order variables (in velocity dispersion)
equations_EFT.f90~:        type(EvolutionVars) EV
equations_EFT.f90~:        real(dl), intent(out), optional :: wnu_arr(max_nu)
equations_EFT.f90~:        real(dl), intent(out), optional :: dgp
equations_EFT.f90~:        !Get density and pressure as ratio to massless by interpolation from table
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    real(dl), dimension(:),pointer :: ypol,ypolprime
equations_EFT.f90~:        ! EFTCAMB MOD START: definitions of EFTCAMB quantities
equations_EFT.f90~:        ! storage for EFT functions.
equations_EFT.f90~:        ! perturbations quantities.
equations_EFT.f90~:        real(dl) EFTpiA, EFTpiB, EFTpiC, EFTpiD, EFTpiE                 ! pi field equations
equations_EFT.f90~:        real(dl) EFTeomF, EFTeomN, EFTeomX, EFTeomY, EFTeomG, EFTeomU   ! equations of motion
equations_EFT.f90~:        real(dl)  EFT_Psi, EFT_Phi, EFT_function_mu, EFT_function_gamma, EFT_xi
equations_EFT.f90~:    !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90~:        ! EFTCAMB MOD START: Computation of DE background density.
equations_EFT.f90~:	    	grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90~:        ! EFTCAMB MOD START: computation of gpres.
equations_EFT.f90~:	    gpres=(grhog_t+grhor_t)/3._dl +Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90~:    !  8*pi*a*a*SUM[rho_i*clx_i] add radiation later
equations_EFT.f90~:        ! EFTCAMB MOD START: initialization of DE perturbations.
equations_EFT.f90~:    ! EFTCAMB MOD START: full mapping models expansion history:
equations_EFT.f90~:        ! EFTCAMB MOD START: Computation of background quantities:
equations_EFT.f90~:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90~:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90~:        ! 2) Compute and write once for all the values of the EFT functions.
equations_EFT.f90~:        ! 3) Computation of EFT background quantities.
equations_EFT.f90~:        ! EFTCAMB MOD START: computation of Einstein equations factors.
equations_EFT.f90~:        ! Debug code. Prints Einstein equations factors.
equations_EFT.f90~:        ! EFTCAMB MOD START: compute z,dz before loading radiation and photon
equations_EFT.f90~:            ! RSA approximation.
equations_EFT.f90~:        !equations of motion 1.
equations_EFT.f90~:        ! EFTCAMB MOD START: equation of motion 3.
equations_EFT.f90~:        ! EFTCAMB MOD START: computation of quantities used to construct the sources.
equations_EFT.f90~:        !E polarization source
equations_EFT.f90~:        ! EFTCAMB MOD START: computation of mu and gamma. These are not used but it's nice to have the possibility to plot them...
equations_EFT.f90~:            EFT_function_mu = -2._dl*k*(EFTsigmadot+adotoa*sigma)/(dgrho)
equations_EFT.f90~:            EFT_function_gamma = (etak - adotoa*sigma)/(EFTsigmadot + adotoa*sigma)
equations_EFT.f90~:                write (10,'(10e15.5)') a, tau, 1._dl/a-1._dl, k, EFT_function_mu, EFT_function_gamma, EFT_xi
equations_EFT.f90~:    type(EvolutionVars) :: EV
equations_EFT.f90~:    real(dl), dimension(:),pointer :: E,Bprime,Eprime
equations_EFT.f90~:        !  Use the full expression for pigdt
equations_EFT.f90~:        !  Use the tight-coupling approximation
equations_EFT.f90~:    type(EvolutionVars) :: EV
equations_EFT.f90~:    real(dl), dimension(:),pointer :: E,Eprime
equations_EFT.f90~:    !  Initial conditions.
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    if (CP%Scalar_initial_condition > initial_nummodes) &
equations_EFT.f90~:    stop 'Invalid initial condition for scalar modes'
equations_EFT.f90~:    !  Set adiabatic initial conditions
equations_EFT.f90~:    chi=1  !Get transfer function for chi
equations_EFT.f90~:    if (CP%Scalar_initial_condition/= initial_adiabatic) then
equations_EFT.f90~:        if (Rc==0) stop 'Isocurvature initial conditions assume non-zero dark matter'
equations_EFT.f90~:    if (CP%Scalar_initial_condition==initial_vector) then
equations_EFT.f90~:            InitVec = InitVec+ initv(i,:)*CP%InitialConditionVector(i)
equations_EFT.f90~:        InitVec = initv(CP%Scalar_initial_condition,:)
equations_EFT.f90~:        if (CP%Scalar_initial_condition==initial_adiabatic) InitVec = -InitVec
equations_EFT.f90~:    !  Initial conditions for tensors
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:        EV%denlkt(3,l)=k*denl(l)*tensfac**2/(l+1)*EV%Kft(l) !term for polarization
equations_EFT.f90~:        EV%denlkt(4,l)=k*4._dl/(l*(l+1))*EV%aux_buf !other for polarization
equations_EFT.f90~:    !  Initial conditions for vectors
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    !  Evaluate the time derivatives of the perturbations
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:        ! EFTCAMB MOD START: definition of variables
equations_EFT.f90~:        ! storage for EFT functions.
equations_EFT.f90~:        ! perturbations quantities.
equations_EFT.f90~:        real(dl) EFTpiA, EFTpiB, EFTpiC, EFTpiD, EFTpiE                 ! pi field equations
equations_EFT.f90~:        real(dl) EFTeomF, EFTeomN, EFTeomX, EFTeomY, EFTeomG, EFTeomU   ! equations of motion
equations_EFT.f90~:    !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90~:	    	grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90~:    !  Get sound speed and ionisation fraction.
equations_EFT.f90~:    !total perturbations: matter terms first, then add massive nu, de and radiation
equations_EFT.f90~:        ! EFTCAMB MOD START: protection against non flatness.
equations_EFT.f90~:        ! EFTCAMB MOD START: full mapping models expansion history:
equations_EFT.f90~:        ! EFTCAMB MOD START: Computation of background quantities:
equations_EFT.f90~:        ! 1) Computation of FRW background quantities.
equations_EFT.f90~:            gpres=gpres + (grhog_t+grhor_t)/3._dl +Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90~:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90~:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90~:        ! 2) Compute and write once for all the values of the EFT functions.
equations_EFT.f90~:        ! 3) Computation of EFT background quantities.
equations_EFT.f90~:        ! EFTCAMB MOD START: initialization of DE perturbations.
equations_EFT.f90~:        ! EFTCAMB MOD START: computation of Einstein equations factors.
equations_EFT.f90~:        ! Debug code. Prints EFT Einstein equations factors.
equations_EFT.f90~:        ! EFTCAMB MOD START: compute z,dz before loading radiation and photon
equations_EFT.f90~:        !RSA approximation of arXiv:1104.2933, dropping opactity terms in the velocity
equations_EFT.f90~:    !  8*pi*a*a*SUM[rho_i*clx_i] - radiation terms
equations_EFT.f90~:        ! EFTCAMB MOD START: equation of motion. Now we use the non-RSA expression for dz.
equations_EFT.f90~:        !  !eta*k equation
equations_EFT.f90~:        ! EFTCAMB MOD START: Pi field equation.
equations_EFT.f90~:        ! 1) Computation of pi field equation prefactors.
equations_EFT.f90~:        ! 2) Solution of the pi field equation of motion.
equations_EFT.f90~:            ! strategies to adopt if the theory does not propagate an additional dof
equations_EFT.f90~:    !  CDM equation of motion
equations_EFT.f90~:    !  Baryon equation of motion.
equations_EFT.f90~:    !  Photon equation of motion
equations_EFT.f90~:    ! old comment:Small k: potential problem with stability, using full equations earlier is NOT more accurate in general
equations_EFT.f90~:    ! Easy to see instability in k \sim 1e-3 by tracking evolution of vb
equations_EFT.f90~:    !  Use explicit equation for vb if appropriate
equations_EFT.f90~:        !  First-order approximation to baryon-photon splip
equations_EFT.f90~:        !  Use tight-coupling approximation for vb
equations_EFT.f90~:        !  zeroth order approximation to vbdot + the pig term
equations_EFT.f90~:        !  Photon equations of motion
equations_EFT.f90~:        !  Use explicit equations for photon moments if appropriate
equations_EFT.f90~:                !  Truncate the photon moment expansion
equations_EFT.f90~:            !  Polarization
equations_EFT.f90~:        !  Massless neutrino equations of motion.
equations_EFT.f90~:            !ufa approximation for k*tau>>1, more accurate when there are reflections from lmax
equations_EFT.f90~:                !  Truncate the neutrino expansion
equations_EFT.f90~:    !  Massive neutrino equations of motion.
equations_EFT.f90~:                    !  Truncate moment expansion.
equations_EFT.f90~:    !  Evaluate the time derivatives of the vector perturbations, flat case
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    real(dl), dimension(:),pointer :: neut,neutprime,E,B,Eprime,Bprime
equations_EFT.f90~:    ! Compute expansion rate from: grho=8*pi*rho*a**2
equations_EFT.f90~:    !for non-large k this expression for sigma is unstable at early times
equations_EFT.f90~:    !so propagate sigma equation separately (near total cancellation in rhoq)
equations_EFT.f90~:        !  Use explicit equations:
equations_EFT.f90~:        !  Equation for the photon heat flux stress
equations_EFT.f90~:        !  Equation for the photon anisotropic stress
equations_EFT.f90~:        !E equations
equations_EFT.f90~:        !B-bar equations
equations_EFT.f90~:        !Tight coupling expansion results
equations_EFT.f90~:        !  Equation for the photon heat flux
equations_EFT.f90~:        ! Get drag from vbdot expression
equations_EFT.f90~:    !  Neutrino equations:
equations_EFT.f90~:    !  Get the propagation equation for the shear
equations_EFT.f90~:    !  Evaluate the time derivatives of the tensor perturbations.
equations_EFT.f90~:    type(EvolutionVars) EV
equations_EFT.f90~:    real(dl), dimension(:),pointer :: neut,neutprime,E,B,Eprime,Bprime
equations_EFT.f90~:    ! Compute expansion rate from: grho=8*pi*rho*a**2
equations_EFT.f90~:	    	grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90~:    ! EFTCAMB MOD START: full mapping models expansion history:
equations_EFT.f90~:        !  Don't use tight coupling approx - use explicit equations:
equations_EFT.f90~:        !  Equation for the photon anisotropic stress
equations_EFT.f90~:            !E and B-bar equations
equations_EFT.f90~:    !  Neutrino equations:
equations_EFT.f90~:        !  Massive neutrino equations of motion and contributions to anisotropic stress.
equations_EFT.f90~:                            !Truncate moment expansion.
equations_EFT.f90~:    !  Get the propagation equation for the shear
equations_EFT.f90~:        ! EFTCAMB MOD START: modified tensor equation of motion:
equations_EFT.f90~:    ! EFTCAMB MOD START: subroutine which sets initial conditions for pi.
equations_EFT.f90~:    subroutine EFTpiInitialConditions(y,EV,tau)
equations_EFT.f90~:        type(EvolutionVars) EV
equations_EFT.f90~:        ! storage for EFT functions.
equations_EFT.f90~:        ! perturbations quantities.
equations_EFT.f90~:        real(dl) EFTpiA, EFTpiB, EFTpiC, EFTpiD, EFTpiE, EFTpiAdot, EFTpiEdot ! pi field equation.
equations_EFT.f90~:        !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90~:	    grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90~:        !  Get sound speed and ionisation fraction.
equations_EFT.f90~:	gpres = gpres + (grhog_t+grhor_t)/3._dl +Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90~:            !RSA approximation of arXiv:1104.2933, dropping opactity terms in the velocity
equations_EFT.f90~:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90~:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90~:        ! Write initial conditions for pi and pidot
equations_EFT.f90~:        ! 1- Test initial conditions
equations_EFT.f90~:        ! 2- Initial conditions on the source
equations_EFT.f90~:        if (EFTpiCfunction(a,k)+k*k*EFTpiDfunction(a,k)/=0) then
equations_EFT.f90~:            y(EV%w_ix)= -EFT_H0*EFTpiE/(EFTpiCfunction(a,k)+k*k*EFTpiDfunction(a,k))
equations_EFT.f90~:            y(EV%w_ix+1)= EFT_H0*(EFTpiE/(EFTpiCfunction(a,k)+k*k*EFTpiDfunction(a,k))**2*a*adotoa*(EFTpiCdotFunction(a,k)+k2*EFTpiDdotFunction(a,k))&
equations_EFT.f90~:                & - EFTpiEdot/(EFTpiCfunction(a,k)+k2*EFTpiDfunction(a,k)))
equations_EFT.f90~:    end subroutine EFTpiInitialConditions
equations_EFT.f90~:    function EFTpiAfunction(a,k)
equations_EFT.f90~:        real(dl) EFTpiAfunction
equations_EFT.f90~:        ! storage for EFT functions.
equations_EFT.f90~:        !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90~:	    grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90~:        gpres = +EFT_gpinu_tot +(grhog_t+grhor_t)/3._dl + Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90~:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90~:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90~:        EFTpiAfunction = EFTpiA
equations_EFT.f90~:    end function EFTpiAfunction
equations_EFT.f90~:    function EFTpiBfunction(a,k)
equations_EFT.f90~:        real(dl) EFTpiBfunction
equations_EFT.f90~:        ! storage for EFT functions.
equations_EFT.f90~:        ! perturbations quantities.
equations_EFT.f90~:        !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90~:	    grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90~:	gpres = +EFT_gpinu_tot +(grhog_t+grhor_t)/3._dl + Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90~:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90~:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90~:        EFTpiBfunction = EFTpiB
equations_EFT.f90~:    end function EFTpiBfunction
equations_EFT.f90~:    function EFTpiCfunction(a,k)
equations_EFT.f90~:        real(dl) EFTpiCfunction
equations_EFT.f90~:        ! storage for EFT functions.
equations_EFT.f90~:        ! perturbations quantities.
equations_EFT.f90~:        !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90~:	    grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90~:	gpres = +EFT_gpinu_tot +(grhog_t+grhor_t)/3._dl +Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90~:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90~:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90~:        EFTpiCfunction = EFTpiC
equations_EFT.f90~:    end function EFTpiCfunction
equations_EFT.f90~:    function EFTpiDfunction(a,k)
equations_EFT.f90~:        real(dl) EFTpiDfunction
equations_EFT.f90~:        ! storage for EFT functions.
equations_EFT.f90~:        ! perturbations quantities.
equations_EFT.f90~:        !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_EFT.f90~:	    grhov_t = Designed_EFT_function(omegadebara2,a,0.0_dl)
equations_EFT.f90~:        gpres = +EFT_gpinu_tot +(grhog_t+grhor_t)/3._dl +Designed_EFT_function(omegadepresbara2,a,0._dl)
equations_EFT.f90~:	EFTbd_weff = Designed_EFT_Function(omegadeweff,a,0._dl)
equations_EFT.f90~:	EFTbd_weffprime	= Designed_EFT_Function(omegadeweffprime,a,0._dl)
equations_EFT.f90~:        EFTpiDfunction = EFTpiD
equations_EFT.f90~:    end function EFTpiDfunction
equations_EFT.f90~:    ! EFTCAMB: now we take the numerical derivative of the functions appearing in the pi field equation
equations_EFT.f90~:    !          to set up initial conditions. This part of code is called just once also because the accuracy
equations_EFT.f90~:    !          of initial conditions is not an issue.
equations_EFT.f90~:    ! EFTCAMB: numerical derivative of the function A
equations_EFT.f90~:    function EFTpiAdotFunction(a,k)
equations_EFT.f90~:        real(dl) EFTpiAdotFunction, temp, err
equations_EFT.f90~:        EFTpiAdotfunction = dfridr(EFTpiAfunction,a,k,0.1_dl*EFTturnonpi,err)
equations_EFT.f90~:    end function EFTpiAdotFunction
equations_EFT.f90~:    ! EFTCAMB: numerical derivative of the function B
equations_EFT.f90~:    function EFTpiBdotFunction(a,k)
equations_EFT.f90~:        real(dl) EFTpiBdotFunction, temp, err
equations_EFT.f90~:        EFTpiBdotfunction = dfridr(EFTpiBfunction,a,k,0.1_dl*EFTturnonpi,err)
equations_EFT.f90~:    end function EFTpiBdotFunction
equations_EFT.f90~:    ! EFTCAMB: numerical derivative of the function C
equations_EFT.f90~:    function EFTpiCdotFunction(a,k)
equations_EFT.f90~:        real(dl) EFTpiCdotFunction, temp, err
equations_EFT.f90~:        EFTpiCdotfunction = dfridr(EFTpiCfunction,a,k,0.1_dl*EFTturnonpi,err)
equations_EFT.f90~:    end function EFTpiCdotFunction
equations_EFT.f90~:    ! EFTCAMB: numerical derivative of the function D
equations_EFT.f90~:    function EFTpiDdotFunction(a,k)
equations_EFT.f90~:        real(dl) EFTpiDdotFunction, temp, err
equations_EFT.f90~:        EFTpiDdotfunction = dfridr(EFTpiDfunction,a,k,0.1_dl*EFTturnonpi,err)
equations_EFT.f90~:    end function EFTpiDdotFunction
equations_EFT.f90~:    ! EFTCAMB: algorithm to compute the numerical derivative. Modified to accept two function arguments.
equations_EFT.f90~:    function dfridr(func,x,k,h,err)
equations_EFT.f90~:        real(dl), dimension(ntab,ntab) :: a
equations_EFT.f90~:    end function dfridr
equations.f90:    ! Equations module for dark energy with constant equation of state parameter w
equations.f90:    ! allowing for perturbations based on a quintessence model
equations.f90:    ! Changes to tight coupling approximation
equations.f90:    ! August 2004, fixed reionization term in lensing potential
equations.f90:    ! Apr 2005, added DoLateRadTruncation option
equations.f90:    ! Nov 2006, tweak to high_precision transfer function accuracy at lowish k
equations.f90:    ! June 2011, improved radiation approximations from arXiv: 1104.2933; Some 2nd order tight coupling terms
equations.f90:    !            merged fderivs and derivs so flat and non-flat use same equations; more precomputed arrays
equations.f90:    !            optimized neutrino sampling, and reorganised neutrino integration functions
equations.f90:    use precision
equations.f90:    function GetOmegak()
equations.f90:    use precision
equations.f90:    end function GetOmegak
equations.f90:    !This is only called once per model, and is a good point to do any extra initialization.
equations.f90:    !Background evolution
equations.f90:    function dtauda(a)
equations.f90:    use precision
equations.f90:    end function dtauda
equations.f90:    !Gauge-dependent perturbation equations
equations.f90:    use precision
equations.f90:    !Description of this file. Change if you make modifications.
equations.f90:    logical :: DoLateRadTruncation = .true.
equations.f90:    !if true, use smooth approx to radition perturbations after decoupling on
equations.f90:    !small scales, saving evolution of irrelevant osciallatory multipole equations
equations.f90:    !Note higher values increase size of Evolution vars, hence memory
equations.f90:    !Supported scalar initial condition flags
equations.f90:    type EvolutionVars
equations.f90:        integer w_ix !Index of two quintessence equations
equations.f90:        !       nvar  - number of scalar (tensor) equations for this k
equations.f90:        integer polind  !index into scalar array of polarization hierarchy
equations.f90:        !array indices for massive neutrino equations
equations.f90:        !True when using non-relativistic approximation
equations.f90:        !True when using tight-coupling approximation (required for stability at early times)
equations.f90:        !Numer of scalar equations we are propagating
equations.f90:        integer E_ix, B_ix !tensor polarization indices
equations.f90:    end type EvolutionVars
equations.f90:    type(EvolutionVars) EV
equations.f90:            //'compiling with bounds checking may (or may not) help find the problem.',error_evolution)
equations.f90:    function next_nu_nq(nq) result (next_nq)
equations.f90:    end function next_nu_nq
equations.f90:    type(EvolutionVars) EV, EVout
equations.f90:    !Evolve equations from tau to tauend, performing switches in equations if necessary.
equations.f90:    if (DoLateRadTruncation) then
equations.f90:    type(EvolutionVars) EV, EVOut
equations.f90:    function DeltaTimeMaxed(a1,a2, tol) result(t)
equations.f90:    real(dl), optional :: tol
equations.f90:    end function DeltaTimeMaxed
equations.f90:    !Set the numer of equations in each hierarchy, and get total number of equations for this k
equations.f90:    type(EvolutionVars) EV
equations.f90:    integer, intent(out), optional :: max_num_eqns
equations.f90:            !Polarization multipoles
equations.f90:            EV%polind = neq -1 !polind+2 is L=2, for polarizationthe first calculated
equations.f90:            if (nu_masses(nu_i) > 5000 .and. CP%Transfer%high_precision) EV%lmaxnu_tau(nu_i) = EV%lmaxnu_tau(nu_i)*2 !megadamping
equations.f90:    type(EvolutionVars) EV, EVOut
equations.f90:                    !Add leading correction for the mass
equations.f90:    type(EvolutionVars) EV
equations.f90:    integer, optional, intent(out) :: maxeq
equations.f90:    type(EvolutionVars) EV, EVOut
equations.f90:    !Set the numer of equations in each hierarchy, and get total number of equations for this k
equations.f90:    type(EvolutionVars) EV
equations.f90:        if (CP%Transfer%high_precision) then
equations.f90:        if (HighAccuracyDefault .and. CP%AccuratePolarization) then
equations.f90:        if (.not.CP%AccuratePolarization) EV%lmaxgpol=max(nint(4*lAccuracyBoost),3)
equations.f90:            !Large scales need fewer equations
equations.f90:            if (CP%AccuratePolarization) scal = 4  !But need more to get polarization right
equations.f90:            if (CP%AccurateReionization) then
equations.f90:        if (CP%Transfer%high_precision) then
equations.f90:            if (EV%q > 0.04 .and. EV%q < 0.5) then !baryon oscillation scales
equations.f90:    !energy-integrated hierarchy going up to third order in velocity dispersion
equations.f90:    type(EvolutionVars) EV, EVout
equations.f90:    !Get density and pressure as ratio to massles by interpolation from table
equations.f90:    !Analytic solution for higher moments, proportional to a^{-3}
equations.f90:    type(EvolutionVars) EV
equations.f90:    real(dl), optional :: grho,gpres,dgrho,dgq,dgpi, gdpi_diff,pidot_sum,clxnu_all
equations.f90:        !Get density and pressure as ratio to massless by interpolation from table
equations.f90:    type(EvolutionVars) EV
equations.f90:    !  Compute the perturbations of density and energy flux
equations.f90:    real(dl), optional, intent(OUT) :: dpnu,pinu
equations.f90:        !Get the rest from perturbatively relativistic expansion
equations.f90:    type(EvolutionVars) EV
equations.f90:    !  and the shear perturbation.
equations.f90:    function Nu_pi(EV, y, a, nu_i) result(pinu)
equations.f90:    type(EvolutionVars) EV
equations.f90:    end function Nu_pi
equations.f90:    type(EvolutionVars) EV
equations.f90:    !  Compute the third order variables (in velocity dispersion)
equations.f90:    type(EvolutionVars) EV
equations.f90:    real(dl), intent(out), optional :: wnu_arr(max_nu)
equations.f90:        !Get density and pressure as ratio to massless by interpolation from table
equations.f90:    type(EvolutionVars) EV
equations.f90:    real(dl), dimension(:),pointer :: ypol,ypolprime
equations.f90:    !  Compute expansion rate from: grho 8*pi*rho*a**2
equations.f90:    !  8*pi*a*a*SUM[rho_i*clx_i] add radiation later
equations.f90:        !E polarization source
equations.f90:    type(EvolutionVars) :: EV
equations.f90:    real(dl), dimension(:),pointer :: E,Bprime,Eprime
equations.f90:        !  Use the full expression for pigdt
equations.f90:        !  Use the tight-coupling approximation
equations.f90:    type(EvolutionVars) :: EV
equations.f90:    real(dl), dimension(:),pointer :: E,Eprime
equations.f90:    !  Initial conditions.
equations.f90:    type(EvolutionVars) EV
equations.f90:    if (CP%Scalar_initial_condition > initial_nummodes) &
equations.f90:        stop 'Invalid initial condition for scalar modes'
equations.f90:    !  Set adiabatic initial conditions
equations.f90:    chi=1  !Get transfer function for chi
equations.f90:    if (CP%Scalar_initial_condition/= initial_adiabatic) then
equations.f90:        if (Rc==0) stop 'Isocurvature initial conditions assume non-zero dark matter'
equations.f90:    if (CP%Scalar_initial_condition==initial_vector) then
equations.f90:            InitVec = InitVec+ initv(i,:)*CP%InitialConditionVector(i)
equations.f90:        InitVec = initv(CP%Scalar_initial_condition,:)
equations.f90:        if (CP%Scalar_initial_condition==initial_adiabatic) InitVec = -InitVec
equations.f90:    !  Initial conditions for tensors
equations.f90:    type(EvolutionVars) EV
equations.f90:        EV%denlkt(3,l)=k*denl(l)*tensfac**2/(l+1)*EV%Kft(l) !term for polarization
equations.f90:        EV%denlkt(4,l)=k*4._dl/(l*(l+1))*EV%aux_buf !other for polarization
equations.f90:    !  Initial conditions for vectors
equations.f90:    type(EvolutionVars) EV
equations.f90:    type(EvolutionVars) EV
equations.f90:    !  Evaluate the time derivatives of the perturbations
equations.f90:    type(EvolutionVars) EV
equations.f90:    !  Compute expansion rate from: grho 8*pi*rho*a**2
equations.f90:    !  Get sound speed and ionisation fraction.
equations.f90:    !total perturbations: matter terms first, then add massive nu, de and radiation
equations.f90:        !RSA approximation of arXiv:1104.2933, dropping opactity terms in the velocity
equations.f90:    !  8*pi*a*a*SUM[rho_i*clx_i] - radiation terms
equations.f90:        !eta*k equation
equations.f90:    !  CDM equation of motion
equations.f90:    !  Baryon equation of motion.
equations.f90:    !  Photon equation of motion
equations.f90:    ! old comment:Small k: potential problem with stability, using full equations earlier is NOT more accurate in general
equations.f90:    ! Easy to see instability in k \sim 1e-3 by tracking evolution of vb
equations.f90:    !  Use explicit equation for vb if appropriate
equations.f90:        !  First-order approximation to baryon-photon splip
equations.f90:        !  Use tight-coupling approximation for vb
equations.f90:        !  zeroth order approximation to vbdot + the pig term
equations.f90:        !  Photon equations of motion
equations.f90:        !  Use explicit equations for photon moments if appropriate
equations.f90:                !  Truncate the photon moment expansion
equations.f90:            !  Polarization
equations.f90:        !  Massless neutrino equations of motion.
equations.f90:            !ufa approximation for k*tau>>1, more accurate when there are reflections from lmax
equations.f90:                !  Truncate the neutrino expansion
equations.f90:    !  Massive neutrino equations of motion.
equations.f90:                    !  Truncate moment expansion.
equations.f90:    !  Evaluate the time derivatives of the vector perturbations, flat case
equations.f90:    type(EvolutionVars) EV
equations.f90:    real(dl), dimension(:),pointer :: neut,neutprime,E,B,Eprime,Bprime
equations.f90:    ! Compute expansion rate from: grho=8*pi*rho*a**2
equations.f90:    !for non-large k this expression for sigma is unstable at early times
equations.f90:    !so propagate sigma equation separately (near total cancellation in rhoq)
equations.f90:        !  Use explicit equations:
equations.f90:        !  Equation for the photon heat flux stress
equations.f90:        !  Equation for the photon anisotropic stress
equations.f90:        !E equations
equations.f90:        !B-bar equations
equations.f90:        !Tight coupling expansion results
equations.f90:        !  Equation for the photon heat flux
equations.f90:        ! Get drag from vbdot expression
equations.f90:    !  Neutrino equations:
equations.f90:    !  Get the propagation equation for the shear
equations.f90:    !  Evaluate the time derivatives of the tensor perturbations.
equations.f90:    type(EvolutionVars) EV
equations.f90:    real(dl), dimension(:),pointer :: neut,neutprime,E,B,Eprime,Bprime
equations.f90:    ! Compute expansion rate from: grho=8*pi*rho*a**2
equations.f90:        !  Don't use tight coupling approx - use explicit equations:
equations.f90:        !  Equation for the photon anisotropic stress
equations.f90:            !E and B-bar equations
equations.f90:    !  Neutrino equations:
equations.f90:        !  Massive neutrino equations of motion and contributions to anisotropic stress.
equations.f90:                            !Truncate moment expansion.
equations.f90:    !  Get the propagation equation for the shear
equations_ppf.f90:    ! Equations module for dark energy with constant equation of state parameter w
equations_ppf.f90:    ! allowing for perturbations based on a quintessence model
equations_ppf.f90:    ! Changes to tight coupling approximation
equations_ppf.f90:    ! August 2004, fixed reionization term in lensing potential
equations_ppf.f90:    ! Apr 2005, added DoLateRadTruncation option
equations_ppf.f90:    ! Nov 2006, tweak to high_precision transfer function accuracy at lowish k
equations_ppf.f90:    ! June 2011, improved radiation approximations from arXiv: 1104.2933; Some 2nd order tight coupling terms
equations_ppf.f90:    !            merged fderivs and derivs so flat and non-flat use same equations; more precomputed arrays
equations_ppf.f90:    !            optimized neutrino sampling, and reorganised neutrino integration functions
equations_ppf.f90:    ! Feb 2012, updated PPF version but now only simple case for w, w_a (no anisotropic stresses etc)
equations_ppf.f90:    ! Oct 2013: fix PPF, consistent with updated equations_cross
equations_ppf.f90:    use precision
equations_ppf.f90:    function w_de(a)
equations_ppf.f90:    end function w_de  ! equation of state of the PPF DE
equations_ppf.f90:    function drdlna_de(al)
equations_ppf.f90:    end function drdlna_de
equations_ppf.f90:    function grho_de(a)  !8 pi G a^4 rho_de
equations_ppf.f90:            else              !if amin is small enough, this extrapolation will be unnecessary.
equations_ppf.f90:    end function grho_de
equations_ppf.f90:    function GetOmegak()
equations_ppf.f90:    use precision
equations_ppf.f90:    end function GetOmegak
equations_ppf.f90:    !This is only called once per model, and is a good point to do any extra initialization.
equations_ppf.f90:    !Background evolution
equations_ppf.f90:    function dtauda(a)
equations_ppf.f90:    use precision
equations_ppf.f90:    end function dtauda
equations_ppf.f90:    !Gauge-dependent perturbation equations
equations_ppf.f90:    use precision
equations_ppf.f90:    !Description of this file. Change if you make modifications.
equations_ppf.f90:    character(LEN=*), parameter :: Eqns_name = 'equations_ppf-Jan15'
equations_ppf.f90:    logical :: DoLateRadTruncation = .true.
equations_ppf.f90:    !if true, use smooth approx to radition perturbations after decoupling on
equations_ppf.f90:    !small scales, saving evolution of irrelevant osciallatory multipole equations
equations_ppf.f90:    !Note higher values increase size of Evolution vars, hence memory
equations_ppf.f90:    !Supported scalar initial condition flags
equations_ppf.f90:    type EvolutionVars
equations_ppf.f90:        integer w_ix !Index of two quintessence equations
equations_ppf.f90:        !       nvar  - number of scalar (tensor) equations for this k
equations_ppf.f90:        integer polind  !index into scalar array of polarization hierarchy
equations_ppf.f90:        !array indices for massive neutrino equations
equations_ppf.f90:        !True when using non-relativistic approximation
equations_ppf.f90:        !True when using tight-coupling approximation (required for stability at early times)
equations_ppf.f90:        !Numer of scalar equations we are propagating
equations_ppf.f90:        integer E_ix, B_ix !tensor polarization indices
equations_ppf.f90:    end type EvolutionVars
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:            //'compiling with bounds checking may (or may not) help find the problem.',error_evolution)
equations_ppf.f90:    function next_nu_nq(nq) result (next_nq)
equations_ppf.f90:    end function next_nu_nq
equations_ppf.f90:    type(EvolutionVars) EV, EVout
equations_ppf.f90:    !Evolve equations from tau to tauend, performing switches in equations if necessary.
equations_ppf.f90:    if (DoLateRadTruncation) then
equations_ppf.f90:    type(EvolutionVars) EV, EVOut
equations_ppf.f90:    function DeltaTimeMaxed(a1,a2, tol) result(t)
equations_ppf.f90:    real(dl), optional :: tol
equations_ppf.f90:    end function DeltaTimeMaxed
equations_ppf.f90:    !Set the numer of equations in each hierarchy, and get total number of equations for this k
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    integer, intent(out), optional :: max_num_eqns
equations_ppf.f90:            !Polarization multipoles
equations_ppf.f90:            EV%polind = neq -1 !polind+2 is L=2, for polarizationthe first calculated
equations_ppf.f90:            if (nu_masses(nu_i) > 5000 .and. CP%Transfer%high_precision) EV%lmaxnu_tau(nu_i) = EV%lmaxnu_tau(nu_i)*2 !megadamping
equations_ppf.f90:    type(EvolutionVars) EV, EVOut
equations_ppf.f90:                    !Add leading correction for the mass
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    integer, optional, intent(out) :: maxeq
equations_ppf.f90:    type(EvolutionVars) EV, EVOut
equations_ppf.f90:    !Set the numer of equations in each hierarchy, and get total number of equations for this k
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:        if (CP%Transfer%high_precision) then
equations_ppf.f90:        if (HighAccuracyDefault .and. CP%AccuratePolarization) then
equations_ppf.f90:        if (.not.CP%AccuratePolarization) EV%lmaxgpol=max(nint(4*lAccuracyBoost),3)
equations_ppf.f90:            !Large scales need fewer equations
equations_ppf.f90:            if (CP%AccuratePolarization) scal = 4  !But need more to get polarization right
equations_ppf.f90:            if (CP%AccurateReionization) then
equations_ppf.f90:        if (CP%Transfer%high_precision) then
equations_ppf.f90:            if (EV%q > 0.04 .and. EV%q < 0.5) then !baryon oscillation scales
equations_ppf.f90:    !energy-integrated hierarchy going up to third order in velocity dispersion
equations_ppf.f90:    type(EvolutionVars) EV, EVout
equations_ppf.f90:    !Get density and pressure as ratio to massles by interpolation from table
equations_ppf.f90:    !Analytic solution for higher moments, proportional to a^{-3}
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    real(dl), optional :: grho,gpres,dgrho,dgq,dgpi, gdpi_diff,pidot_sum,clxnu_all
equations_ppf.f90:        !Get density and pressure as ratio to massless by interpolation from table
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    !  Compute the perturbations of density and energy flux
equations_ppf.f90:    real(dl), optional, intent(OUT) :: dpnu,pinu
equations_ppf.f90:        !Get the rest from perturbatively relativistic expansion
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    !  and the shear perturbation.
equations_ppf.f90:    function Nu_pi(EV, y, a, nu_i) result(pinu)
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    end function Nu_pi
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    !  Compute the third order variables (in velocity dispersion)
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    real(dl), intent(out), optional :: wnu_arr(max_nu)
equations_ppf.f90:        !Get density and pressure as ratio to massless by interpolation from table
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    real(dl), dimension(:),pointer :: ypol,ypolprime
equations_ppf.f90:    !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_ppf.f90:    !  8*pi*a*a*SUM[rho_i*clx_i] add radiation later
equations_ppf.f90:        !E polarization source
equations_ppf.f90:    type(EvolutionVars) :: EV
equations_ppf.f90:    real(dl), dimension(:),pointer :: E,Bprime,Eprime
equations_ppf.f90:        !  Use the full expression for pigdt
equations_ppf.f90:        !  Use the tight-coupling approximation
equations_ppf.f90:    type(EvolutionVars) :: EV
equations_ppf.f90:    real(dl), dimension(:),pointer :: E,Eprime
equations_ppf.f90:    !  Initial conditions.
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    if (CP%Scalar_initial_condition > initial_nummodes) &
equations_ppf.f90:        stop 'Invalid initial condition for scalar modes'
equations_ppf.f90:    !  Set adiabatic initial conditions
equations_ppf.f90:    chi=1  !Get transfer function for chi
equations_ppf.f90:    if (CP%Scalar_initial_condition/= initial_adiabatic) then
equations_ppf.f90:        if (Rc==0) stop 'Isocurvature initial conditions assume non-zero dark matter'
equations_ppf.f90:    if (CP%Scalar_initial_condition==initial_vector) then
equations_ppf.f90:            InitVec = InitVec+ initv(i,:)*CP%InitialConditionVector(i)
equations_ppf.f90:        InitVec = initv(CP%Scalar_initial_condition,:)
equations_ppf.f90:        if (CP%Scalar_initial_condition==initial_adiabatic) InitVec = -InitVec
equations_ppf.f90:    !  Initial conditions for tensors
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:        EV%denlkt(3,l)=k*denl(l)*tensfac**2/(l+1)*EV%Kft(l) !term for polarization
equations_ppf.f90:        EV%denlkt(4,l)=k*4._dl/(l*(l+1))*EV%aux_buf !other for polarization
equations_ppf.f90:    !  Initial conditions for vectors
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    !  Evaluate the time derivatives of the perturbations
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    !  Compute expansion rate from: grho 8*pi*rho*a**2
equations_ppf.f90:    !  Get sound speed and ionisation fraction.
equations_ppf.f90:    !total perturbations: matter terms first, then add massive nu, de and radiation
equations_ppf.f90:        !RSA approximation of arXiv:1104.2933, dropping opactity terms in the velocity
equations_ppf.f90:    !  8*pi*a*a*SUM[rho_i*clx_i] - radiation terms
equations_ppf.f90:        !eta*k equation
equations_ppf.f90:    !  CDM equation of motion
equations_ppf.f90:    !  Baryon equation of motion.
equations_ppf.f90:    !  Photon equation of motion
equations_ppf.f90:    ! old comment:Small k: potential problem with stability, using full equations earlier is NOT more accurate in general
equations_ppf.f90:    ! Easy to see instability in k \sim 1e-3 by tracking evolution of vb
equations_ppf.f90:    !  Use explicit equation for vb if appropriate
equations_ppf.f90:        !  First-order approximation to baryon-photon splip
equations_ppf.f90:        !  Use tight-coupling approximation for vb
equations_ppf.f90:        !  zeroth order approximation to vbdot + the pig term
equations_ppf.f90:        !  Photon equations of motion
equations_ppf.f90:        !  Use explicit equations for photon moments if appropriate
equations_ppf.f90:                !  Truncate the photon moment expansion
equations_ppf.f90:            !  Polarization
equations_ppf.f90:        !  Massless neutrino equations of motion.
equations_ppf.f90:            !ufa approximation for k*tau>>1, more accurate when there are reflections from lmax
equations_ppf.f90:                !  Truncate the neutrino expansion
equations_ppf.f90:    !  Massive neutrino equations of motion.
equations_ppf.f90:                    !  Truncate moment expansion.
equations_ppf.f90:    !  Evaluate the time derivatives of the vector perturbations, flat case
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    real(dl), dimension(:),pointer :: neut,neutprime,E,B,Eprime,Bprime
equations_ppf.f90:    ! Compute expansion rate from: grho=8*pi*rho*a**2
equations_ppf.f90:    !for non-large k this expression for sigma is unstable at early times
equations_ppf.f90:    !so propagate sigma equation separately (near total cancellation in rhoq)
equations_ppf.f90:        !  Use explicit equations:
equations_ppf.f90:        !  Equation for the photon heat flux stress
equations_ppf.f90:        !  Equation for the photon anisotropic stress
equations_ppf.f90:        !E equations
equations_ppf.f90:        !B-bar equations
equations_ppf.f90:        !Tight coupling expansion results
equations_ppf.f90:        !  Equation for the photon heat flux
equations_ppf.f90:        ! Get drag from vbdot expression
equations_ppf.f90:    !  Neutrino equations:
equations_ppf.f90:    !  Get the propagation equation for the shear
equations_ppf.f90:    !  Evaluate the time derivatives of the tensor perturbations.
equations_ppf.f90:    type(EvolutionVars) EV
equations_ppf.f90:    real(dl), dimension(:),pointer :: neut,neutprime,E,B,Eprime,Bprime
equations_ppf.f90:    ! Compute expansion rate from: grho=8*pi*rho*a**2
equations_ppf.f90:        !  Don't use tight coupling approx - use explicit equations:
equations_ppf.f90:        !  Equation for the photon anisotropic stress
equations_ppf.f90:            !E and B-bar equations
equations_ppf.f90:    !  Neutrino equations:
equations_ppf.f90:        !  Massive neutrino equations of motion and contributions to anisotropic stress.
equations_ppf.f90:                            !Truncate moment expansion.
equations_ppf.f90:    !  Get the propagation equation for the shear
halofit_ppf.f90:    ! The `halofit' code models the nonlinear evolution of cold matter
halofit_ppf.f90:    !!BR09 Oct 09: generalized expressions for om(z) and ol(z) to include w
halofit_ppf.f90:    !!JD 08/13: generalized expressions for om(z) and ol(z) to include
halofit_ppf.f90:    !           modifications
halofit_ppf.f90:    ! AL Sept 14: added halofit_version parameter to change approximation used;
halofit_ppf.f90:    !   separate halofit.f90 is no longer needed as equations.f90 defined fixed wa_ppf
halofit_ppf.f90:    integer :: halofit_version = halofit_default
halofit_ppf.f90:    public halofit_version,halofit_default, halofit_original, halofit_bird, halofit_peacock, halofit_takahashi
halofit_ppf.f90:    halofit_version = Ini_Read_Int_File(Ini, 'halofit_version', halofit_default)
halofit_ppf.f90:    !This implementation uses Halofit
halofit_ppf.f90:                ! where ph is represents the self-correlation halo term.
halofit_ppf.f90:    if (halofit_version ==halofit_original .or. halofit_version ==halofit_bird &
halofit_ppf.f90:        .or. halofit_version == halofit_peacock) then
halofit_ppf.f90:    !factor of two. Add an extra correction from the simulations in Bird, Viel,
halofit_ppf.f90:    if (halofit_version ==halofit_bird) then
halofit_ppf.f90:    elseif (halofit_version == halofit_takahashi) then
halofit_ppf.f90:        !than latest N-body simulations at small scales.
halofit_ppf.f90:        !alpha & beta from the simulations in Takahashi+ 2012.
halofit_ppf.f90:        stop 'Unknown halofit_version'
halofit_ppf.f90:    if(abs(1-om_m).gt.0.01) then ! omega evolution
halofit_ppf.f90:    if (halofit_version == halofit_peacock) then
halofit_ppf.f90:    function omega_m(aa,om_m0,om_v0,wval,waval)
halofit_ppf.f90:    end function omega_m
halofit_ppf.f90:    ! evolution of omega lambda with expansion factor
halofit_ppf.f90:    function omega_v(aa,om_m0,om_v0,wval,waval)
halofit_ppf.f90:    end function omega_v
hyrec.F90:    ! Recombination module for CAMB, using HyRec
hyrec.F90:    module Recombination
hyrec.F90:    type RecombinationParams
hyrec.F90:    end type RecombinationParams
hyrec.F90:    character(LEN=*), parameter :: Recombination_Name = 'HyRec'
hyrec.F90:    public RecombinationParams, Recombination_xe, Recombination_tm, Recombination_init,   &
hyrec.F90:    Recombination_ReadParams, Recombination_SetDefParams, &
hyrec.F90:    Recombination_Validate, Recombination_Name
hyrec.F90:    subroutine Recombination_ReadParams(R, Ini)
hyrec.F90:    Type(RecombinationParams) :: R
hyrec.F90:    end subroutine Recombination_ReadParams
hyrec.F90:    subroutine Recombination_SetDefParams(R)
hyrec.F90:    type (RecombinationParams) ::R
hyrec.F90:    end subroutine Recombination_SetDefParams
hyrec.F90:    subroutine Recombination_Validate(R, OK)
hyrec.F90:    Type(RecombinationParams), intent(in) :: R
hyrec.F90:    end subroutine Recombination_Validate
hyrec.F90:    function Recombination_tm(a)
hyrec.F90:    real(dl) Recombination_tm, hyrec_tm
hyrec.F90:    Recombination_tm =  hyrec_tm(a);
hyrec.F90:    end function Recombination_tm
hyrec.F90:    function Recombination_xe(a)
hyrec.F90:    real(dl) Recombination_xe,hyrec_xe
hyrec.F90:    Recombination_xe = hyrec_xe(a);
hyrec.F90:    end function Recombination_xe
hyrec.F90:    subroutine Recombination_init(Recomb, OmegaC, OmegaB, OmegaN, Omegav, h0inp, tcmb, yp, num_nu)
hyrec.F90:    Type (RecombinationParams), intent(in) :: Recomb
hyrec.F90:    end subroutine Recombination_init
hyrec.F90:    end module Recombination
inidriver.F90:    !     See readme.html for documentation. This is a sample driver routine that reads
inidriver.F90:    MatterPowerFileNames(max_transfer_redshifts), outroot, version_check
inidriver.F90:    P%OutputNormalization=outNone
inidriver.F90:    ! 1) Initialization of EFTCAMB flags.
inidriver.F90:    ! 2) Initialization of EFTCAMB model properties flags.
inidriver.F90:         ! read the DE eos model selection flag:
inidriver.F90:         ! read pure EFT Horndeski model selection flag:
inidriver.F90:         ! read RPH model selection flags:
inidriver.F90:    ! 3) Initialization of EFTCAMB stability flags:
inidriver.F90:         P%EFTAdditionalPriors        = Ini_Read_Logical('EFTAdditionalPriors',.true.)
inidriver.F90:    ! 4) Initialization of EFTCAMB model parameters.
inidriver.F90:    P%yhe    = Ini_Read_Double('helium_fraction',0.24_dl)
inidriver.F90:        numstr = Ini_Read_String('nu_mass_fractions')
inidriver.F90:            if (P%Nu_mass_eigenstates >1) stop 'must give nu_mass_fractions for the eigenstates'
inidriver.F90:            P%Nu_mass_fractions(1)=1
inidriver.F90:            read(numstr,*) P%Nu_mass_fractions(1:P%Nu_mass_eigenstates)
inidriver.F90:        P%Transfer%high_precision=  Ini_Read_Logical('transfer_high_precision',.false.)
inidriver.F90:        P%transfer%high_precision = .false.
inidriver.F90:    call Reionization_ReadParams(P%Reion, DefIni)
inidriver.F90:    call Recombination_ReadParams(P%Recomb, DefIni)
inidriver.F90:    if (Ini_HasKey('recombination')) then
inidriver.F90:        i = Ini_Read_Int('recombination',1)
inidriver.F90:        if (i/=1) stop 'recombination option deprecated'
inidriver.F90:        P%Scalar_initial_condition = Ini_Read_Int('initial_condition',initial_adiabatic)
inidriver.F90:        if (P%Scalar_initial_condition == initial_vector) then
inidriver.F90:            P%InitialConditionVector=0
inidriver.F90:            read (numstr,*) P%InitialConditionVector(1:initial_iso_neutrino_vel)
inidriver.F90:        if (P%Scalar_initial_condition/= initial_adiabatic) use_spline_template = .false.
inidriver.F90:    !optional parameters controlling the computation
inidriver.F90:    P%AccuratePolarization = Ini_Read_Logical('accurate_polarization',.true.)
inidriver.F90:    P%AccurateReionization = Ini_Read_Logical('accurate_reionization',.false.)
inidriver.F90:    version_check = Ini_Read_String('version_check')
inidriver.F90:    if (version_check == '') then
inidriver.F90:        !tag the output used parameters .ini file with the version of CAMB being used now
inidriver.F90:        call TNameValueList_Add(DefIni%ReadValues, 'version_check', version)
inidriver.F90:    else if (version_check /= version) then
inidriver.F90:        write(*,*) 'WARNING: version_check does not match this CAMB version'
inidriver.F90:    if (Ini_HasKey('do_late_rad_trunction')) then
inidriver.F90:        DoLateRadTruncation = Ini_Read_Logical('do_late_rad_trunction',.true.)
inidriver.F90:        if (Ini_HasKey('do_late_rad_truncation')) stop 'check do_late_rad_xxxx'
inidriver.F90:        DoLateRadTruncation = Ini_Read_Logical('do_late_rad_truncation',.true.)
inidriver.F90~:    !     See readme.html for documentation. This is a sample driver routine that reads
inidriver.F90~:    MatterPowerFileNames(max_transfer_redshifts), outroot, version_check
inidriver.F90~:    P%OutputNormalization=outNone
inidriver.F90~:    ! 1) Initialization of EFTCAMB flags.
inidriver.F90~:    ! 2) Initialization of EFTCAMB model properties flags.
inidriver.F90~:         ! read the DE eos model selection flag:
inidriver.F90~:         ! read pure EFT Horndeski model selection flag:
inidriver.F90~:         ! read RPH model selection flags:
inidriver.F90~:    ! 3) Initialization of EFTCAMB stability flags:
inidriver.F90~:         P%EFTAdditionalPriors        = Ini_Read_Logical('EFTAdditionalPriors',.true.)
inidriver.F90~:    ! 4) Initialization of EFTCAMB model parameters.
inidriver.F90~:    P%yhe    = Ini_Read_Double('helium_fraction',0.24_dl)
inidriver.F90~:        numstr = Ini_Read_String('nu_mass_fractions')
inidriver.F90~:            if (P%Nu_mass_eigenstates >1) stop 'must give nu_mass_fractions for the eigenstates'
inidriver.F90~:            P%Nu_mass_fractions(1)=1
inidriver.F90~:            read(numstr,*) P%Nu_mass_fractions(1:P%Nu_mass_eigenstates)
inidriver.F90~:        P%Transfer%high_precision=  Ini_Read_Logical('transfer_high_precision',.false.)
inidriver.F90~:        P%transfer%high_precision = .false.
inidriver.F90~:    call Reionization_ReadParams(P%Reion, DefIni)
inidriver.F90~:    call Recombination_ReadParams(P%Recomb, DefIni)
inidriver.F90~:    if (Ini_HasKey('recombination')) then
inidriver.F90~:        i = Ini_Read_Int('recombination',1)
inidriver.F90~:        if (i/=1) stop 'recombination option deprecated'
inidriver.F90~:        P%Scalar_initial_condition = Ini_Read_Int('initial_condition',initial_adiabatic)
inidriver.F90~:        if (P%Scalar_initial_condition == initial_vector) then
inidriver.F90~:            P%InitialConditionVector=0
inidriver.F90~:            read (numstr,*) P%InitialConditionVector(1:initial_iso_neutrino_vel)
inidriver.F90~:        if (P%Scalar_initial_condition/= initial_adiabatic) use_spline_template = .false.
inidriver.F90~:    !optional parameters controlling the computation
inidriver.F90~:    P%AccuratePolarization = Ini_Read_Logical('accurate_polarization',.true.)
inidriver.F90~:    P%AccurateReionization = Ini_Read_Logical('accurate_reionization',.false.)
inidriver.F90~:    version_check = Ini_Read_String('version_check')
inidriver.F90~:    if (version_check == '') then
inidriver.F90~:        !tag the output used parameters .ini file with the version of CAMB being used now
inidriver.F90~:        call TNameValueList_Add(DefIni%ReadValues, 'version_check', version)
inidriver.F90~:    else if (version_check /= version) then
inidriver.F90~:        write(*,*) 'WARNING: version_check does not match this CAMB version'
inidriver.F90~:    if (Ini_HasKey('do_late_rad_trunction')) then
inidriver.F90~:        DoLateRadTruncation = Ini_Read_Logical('do_late_rad_trunction',.true.)
inidriver.F90~:        if (Ini_HasKey('do_late_rad_truncation')) stop 'check do_late_rad_xxxx'
inidriver.F90~:        DoLateRadTruncation = Ini_Read_Logical('do_late_rad_truncation',.true.)
inifile.f90:    type(TNameValue_pointer), dimension(:), pointer :: Items
inifile.f90:    logical, intent(in), optional :: ignoreDuplicates
inifile.f90:    function TNameValueList_IndexOf(L, AName) result (AValue)
inifile.f90:   end function TNameValueList_IndexOf
inifile.f90:   function TNameValueList_HasKey(L, AName) result (AValue)
inifile.f90:   end function TNameValueList_HasKey
inifile.f90:    logical, optional, intent(in) :: only_if_undefined
inifile.f90:    type(TNameValue_pointer), dimension(:), pointer :: TmpItems
inifile.f90:    logical, optional, intent(in) :: only_if_undefined
inifile.f90:     logical, optional, intent(OUT) :: error
inifile.f90:     logical, optional, intent(IN) :: slash_comments
inifile.f90:  function Ini_ExtractFilePath(aname)
inifile.f90:  end function Ini_ExtractFilePath
inifile.f90:     logical, optional, intent(IN) :: slash_comments
inifile.f90:     logical, optional, intent(in) :: append, only_if_undefined
inifile.f90:          !Settings to read in as defaults, overridden by subsequent re-definitions
inifile.f90:    character (LEN=*), dimension(NumLines), intent(IN) :: Lines
inifile.f90:  function Ini_Read_String(Key, NotFoundFail) result(AValue)
inifile.f90:   logical, optional, intent(IN) :: NotFoundFail
inifile.f90:  end function Ini_Read_String
inifile.f90:  function Ini_Read_String_Default(Key, Default,AllowBlank) result(AValue)
inifile.f90:   logical, intent(in), optional :: AllowBlank
inifile.f90:  end function Ini_Read_String_Default
inifile.f90:  function Ini_Read_String_File(Ini, Key, NotFoundFail) result(AValue)
inifile.f90:   logical, optional, intent(IN) :: NotFoundFail
inifile.f90:  end function Ini_Read_String_File
inifile.f90:  function Ini_Read_String_Default_File(Ini, Key, Default, AllowBlank) result(AValue)
inifile.f90:   logical, intent(in), optional :: AllowBlank
inifile.f90:  end function Ini_Read_String_Default_File
inifile.f90:  function Ini_HasKey(Key) result(AValue)
inifile.f90:  end function Ini_HasKey
inifile.f90:  function Ini_HasKey_File(Ini, Key) result(AValue)
inifile.f90:  end function Ini_HasKey_File
inifile.f90: function Ini_Key_To_Arraykey(Key, index)  result(AValue)
inifile.f90: end function Ini_Key_To_Arraykey
inifile.f90:  function Ini_Read_String_Array(Key, index, NotFoundFail) result(AValue)
inifile.f90:   logical, optional, intent(IN) :: NotFoundFail
inifile.f90:  end function Ini_Read_String_Array
inifile.f90:  function Ini_Read_String_Array_File(Ini, Key, index, NotFoundFail) result(AValue)
inifile.f90:   logical, optional, intent(IN) :: NotFoundFail
inifile.f90:  end function Ini_Read_String_Array_File
inifile.f90:  function Ini_Read_Int_Array(Key, index, Default)
inifile.f90:     integer, optional, intent(IN) :: Default
inifile.f90:   end function Ini_Read_Int_Array
inifile.f90:  function Ini_Read_Int_Array_File(Ini,Key, index, Default)
inifile.f90:   integer, optional, intent(IN) :: Default
inifile.f90:  end function Ini_Read_Int_Array_File
inifile.f90:  function Ini_Read_Int(Key, Default)
inifile.f90:     integer, optional, intent(IN) :: Default
inifile.f90:  end function Ini_Read_Int
inifile.f90:  function Ini_Read_Int_File(Ini, Key, Default)
inifile.f90:   integer, optional, intent(IN) :: Default
inifile.f90:  end function Ini_Read_Int_File
inifile.f90:  function Ini_Read_Double(Key, Default)
inifile.f90:     double precision, optional, intent(IN) :: Default
inifile.f90:     double precision Ini_Read_Double
inifile.f90:  end function Ini_Read_Double
inifile.f90:  function Ini_Read_Double_File(Ini,Key, Default)
inifile.f90:   double precision Ini_Read_Double_File 
inifile.f90:   double precision, optional, intent(IN) :: Default
inifile.f90:  end function Ini_Read_Double_File
inifile.f90:    function Ini_Read_Double_Array(Key, index, Default)
inifile.f90:     double precision, optional, intent(IN) :: Default
inifile.f90:     double precision Ini_Read_Double_Array
inifile.f90:    end function Ini_Read_Double_Array
inifile.f90:  function Ini_Read_Double_Array_File(Ini,Key, index, Default)
inifile.f90:   double precision Ini_Read_Double_Array_File 
inifile.f90:   double precision, optional, intent(IN) :: Default
inifile.f90:  end function Ini_Read_Double_Array_File
inifile.f90:    function Ini_Read_Real(Key, Default)
inifile.f90:     real, optional, intent(IN) :: Default
inifile.f90:    end function Ini_Read_Real
inifile.f90:    function Ini_Read_Real_File(Ini,Key, Default)
inifile.f90:    real, optional, intent(IN) :: Default
inifile.f90:  end function Ini_Read_Real_File
inifile.f90:   function Ini_Read_Real_Array(Key, index, Default)
inifile.f90:     real, optional, intent(IN) :: Default
inifile.f90:   end function Ini_Read_Real_Array
inifile.f90:  function Ini_Read_Real_Array_File(Ini,Key, index, Default)
inifile.f90:   real, optional, intent(IN) :: Default
inifile.f90:  end function Ini_Read_Real_Array_File
inifile.f90:  function Ini_Read_Logical(Key, Default)
inifile.f90:     Logical, optional, intent(IN) :: Default
inifile.f90:  end function Ini_Read_Logical
inifile.f90:  function Ini_Read_Logical_File(Ini, Key, Default)
inifile.f90:   logical, optional, intent(IN) :: Default
inifile.f90:  end function Ini_Read_Logical_File
lensing.f90:!Lensing the C_l using the deflection angle from the computed lensing potential
lensing.f90:!lensing_method=1: using an accurate curved-sky correlation function method
lensing.f90:!accute_BB only does *not* include any non-linear corrections or ensure you have
lensing.f90:!non-linear evolution to cause a significant error.
lensing.f90:!Correlation function routines by AL+AC Nov 2004 with flat-sky borrowings from CMBFAST
lensing.f90:!For better derivations see also astro-ph/0301064 and astro-ph/0301031
lensing.f90:!Uses f90 version of "J1-RECURSION OF 3J-COEFFICIENTS" by K. Schulten and R.G. Gordon 
lensing.f90:use Precision
lensing.f90: real(dl), dimension(:), allocatable :: Bess0, ddBess0
lensing.f90: real(dl), dimension(:), allocatable :: Bess2, ddBess2
lensing.f90: real(dl), dimension(:), allocatable :: Bess4, ddBess4
lensing.f90: real(dl), dimension(:), allocatable :: Bess6, ddBess6
lensing.f90: integer, parameter :: lensed_convolution_margin = 100
lensing.f90: real(dl), dimension(:), allocatable  :: lnfa
lensing.f90:  lmax_extrap = CP%Max_l - lensed_convolution_margin + 450  
lensing.f90: !Accurate curved sky correlation function method
lensing.f90: !Uses non-perturbative isotropic term with 2nd order expansion in C_{gl,2}
lensing.f90:    do while(lSamp%l(max_lensed_ix) > CP%Max_l - lensed_convolution_margin) 
lensing.f90:       range_fac= max(1._dl,32/AccuracyBoost) !fraction of range to integrate
lensing.f90:      !which is then mitigated by the apodization below
lensing.f90:       write (*,*) 'You need to normalize the high-L template so it is dimensionless'
lensing.f90:       !these are approx, but extremely good approximations
lensing.f90:!Interpolate contributions
lensing.f90:  real(dl), allocatable, dimension(:,:,:) :: lens_contrib(:,:,:)
lensing.f90:!Interpolate the Bessel functions, and compute sigma^2 and C_{gl,2} 
lensing.f90:!Get difference between lensed and unlensed correlation function
lensing.f90:  real(dl) , dimension (:,:,:), allocatable :: bare_cls
lensing.f90:  real(dl) , dimension (:,:,:), allocatable :: iCl_lensed
lensing.f90:  DoPol = CP%AccuratePolarization
lensing.f90:        !  Contributions to C_al are a smooth function of l_1 - so interpolate
lensing.f90:        else !No polarization
lensing.f90:              if (g1 == 0 ) cycle  !Contribution is zero
lensing.f90:          end if !No polarization
lensing.f90:       !Interpolate contributions to sum and add up
lensing.f90:       real(dl), allocatable, dimension(:) :: x
lensing.f90:      FUNCTION bessj0(x)
lensing.f90:      END FUNCTION bessj0
lensing.f90:      FUNCTION bessj(n,x)
lensing.f90:      END FUNCTION bessj
lensing.f90:! Auxiliary Bessel functions for N=0, N=1
lensing.f90:      FUNCTION BESSI0(X)
lensing.f90:      double precision X,BESSI0,Y,P1,P2,P3,P4,P5,P6,P7,  &
lensing.f90:      END FUNCTION BESSI0
lensing.f90:      FUNCTION BESSI1(X)
lensing.f90:      double precision X,BESSI1,Y,P1,P2,P3,P4,P5,P6,P7,  &
lensing.f90:      END FUNCTION BESSI1
lensing.f90:      FUNCTION BESSI(N,X)
lensing.f90:!     This subroutine calculates the first kind modified Bessel function
lensing.f90:!     recursion formula, when X > N. For X < N, the Miller's algorithm
lensing.f90:!     C.W.CLENSHAW, CHEBYSHEV SERIES FOR MATHEMATICAL FUNCTIONS,
lensing.f90:      double precision, parameter ::  BIGNO = 1.D10, BIGNI = 1.D-10
lensing.f90:      double precision X,BESSI,TOX,BIM,BI,BIP
lensing.f90:      END FUNCTION BESSI
Makefile:#The options here work in v4.6+
Makefile:#native optimization does not work on Mac
Makefile:#Location of FITSIO and name of library
Makefile:#Location of HEALPIX for building camb_fits
Makefile_main:#Files containing evolution equations initial power spectrum module
Makefile_main:EQUATIONS     ?= equations_EFT
Makefile_main:REIONIZATION ?= reionization
Makefile_main:RECOMBINATION ?= recfast
Makefile_main:CAMBLIB       = $(OUTPUT_DIR)/libcamb_$(RECOMBINATION).a
Makefile_main:EFT_OBJ       =  $(OUTPUT_DIR)/EFT_def.o  $(OUTPUT_DIR)/EFT_designer.o  $(OUTPUT_DIR)/EFT_Horndeski.o  $(OUTPUT_DIR)/EFT_functions.o $(OUTPUT_DIR)/EFT_main.o
Makefile_main:	$(OUTPUT_DIR)/inifile.o  $(OUTPUT_DIR)/$(POWERSPECTRUM).o  $(OUTPUT_DIR)/$(RECOMBINATION).o \
Makefile_main:	$(OUTPUT_DIR)/$(REIONIZATION).o $(OUTPUT_DIR)/modules.o $(OUTPUT_DIR)/bessels.o $(EFT_OBJ) $(OUTPUT_DIR)/$(EQUATIONS).o \
Makefile_main:	$(OUTPUT_DIR)/$(POWERSPECTRUM).o $(OUTPUT_DIR)/$(RECOMBINATION).o \
Makefile_main:	$(OUTPUT_DIR)/$(REIONIZATION).o $(OUTPUT_DIR)/modules.o $(OUTPUT_DIR)/bessels.o $(EFT_OBJ) $(OUTPUT_DIR)/$(EQUATIONS).o \
Makefile_main:ifeq ($(RECOMBINATION),cosmorec)
Makefile_main:ifeq ($(RECOMBINATION),hyrec)
Makefile_main:$(OUTPUT_DIR)/$(RECOMBINATION).o: $(OUTPUT_DIR)/subroutines.o $(OUTPUT_DIR)/inifile.o
Makefile_main:$(OUTPUT_DIR)/$(REIONIZATION).o: $(OUTPUT_DIR)/constants.o $(OUTPUT_DIR)/inifile.o
Makefile_main:$(OUTPUT_DIR)/modules.o: $(OUTPUT_DIR)/$(REIONIZATION).o $(OUTPUT_DIR)/$(POWERSPECTRUM).o $(OUTPUT_DIR)/$(RECOMBINATION).o
Makefile_main:$(OUTPUT_DIR)/$(EQUATIONS).o: $(OUTPUT_DIR)/bessels.o
Makefile_main:$(OUTPUT_DIR)/$(NONLINEAR).o:  $(OUTPUT_DIR)/modules.o $(OUTPUT_DIR)/$(EQUATIONS).o
Makefile_main:$(OUTPUT_DIR)/cmbmain.o: $(OUTPUT_DIR)/lensing.o $(OUTPUT_DIR)/$(NONLINEAR).o $(OUTPUT_DIR)/$(EQUATIONS).o $(OUTPUT_DIR)/$(BISPECTRUM).o
Matrix_utils.F90:    !Precision of matrix operators
Matrix_utils.F90:        real(dm), dimension(:,:), pointer :: M
Matrix_utils.F90:    function GetMatrixTime()
Matrix_utils.F90:    end function GetMatrixTime
Matrix_utils.F90:    character(LEN=*), intent(in), optional :: commentline   
Matrix_utils.F90:    logical, intent(in), optional :: forcetable
Matrix_utils.F90:    double precision, intent(in) :: mat(:,:)
Matrix_utils.F90:    logical, intent(in), optional :: forcetable
Matrix_utils.F90:    function Matrix_Diag(M, n)
Matrix_utils.F90:    end function Matrix_Diag
Matrix_utils.F90:    function ILAENV_wrap(i,S1,S2,a,b,c,d)
Matrix_utils.F90:    end  function ILAENV_wrap
Matrix_utils.F90:    real(dm), allocatable, dimension(:) :: tmp
Matrix_utils.F90:    !Complex version. Does m = U diag U^dag, returning U in M
Matrix_utils.F90:    real(dm), allocatable, dimension(:) :: tmp
Matrix_utils.F90:    integer, allocatable,dimension(:):: iwork
Matrix_utils.F90:    !Real version. Does m = U diag U^dag, returning U in M
Matrix_utils.F90:    real(dm), allocatable, dimension(:) :: work
Matrix_utils.F90:    real(dm), allocatable, dimension(:,:) :: tmp
Matrix_utils.F90:    integer, allocatable,dimension(:):: supp,iwork
Matrix_utils.F90:    !Complex version. Does m = U diag U^dag, returning U in M
Matrix_utils.F90:    real(dm), allocatable, dimension(:) :: Rwork
Matrix_utils.F90:    complex(dm), allocatable, dimension(:) :: work
Matrix_utils.F90:    complex(dm), allocatable, dimension(:,:) :: tmp
Matrix_utils.F90:    integer, allocatable,dimension(:):: supp,iwork
Matrix_utils.F90:    !Complex version. Does m = U diag U^dag, returning U in M
Matrix_utils.F90:    real(dm), allocatable, dimension(:) :: Rwork
Matrix_utils.F90:    complex(dm), allocatable, dimension(:) :: tmp
Matrix_utils.F90:    integer, allocatable,dimension(:):: iwork
Matrix_utils.F90:    function Matrix_CTrace(M)
Matrix_utils.F90:    end function Matrix_CTrace
Matrix_utils.F90:    function Matrix_Trace(M)
Matrix_utils.F90:    end function Matrix_Trace
Matrix_utils.F90:    function MatrixSym_LogDet(mat) result (logDet)
Matrix_utils.F90:    end function MatrixSym_LogDet
Matrix_utils.F90:    complex(dm), dimension(:,:), allocatable :: C
Matrix_utils.F90:    logical, intent(in), optional :: triangular
Matrix_utils.F90:    real(dm), dimension(:,:), allocatable :: C
Matrix_utils.F90:    logical, intent(in), optional :: triangular
Matrix_utils.F90:    real(dm), dimension(:,:), allocatable :: C
Matrix_utils.F90:    complex(dm), intent(in), optional :: a,b
Matrix_utils.F90:    complex(dm), intent(in), optional :: a,b
Matrix_utils.F90:    complex(dm), intent(in), optional :: a,b
Matrix_utils.F90:    real(dm), intent(in), optional :: a
Matrix_utils.F90:    real(dm), dimension(:,:), allocatable :: tmp
Matrix_utils.F90:    real(dm), intent(in), optional :: a,b
Matrix_utils.F90:    real(dm), intent(in), optional :: a,b
Matrix_utils.F90:    real(dm), intent(in), optional :: a,b
Matrix_utils.F90:    complex(dm), intent(in), optional :: a,b
Matrix_utils.F90:    real(dm), intent(in), optional :: a,b
Matrix_utils.F90:    complex(dm), intent(in), optional :: a,b
Matrix_utils.F90:    real(dm), intent(in), optional :: a,b
Matrix_utils.F90:    integer, optional :: err
Matrix_utils.F90:    logical, intent(in), optional :: zeroed
Matrix_utils.F90:    logical, intent(in), optional :: transpose 
Matrix_utils.F90:    integer, intent(out), optional :: error
Matrix_utils.F90:    logical, intent(in), optional :: dagger 
Matrix_utils.F90:    !This should not be used in real situations, but useful for quick testing
Matrix_utils.F90:    integer, optional :: err
Matrix_utils.F90:    !     real(dm), dimension(:,:), allocatable :: tmp, tmp2
Matrix_utils.F90:    !     real(dm), dimension(:), allocatable :: norm
Matrix_utils.F90:    function Matrix_GaussianLogLike(Cov, d) result(LogLike)
Matrix_utils.F90:    !** Cov is destroyed by the function** [replaced by choleksy lower triangular]
Matrix_utils.F90:    end function Matrix_GaussianLogLike
Matrix_utils.F90:    function Matrix_GaussianLogLikeDouble(Cov, d) result(LogLike)
Matrix_utils.F90:    !** Cov is destroyed by the function** [replaced by choleksy lower triangular]
Matrix_utils.F90:    double precision, intent(inout):: Cov(:,:)
Matrix_utils.F90:    double precision, intent(in):: d(:)
Matrix_utils.F90:    double precision, allocatable :: tmp(:)
Matrix_utils.F90:    double precision :: LogLike
Matrix_utils.F90:    end function Matrix_GaussianLogLikeDouble
Matrix_utils.F90:    !This should not be used in real situations, but useful for quick testing
Matrix_utils.F90:    real(dm), dimension(:,:), allocatable :: tmp, VT
Matrix_utils.F90:    !Do singular value decomposition of m x n matrix Mat
Matrix_utils.F90:    real(dm), allocatable, dimension (:) :: rv1 
Matrix_utils.F90:    !Do singular value decomposition of m x n matrix Mat
Matrix_utils.F90:    real(dm), intent(out),optional :: U(m,m)
Matrix_utils.F90:    integer,allocatable, dimension (:) :: IWork
Matrix_utils.F90:    real(dm), allocatable, dimension (:) :: rv1
Matrix_utils.F90:    !Do singular value decomposition of m x n matrix Mat
Matrix_utils.F90:    complex(dm), intent(out),optional :: U(m,m)
Matrix_utils.F90:    integer,allocatable, dimension (:) :: IWork
Matrix_utils.F90:    complex(dm), allocatable, dimension (:) :: rv1 
Matrix_utils.F90:    real(dm), allocatable, dimension (:) :: rwork
Matrix_utils.F90:    !Do singular value decomposition of m x n matrix Mat
Matrix_utils.F90:    complex(dm), intent(out),optional :: VT(n,n)
Matrix_utils.F90:    integer,allocatable, dimension (:) :: IWork
Matrix_utils.F90:    complex(dm), allocatable, dimension (:) :: rv1 
Matrix_utils.F90:    real(dm), allocatable, dimension (:) :: rwork
Matrix_utils.F90:    !Do singular value decomposition of m x n matrix Mat
Matrix_utils.F90:    complex(dm), allocatable, dimension (:) :: rv1 
Matrix_utils.F90:    complex(dm), allocatable, dimension (:,:) :: U
Matrix_utils.F90:    integer, allocatable, dimension(:) :: IWork
Matrix_utils.F90:    real(dm), allocatable, dimension (:) :: rwork
Matrix_utils.F90:    real(dm), dimension(:,:), allocatable :: tmp
Matrix_utils.F90:    real(dm), dimension(:), allocatable :: work
Matrix_utils.F90:    real(dm), dimension(:,:), allocatable :: tmp
Matrix_utils.F90:    function Matrix_vecdot(vec1,vec2)
Matrix_utils.F90:    end function Matrix_vecdot
Matrix_utils.F90:    function Matrix_QuadForm(Mat,vec)
Matrix_utils.F90:    real(dm), dimension(:), allocatable :: out
Matrix_utils.F90:    end function Matrix_QuadForm
Matrix_utils.F90:    real(dm), intent(in), optional :: a,b
Matrix_utils.F90:    real, intent(in), optional :: a,b
Matrix_utils.F90:    real(dm), intent(in), optional :: a,b
Matrix_utils.F90:    real, intent(in), optional :: a,b
Matrix_utils.F90:    function Matrix_vecdotSingle(vec1,vec2)
Matrix_utils.F90:    end function Matrix_vecdotSingle
Matrix_utils.F90:                call MPI_SEND(AM%M,size(AM%M),MPI_DOUBLE_PRECISION, j, 1, MPI_COMM_WORLD, ierr) 
Matrix_utils.F90:                call MPI_RECV(AM%M,size(AM%M),MPI_DOUBLE_PRECISION, 0, 1, MPI_COMM_WORLD,MPI_STATUS_IGNORE, ierr) 
Matrix_utils.F90:                    call MPI_RECV(Arr(j)%M,size(Arr(j)%M),MPI_DOUBLE_PRECISION, sid, 1, MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr) 
Matrix_utils.F90:                call MPI_SEND(AM%M,size(AM%M),MPI_DOUBLE_PRECISION, 0, 1, MPI_COMM_WORLD, ierr) 
Matrix_utils.F90:            call MPI_RECV(ARr(j)%M,Size(ARr(j)%M),MPI_DOUBLE_PRECISION, sid, 1, MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr) 
Binary file matter_comp_wbd_10.pdf matches
Binary file matter_comp_wbd_75.pdf matches
modules.f90:    !     See readme.html for documentation.
modules.f90:    !     REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.
modules.f90:    !     By way of example, but not limitation,
modules.f90:    !     M.I.T. AND C.f.A MAKE NO REPRESENTATIONS OR WARRANTIES OF
modules.f90:    !     THE USE OF THE LICENSED SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE
modules.f90:    !     portions of this software are based on the COSMICS package of
modules.f90:    !     E. Bertschinger.  See the LICENSE file of the COSMICS distribution
modules.f90:    !     for restrictions on the modification and distribution of this software.
modules.f90:    use precision
modules.f90:    use Reionization
modules.f90:    use Recombination
modules.f90:    character(LEN=*), parameter :: version = 'Feb15'
modules.f90:    integer :: FeedbackLevel = 0 !if >0 print out useful information about the model
modules.f90:    logical, parameter :: DebugEvolution = .false. !Set to true to do all the evolution for all k
modules.f90:    logical, parameter :: hard_bispectrum = .false. ! e.g. warm inflation where delicate cancellations
modules.f90:    logical, parameter :: full_bessel_integration = .false. !(go into the tails when calculating the sources)
modules.f90:    !Nu_int: always integrate distribution function
modules.f90:    !Nu_trunc: switch to expansion in velocity once non-relativistic
modules.f90:    Type(Regions) :: TimeSteps
modules.f90:        logical     ::  high_precision
modules.f90:    !other variables, options, derived variables, etc.
modules.f90:    ! _tensor settings only used in initialization,
modules.f90:    logical   :: share_delta_neff !take fractional part to heat all eigenstates the same
modules.f90:    real(dl)  :: Nu_mass_fractions(max_nu) !The ratios of the total densities
modules.f90:        ! 1) Definition of flags:
modules.f90:        ! 2) Definition of stability flags:
modules.f90:        logical :: EFT_mathematical_stability, EFT_physical_stability, EFTAdditionalPriors, MinkowskyPriors
modules.f90:        ! 3) Definition of model parameters:
modules.f90:        real(dl) :: EFTGeffG !present-day ratio of effective graviational coupling to G
modules.f90:    integer   :: Scalar_initial_condition
modules.f90:    integer   :: OutputNormalization
modules.f90:    !outNone, or C_OutputNormalization=1 if > 1
modules.f90:    logical   :: AccuratePolarization
modules.f90:    !Do you care about the accuracy of the polarization Cls?
modules.f90:    !Reionization settings - used if Reion%Reionization=.true.
modules.f90:    logical   :: AccurateReionization
modules.f90:    !Do you care about pecent level accuracy on EE signal from reionization?
modules.f90:    type(ReionizationParams) :: Reion
modules.f90:    type(RecombinationParams):: Recomb
modules.f90:    real(dl) ::  InitialConditionVector(1:10) !Allow up to 10 for future extensions
modules.f90:    !ignored unless Scalar_initial_condition == initial_vector
modules.f90:    type(ReionizationHistory) :: ReionHist
modules.f90:    type(CAMBparams), save :: CP  !Global collection of parameters
modules.f90:    !     taurst,taurend - time at start/end of recombination
modules.f90:    !     dtaurec - dtau during recombination
modules.f90:    !     adotrad - a(tau) in radiation era
modules.f90:    !Increase lSampleBoost to increase sampling in lSamp%l for Cl interpolation
modules.f90:    real(dl),parameter :: tol=1.0d-4 !Base tolerance for integrations
modules.f90:    !fiducial high-accuracy high-L C_L used for making small cosmology-independent numerical corrections
modules.f90:    !to lensing and C_L interpolation. Ideally close to models of interest, but dependence is weak.
modules.f90:    subroutine CAMBParams_Set(P, Haux, error, DoReion)
modules.f90:    real(dl) GetOmegak, fractional_number, conv
modules.f90:    integer, optional :: error !Zero if OK
modules.f90:    logical, optional :: DoReion
modules.f90:    logical WantReion
modules.f90:    if (present(DoReion)) then
modules.f90:        WantReion = DoReion
modules.f90:        WantReion = .true.
modules.f90:            CP%AccuratePolarization = .false.
modules.f90:            CP%Reion%Reionization = .false.
modules.f90:            fractional_number = CP%Num_Nu_massless + CP%Num_Nu_massive
modules.f90:            neff_i = fractional_number/(actual_massless + CP%Num_Nu_massive)
modules.f90:        if (abs(sum(CP%Nu_mass_fractions(1:CP%Nu_mass_eigenstates))-1) > 1e-4) &
modules.f90:        stop 'Nu_mass_fractions do not add up to 1'
modules.f90:    !  grho gives the contribution to the expansion rate from: (g) photons,
modules.f90:    !correction for fractional number of neutrinos, e.g. 3.04 to give slightly higher T_nu hence rhor
modules.f90:    !  adotrad gives the relation a(tau) in the radiation era:
modules.f90:	!MODIFIED BY NELSON (NEED TO RECOVER H0 TODAY FROM BRANS-DICKE EVOLUTION. THIS IS THE PERFECT TIME!!!
modules.f90:            if (WantReion) call Reionization_Init(CP%Reion,CP%ReionHist, CP%YHe, akthom, CP%tau0, FeedbackLevel)
modules.f90:    function GetTestTime()
modules.f90:    end function GetTestTime
modules.f90:    function rofChi(Chi) !sinh(chi) for open, sin(chi) for closed.
modules.f90:    end function rofChi
modules.f90:    function cosfunc (Chi)
modules.f90:    end function cosfunc
modules.f90:    function tanfunc(Chi)
modules.f90:    end  function tanfunc
modules.f90:    function invsinfunc(x)
modules.f90:    end function invsinfunc
modules.f90:    function f_K(x)
modules.f90:    end function f_K
modules.f90:    function DeltaTime(a1,a2, in_tol)
modules.f90:    real(dl), optional, intent(in) :: in_tol
modules.f90:    real(dl) dtauda, rombint !diff of tau w.CP%r.t a and integration
modules.f90:    end function DeltaTime
modules.f90:    function TimeOfz(z)
modules.f90:    end function TimeOfz
modules.f90:    function DeltaPhysicalTimeGyr(a1,a2, in_tol)
modules.f90:    real(dl), optional, intent(in) :: in_tol
modules.f90:    end function DeltaPhysicalTimeGyr
modules.f90:    function AngularDiameterDistance(z)
modules.f90:    end function AngularDiameterDistance
modules.f90:    function AngularDiameterDistance2(z1, z2) ! z1 < z2
modules.f90:    end function AngularDiameterDistance2
modules.f90:    function LuminosityDistance(z)
modules.f90:    end function LuminosityDistance
modules.f90:    function ComovingRadialDistance(z)
modules.f90:    end function ComovingRadialDistance
modules.f90:    function Hofz(z)
modules.f90:    end function Hofz
modules.f90:    real(dl) function BAO_D_v_from_DA_H(z, DA, Hz)
modules.f90:    end function BAO_D_v_from_DA_H
modules.f90:    real(dl) function BAO_D_v(z)
modules.f90:    end function BAO_D_v
modules.f90:    function dsound_da_exact(a)
modules.f90:    end function dsound_da_exact
modules.f90:    function dsound_da(a)
modules.f90:    end function dsound_da
modules.f90:    function dtda(a)
modules.f90:    end function
modules.f90:    function CosmomcTheta()
modules.f90:    end function CosmomcTheta
modules.f90:    use precision
modules.f90:    function lvalues_indexOf(lSet,l)
modules.f90:    end function  lvalues_indexOf
modules.f90:    if (CP%AccurateReionization) then
modules.f90:            !Not in CP%flat case so interpolation table is the same when using lower l_max
modules.f90:    integer, intent(in), optional :: template_index
modules.f90:                !overlap to reduce interpolation artefacts
modules.f90:    use precision
modules.f90:        real(dl), dimension(:), pointer :: k
modules.f90:        real(dl), dimension(:), pointer :: Source
modules.f90:        !Cl transfer function variables
modules.f90:        !values of q for integration over q to get C_ls
modules.f90:        Type (Regions) :: q
modules.f90:        real(dl), dimension(:,:,:), pointer :: Delta_p_l_k => NULL()
modules.f90:        integer, dimension(:), pointer :: Limber_l_min => NULL()
modules.f90:        Type(LimberRec), dimension(:,:), pointer :: Limber_windows => NULL()
modules.f90:    real(dl), dimension (:,:,:), allocatable :: Cl_scalar, Cl_tensor, Cl_vector
modules.f90:    real(dl), dimension (:,:,:,:), allocatable :: Cl_Scalar_Array
modules.f90:    real(dl) , dimension (:,:,:), allocatable :: Cl_lensed
modules.f90:    if (st /= 0) stop 'Init_ClTransfer: Error allocating memory for transfer functions'
modules.f90:    real(dl), intent(in), optional :: factor
modules.f90:    real(dl), intent(in), optional :: factor
modules.f90:    !output file of dimensionless [l(l+1)]^2 C_phi_phi/2pi and [l(l+1)]^(3/2) C_phi_T/2pi
modules.f90:    real(dl), intent(in), optional :: factor
modules.f90:    use precision
modules.f90:    !smallest a*m_nu to integrate distribution function rather than using series
modules.f90:    real(dl), dimension(:), allocatable ::  r1,p1,dr1,dp1,ddr1, ddp1, dddp1
modules.f90:    ! real(dl), dimension(:), allocatable ::  r1,p1,dr1,dp1,ddr1
modules.f90:    !  Initialize interpolation tables for massive neutrinos.
modules.f90:    !  Use cubic splines interpolation of log rhonu and pnu vs. log a*m.
modules.f90:        nu_masses(i)=const/(1.5d0*zeta3)*grhom/grhor*CP%omegan*CP%Nu_mass_fractions(i) &
modules.f90:    !Integration scheme gets (Fermi-Dirac thing)*q^n exact,for n=-4, -2..2
modules.f90:    !  Integrate up to qmax and then use asymptotic expansion for remainder.
modules.f90:    !  Apply asymptotic corrrection for q>qmax and normalize by relativistic
modules.f90:    use precision
modules.f90:    !  Cubic spline interpolation.
modules.f90:    use precision
modules.f90:    !  Cubic spline interpolation.
modules.f90:    function Nu_drho(am,adotoa,rhonu) result (rhonudot)
modules.f90:    use precision
modules.f90:    !  and the shear perturbation.
modules.f90:        !  Cubic spline interpolation for rhonudot.
modules.f90:    end function Nu_drho
modules.f90:    function Nu_pidot(am,adotoa,presnu) result (presnudot)
modules.f90:        use precision
modules.f90:    end function Nu_pidot
modules.f90:    function Nu_pidotdot(am,adotoa,Hdot,presnu,presnudot) result (presnudotdot)
modules.f90:        use precision
modules.f90:    end function Nu_pidotdot
modules.f90:    ! wrapper function to avoid cirular module references
modules.f90:        ! total perturbations with and without neutrinos, with neutrinos+dark energy in the numerator
modules.f90:    !set to false to output calculated values for later interpolation
modules.f90:    !Transfer_tot uses total matter perturbation
modules.f90:        integer   ::  num_q_trans   !    number of steps in k for transfer calculation
modules.f90:        real(dl), dimension (:), pointer :: q_trans => NULL()
modules.f90:        real(dl), dimension (:,:), pointer ::  sigma_8 => NULL()
modules.f90:        real(dl), dimension (:,:), pointer ::  sigma2_vdelta_8 => NULL() !growth from sigma_{v delta}
modules.f90:        real, dimension(:,:,:), pointer :: TransferData => NULL()
modules.f90:        !everything is a function of k/h
modules.f90:        real(dl), dimension(:), pointer :: log_kh => NULL(), redshifts => NULL()
modules.f90:        real(dl), dimension(:,:), allocatable :: matpower, ddmat
modules.f90:        !function of k and redshift NonLinearScaling(k_index,z_index)
modules.f90:        real(dl), dimension(:,:), pointer :: nonlin_ratio => NULL()
modules.f90:    integer, optional, intent(in) :: var1
modules.f90:    integer, optional, intent(in) :: var2
modules.f90:    logical, optional, intent(in) :: hubble_units
modules.f90:    !Does *NOT* include non-linear corrections
modules.f90:    !Get total matter power spectrum in units of (h Mpc^{-1})^3 ready for interpolation.
modules.f90:    !Here there definition is < Delta^2(x) > = 1/(2 pi)^3 int d^3k P_k(k)
modules.f90:    integer, intent(in), optional :: power_ix
modules.f90:    integer, intent(in), optional :: itf_only
modules.f90:    integer, intent(in), optional :: var1, var2
modules.f90:    !Get total matter power spectrum in units of (h Mpc^{-1})^3 ready for interpolation.
modules.f90:    !Here there definition is < Delta^2(x) > = 1/(2 pi)^3 int d^3k P_k(k)
modules.f90:    function MatterPowerData_k(PK,  kh, itf) result(outpower)
modules.f90:    !Get matter power spectrum at particular k/h by interpolation
modules.f90:        !Do dodgy linear extrapolation on assumption accuracy of result won't matter
modules.f90:    end function MatterPowerData_k
modules.f90:    integer, intent(in), optional :: var1, var2
modules.f90:    !redshift in the PK_redshifts array.  The position of this redshift in the master redshift
modules.f90:    !if CP%Nonlinear/ = NonLinear_none includes non-linear evolution
modules.f90:    !Here there definition is < Delta^2(x) > = 1/(2 pi)^3 int d^3k P_k(k)
modules.f90:    integer, intent(in), optional :: var1, var2
modules.f90:    !            stop 'Transfer_GetMatterPower: kh out of computed region'
modules.f90:        !Put in power spectrum later: transfer functions should be smooth, initial power may not be
modules.f90:        !Do linear extrapolation in the log
modules.f90:        !Obviouly inaccurate, non-linear etc, but OK if only using in tails of window functions
modules.f90:    !set va1, var2 e.g. to get the value from some combination of transfer functions rather than total
modules.f90:    integer, intent(in), optional :: var1, var2
modules.f90:    integer, intent(in), optional :: power_ix
modules.f90:    logical, intent(in), optional :: root !if true, give sigma8, otherwise sigma8^2
modules.f90:    real(dl), dimension(CP%Transfer%PK_num_redshifts) ::  dsig8, dsig8o, sig8, sig8o
modules.f90:            !Contribution should be very small in any case
modules.f90:    integer, intent(in), optional :: redshift_ix, var1, var2, power_ix
modules.f90:    real(dl), dimension(size(R)) ::  x, win, dsig8, dsig8o, sig8, sig8o
modules.f90:                !Contribution should be very small in any case
modules.f90:    ! set va1, var2 e.g. to get the value from some combination of transfer functions rather than total
modules.f90:    real(dl), intent(in), optional :: R
modules.f90:    integer, intent(in), optional :: var1, var2
modules.f90:    real(dl), intent(in), optional :: R
modules.f90:    integer, intent(in), optional :: var_delta,var_v
modules.f90:    !Changed function below to write to only P%NLL_*redshifts* variables
modules.f90:        !only notionally more accuracy, more stable for RS
modules.f90:    real, dimension(:,:,:), allocatable :: outpower
modules.f90:    !JD 08/13 New function for nonlinear lensing of CMB + MPK compatibility
modules.f90:    real(dl), dimension(:), allocatable :: vis,dvis,ddvis,expmmu,dopac, opac, lenswin
modules.f90:    !Times when 1/(opacity*tau) = 0.01, for use switching tight coupling approximation
modules.f90:    !and ionization fraction by interpolating pre-computed tables.
modules.f90:    real(dl), intent(out), optional :: dopacity
modules.f90:        !Linear interpolation if out of bounds (should not occur).
modules.f90:        !Cubic spline interpolation.
modules.f90:    function Thermo_OpacityToTime(opacity)
modules.f90:    end function Thermo_OpacityToTime
modules.f90:    !  Compute and save unperturbed baryon temperature and ionization fraction
modules.f90:    !  as a function of time.  With nthermo=10000, xe(tau) has a relative
modules.f90:    ! accuracy (numerical integration precision) better than 1.e-5.
modules.f90:    use precision
modules.f90:    real(dl) dtauda  !diff of tau w.CP%r.t a and integration
modules.f90:    call Recombination_Init(CP%Recomb, CP%omegac/(CP%H0/100.0)**2.0, CP%omegab/(CP%H0/100.0)**2.0,CP%Omegan/(CP%H0/100.0)**2.0, &
modules.f90:    call Recombination_Init(CP%Recomb, CP%omegac, CP%omegab,CP%Omegan, CP%Omegav, &
modules.f90:    !  Initial conditions: assume radiation-dominated universe.
modules.f90:    !  Assume that any entropy generation occurs before tauminn.
modules.f90:    !  This gives wrong temperature before pair annihilation, but
modules.f90:        !  Integrate Friedmann equation using inverse trapezoidal rule.
modules.f90:        !  Baryon temperature evolution: adiabatic except for Thomson cooling.
modules.f90:        !  Use  quadrature solution.
modules.f90:        ! This is redundant as also calculated in REFCAST, but agrees well before reionization
modules.f90:        !  the solution of the ionization equation.
modules.f90:        ! If there is re-ionization, smoothly increase xe to the
modules.f90:        if (CP%Reion%Reionization .and. tau > CP%ReionHist%tau_start) then
modules.f90:            xe(i) = Reionization_xe(a, tau, xe(ncount))
modules.f90:            if (CP%AccurateReionization .and. CP%DerivedParameters) then
modules.f90:                dotmu(i)=(Recombination_xe(a) - xe(i))*akthom/a2
modules.f90:            xe(i)=Recombination_xe(a)
modules.f90:        ! Calculation of the visibility function
modules.f90:    if (CP%Reion%Reionization .and. (xe(nthermo) < 0.999d0)) then
modules.f90:        write(*,*) 'Check input parameters an Reionization_xe'
modules.f90:        write(*,*) 'function in the Reionization module'
modules.f90:            if (.not. CP%AccurateReionization .and. &
modules.f90:            if (CP%AccurateReionization .and. CP%DerivedParameters .and. z_star==0.d0) then
modules.f90:    if (CP%AccurateReionization .and. FeedbackLevel > 0 .and. CP%DerivedParameters) then
modules.f90:        write(*,'("Reion opt depth      = ",f7.4)') actual_opt_depth
modules.f90:        call GlobalError('inithermo: failed to find end of recombination',error_reionization)
modules.f90:    ! Calculating the timesteps during recombination.
modules.f90:    if (CP%Reion%Reionization) taurend=min(taurend,CP%ReionHist%tau_start)
modules.f90:    ! Calculating the timesteps after recombination
modules.f90:    if (CP%Reion%Reionization) then
modules.f90:        nri0=int(Reionization_timesteps(CP%ReionHist)*AccuracyBoost)
modules.f90:        !Steps while reionization going from zero to maximum
modules.f90:        call Ranges_Add(TimeSteps,CP%ReionHist%tau_start,CP%ReionHist%tau_complete,nri0)
modules.f90:    !Create arrays out of the region information.
modules.f90:    !     Cubic-spline interpolation.
modules.f90:    function ddamping_da(a)
modules.f90:    !ignoring reionisation, not relevant for distance measures
modules.f90:    ddamping_da = (R**2 + 16*(1+R)/15)/(1+R)**2*dtauda(a)*a**2/(Recombination_xe(a)*akthom)
modules.f90:    end function ddamping_da
modules.f90:    !JH: functions and subroutines for calculating z_star and z_drag
modules.f90:    function doptdepth_dz(z)
modules.f90:    !ignoring reionisation, not relevant for distance measures
modules.f90:    doptdepth_dz = Recombination_xe(a)*akthom*dtauda(a)
modules.f90:    end function doptdepth_dz
modules.f90:    function optdepth(z)
modules.f90:    end function optdepth
modules.f90:    function ddragoptdepth_dz(z)
modules.f90:    end function ddragoptdepth_dz
modules.f90:    function dragoptdepth(z)
modules.f90:    end function dragoptdepth
modules.f90:            call GlobalError('optical depth redshift finder did not converge',error_reionization)
modules.f90~:    !     See readme.html for documentation.
modules.f90~:    !     REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.
modules.f90~:    !     By way of example, but not limitation,
modules.f90~:    !     M.I.T. AND C.f.A MAKE NO REPRESENTATIONS OR WARRANTIES OF
modules.f90~:    !     THE USE OF THE LICENSED SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE
modules.f90~:    !     portions of this software are based on the COSMICS package of
modules.f90~:    !     E. Bertschinger.  See the LICENSE file of the COSMICS distribution
modules.f90~:    !     for restrictions on the modification and distribution of this software.
modules.f90~:    use precision
modules.f90~:    use Reionization
modules.f90~:    use Recombination
modules.f90~:    character(LEN=*), parameter :: version = 'Feb15'
modules.f90~:    integer :: FeedbackLevel = 0 !if >0 print out useful information about the model
modules.f90~:    logical, parameter :: DebugEvolution = .false. !Set to true to do all the evolution for all k
modules.f90~:    logical, parameter :: hard_bispectrum = .false. ! e.g. warm inflation where delicate cancellations
modules.f90~:    logical, parameter :: full_bessel_integration = .false. !(go into the tails when calculating the sources)
modules.f90~:    !Nu_int: always integrate distribution function
modules.f90~:    !Nu_trunc: switch to expansion in velocity once non-relativistic
modules.f90~:    Type(Regions) :: TimeSteps
modules.f90~:        logical     ::  high_precision
modules.f90~:    !other variables, options, derived variables, etc.
modules.f90~:    ! _tensor settings only used in initialization,
modules.f90~:    logical   :: share_delta_neff !take fractional part to heat all eigenstates the same
modules.f90~:    real(dl)  :: Nu_mass_fractions(max_nu) !The ratios of the total densities
modules.f90~:        ! 1) Definition of flags:
modules.f90~:        ! 2) Definition of stability flags:
modules.f90~:        logical :: EFT_mathematical_stability, EFT_physical_stability, EFTAdditionalPriors, MinkowskyPriors
modules.f90~:        ! 3) Definition of model parameters:
modules.f90~:        real(dl) :: EFTGeffG !present-day ratio of effective graviational coupling to G
modules.f90~:    integer   :: Scalar_initial_condition
modules.f90~:    integer   :: OutputNormalization
modules.f90~:    !outNone, or C_OutputNormalization=1 if > 1
modules.f90~:    logical   :: AccuratePolarization
modules.f90~:    !Do you care about the accuracy of the polarization Cls?
modules.f90~:    !Reionization settings - used if Reion%Reionization=.true.
modules.f90~:    logical   :: AccurateReionization
modules.f90~:    !Do you care about pecent level accuracy on EE signal from reionization?
modules.f90~:    type(ReionizationParams) :: Reion
modules.f90~:    type(RecombinationParams):: Recomb
modules.f90~:    real(dl) ::  InitialConditionVector(1:10) !Allow up to 10 for future extensions
modules.f90~:    !ignored unless Scalar_initial_condition == initial_vector
modules.f90~:    type(ReionizationHistory) :: ReionHist
modules.f90~:    type(CAMBparams), save :: CP  !Global collection of parameters
modules.f90~:    !     taurst,taurend - time at start/end of recombination
modules.f90~:    !     dtaurec - dtau during recombination
modules.f90~:    !     adotrad - a(tau) in radiation era
modules.f90~:    !Increase lSampleBoost to increase sampling in lSamp%l for Cl interpolation
modules.f90~:    real(dl),parameter :: tol=1.0d-4 !Base tolerance for integrations
modules.f90~:    !fiducial high-accuracy high-L C_L used for making small cosmology-independent numerical corrections
modules.f90~:    !to lensing and C_L interpolation. Ideally close to models of interest, but dependence is weak.
modules.f90~:    subroutine CAMBParams_Set(P, Haux, error, DoReion)
modules.f90~:    real(dl) GetOmegak, fractional_number, conv
modules.f90~:    integer, optional :: error !Zero if OK
modules.f90~:    logical, optional :: DoReion
modules.f90~:    logical WantReion
modules.f90~:    if (present(DoReion)) then
modules.f90~:        WantReion = DoReion
modules.f90~:        WantReion = .true.
modules.f90~:            CP%AccuratePolarization = .false.
modules.f90~:            CP%Reion%Reionization = .false.
modules.f90~:            fractional_number = CP%Num_Nu_massless + CP%Num_Nu_massive
modules.f90~:            neff_i = fractional_number/(actual_massless + CP%Num_Nu_massive)
modules.f90~:        if (abs(sum(CP%Nu_mass_fractions(1:CP%Nu_mass_eigenstates))-1) > 1e-4) &
modules.f90~:        stop 'Nu_mass_fractions do not add up to 1'
modules.f90~:    !  grho gives the contribution to the expansion rate from: (g) photons,
modules.f90~:    !correction for fractional number of neutrinos, e.g. 3.04 to give slightly higher T_nu hence rhor
modules.f90~:    !  adotrad gives the relation a(tau) in the radiation era:
modules.f90~:	!MODIFIED BY NELSON (NEED TO RECOVER H0 TODAY FROM BRANS-DICKE EVOLUTION. THIS IS THE PERFECT TIME!!!
modules.f90~:            if (WantReion) call Reionization_Init(CP%Reion,CP%ReionHist, CP%YHe, akthom, CP%tau0, FeedbackLevel)
modules.f90~:    function GetTestTime()
modules.f90~:    end function GetTestTime
modules.f90~:    function rofChi(Chi) !sinh(chi) for open, sin(chi) for closed.
modules.f90~:    end function rofChi
modules.f90~:    function cosfunc (Chi)
modules.f90~:    end function cosfunc
modules.f90~:    function tanfunc(Chi)
modules.f90~:    end  function tanfunc
modules.f90~:    function invsinfunc(x)
modules.f90~:    end function invsinfunc
modules.f90~:    function f_K(x)
modules.f90~:    end function f_K
modules.f90~:    function DeltaTime(a1,a2, in_tol)
modules.f90~:    real(dl), optional, intent(in) :: in_tol
modules.f90~:    real(dl) dtauda, rombint !diff of tau w.CP%r.t a and integration
modules.f90~:    end function DeltaTime
modules.f90~:    function TimeOfz(z)
modules.f90~:    end function TimeOfz
modules.f90~:    function DeltaPhysicalTimeGyr(a1,a2, in_tol)
modules.f90~:    real(dl), optional, intent(in) :: in_tol
modules.f90~:    end function DeltaPhysicalTimeGyr
modules.f90~:    function AngularDiameterDistance(z)
modules.f90~:    end function AngularDiameterDistance
modules.f90~:    function AngularDiameterDistance2(z1, z2) ! z1 < z2
modules.f90~:    end function AngularDiameterDistance2
modules.f90~:    function LuminosityDistance(z)
modules.f90~:    end function LuminosityDistance
modules.f90~:    function ComovingRadialDistance(z)
modules.f90~:    end function ComovingRadialDistance
modules.f90~:    function Hofz(z)
modules.f90~:    end function Hofz
modules.f90~:    real(dl) function BAO_D_v_from_DA_H(z, DA, Hz)
modules.f90~:    end function BAO_D_v_from_DA_H
modules.f90~:    real(dl) function BAO_D_v(z)
modules.f90~:    end function BAO_D_v
modules.f90~:    function dsound_da_exact(a)
modules.f90~:    end function dsound_da_exact
modules.f90~:    function dsound_da(a)
modules.f90~:    end function dsound_da
modules.f90~:    function dtda(a)
modules.f90~:    end function
modules.f90~:    function CosmomcTheta()
modules.f90~:    end function CosmomcTheta
modules.f90~:    use precision
modules.f90~:    function lvalues_indexOf(lSet,l)
modules.f90~:    end function  lvalues_indexOf
modules.f90~:    if (CP%AccurateReionization) then
modules.f90~:            !Not in CP%flat case so interpolation table is the same when using lower l_max
modules.f90~:    integer, intent(in), optional :: template_index
modules.f90~:                !overlap to reduce interpolation artefacts
modules.f90~:    use precision
modules.f90~:        real(dl), dimension(:), pointer :: k
modules.f90~:        real(dl), dimension(:), pointer :: Source
modules.f90~:        !Cl transfer function variables
modules.f90~:        !values of q for integration over q to get C_ls
modules.f90~:        Type (Regions) :: q
modules.f90~:        real(dl), dimension(:,:,:), pointer :: Delta_p_l_k => NULL()
modules.f90~:        integer, dimension(:), pointer :: Limber_l_min => NULL()
modules.f90~:        Type(LimberRec), dimension(:,:), pointer :: Limber_windows => NULL()
modules.f90~:    real(dl), dimension (:,:,:), allocatable :: Cl_scalar, Cl_tensor, Cl_vector
modules.f90~:    real(dl), dimension (:,:,:,:), allocatable :: Cl_Scalar_Array
modules.f90~:    real(dl) , dimension (:,:,:), allocatable :: Cl_lensed
modules.f90~:    if (st /= 0) stop 'Init_ClTransfer: Error allocating memory for transfer functions'
modules.f90~:    real(dl), intent(in), optional :: factor
modules.f90~:    real(dl), intent(in), optional :: factor
modules.f90~:    !output file of dimensionless [l(l+1)]^2 C_phi_phi/2pi and [l(l+1)]^(3/2) C_phi_T/2pi
modules.f90~:    real(dl), intent(in), optional :: factor
modules.f90~:    use precision
modules.f90~:    !smallest a*m_nu to integrate distribution function rather than using series
modules.f90~:    real(dl), dimension(:), allocatable ::  r1,p1,dr1,dp1,ddr1, ddp1, dddp1
modules.f90~:    ! real(dl), dimension(:), allocatable ::  r1,p1,dr1,dp1,ddr1
modules.f90~:    !  Initialize interpolation tables for massive neutrinos.
modules.f90~:    !  Use cubic splines interpolation of log rhonu and pnu vs. log a*m.
modules.f90~:        nu_masses(i)=const/(1.5d0*zeta3)*grhom/grhor*CP%omegan*CP%Nu_mass_fractions(i) &
modules.f90~:    !Integration scheme gets (Fermi-Dirac thing)*q^n exact,for n=-4, -2..2
modules.f90~:    !  Integrate up to qmax and then use asymptotic expansion for remainder.
modules.f90~:    !  Apply asymptotic corrrection for q>qmax and normalize by relativistic
modules.f90~:    use precision
modules.f90~:    !  Cubic spline interpolation.
modules.f90~:    use precision
modules.f90~:    !  Cubic spline interpolation.
modules.f90~:    function Nu_drho(am,adotoa,rhonu) result (rhonudot)
modules.f90~:    use precision
modules.f90~:    !  and the shear perturbation.
modules.f90~:        !  Cubic spline interpolation for rhonudot.
modules.f90~:    end function Nu_drho
modules.f90~:    function Nu_pidot(am,adotoa,presnu) result (presnudot)
modules.f90~:        use precision
modules.f90~:    end function Nu_pidot
modules.f90~:    function Nu_pidotdot(am,adotoa,Hdot,presnu,presnudot) result (presnudotdot)
modules.f90~:        use precision
modules.f90~:    end function Nu_pidotdot
modules.f90~:    ! wrapper function to avoid cirular module references
modules.f90~:        ! total perturbations with and without neutrinos, with neutrinos+dark energy in the numerator
modules.f90~:    !set to false to output calculated values for later interpolation
modules.f90~:    !Transfer_tot uses total matter perturbation
modules.f90~:        integer   ::  num_q_trans   !    number of steps in k for transfer calculation
modules.f90~:        real(dl), dimension (:), pointer :: q_trans => NULL()
modules.f90~:        real(dl), dimension (:,:), pointer ::  sigma_8 => NULL()
modules.f90~:        real(dl), dimension (:,:), pointer ::  sigma2_vdelta_8 => NULL() !growth from sigma_{v delta}
modules.f90~:        real, dimension(:,:,:), pointer :: TransferData => NULL()
modules.f90~:        !everything is a function of k/h
modules.f90~:        real(dl), dimension(:), pointer :: log_kh => NULL(), redshifts => NULL()
modules.f90~:        real(dl), dimension(:,:), allocatable :: matpower, ddmat
modules.f90~:        !function of k and redshift NonLinearScaling(k_index,z_index)
modules.f90~:        real(dl), dimension(:,:), pointer :: nonlin_ratio => NULL()
modules.f90~:    integer, optional, intent(in) :: var1
modules.f90~:    integer, optional, intent(in) :: var2
modules.f90~:    logical, optional, intent(in) :: hubble_units
modules.f90~:    !Does *NOT* include non-linear corrections
modules.f90~:    !Get total matter power spectrum in units of (h Mpc^{-1})^3 ready for interpolation.
modules.f90~:    !Here there definition is < Delta^2(x) > = 1/(2 pi)^3 int d^3k P_k(k)
modules.f90~:    integer, intent(in), optional :: power_ix
modules.f90~:    integer, intent(in), optional :: itf_only
modules.f90~:    integer, intent(in), optional :: var1, var2
modules.f90~:    !Get total matter power spectrum in units of (h Mpc^{-1})^3 ready for interpolation.
modules.f90~:    !Here there definition is < Delta^2(x) > = 1/(2 pi)^3 int d^3k P_k(k)
modules.f90~:    function MatterPowerData_k(PK,  kh, itf) result(outpower)
modules.f90~:    !Get matter power spectrum at particular k/h by interpolation
modules.f90~:        !Do dodgy linear extrapolation on assumption accuracy of result won't matter
modules.f90~:    end function MatterPowerData_k
modules.f90~:    integer, intent(in), optional :: var1, var2
modules.f90~:    !redshift in the PK_redshifts array.  The position of this redshift in the master redshift
modules.f90~:    !if CP%Nonlinear/ = NonLinear_none includes non-linear evolution
modules.f90~:    !Here there definition is < Delta^2(x) > = 1/(2 pi)^3 int d^3k P_k(k)
modules.f90~:    integer, intent(in), optional :: var1, var2
modules.f90~:    !            stop 'Transfer_GetMatterPower: kh out of computed region'
modules.f90~:        !Put in power spectrum later: transfer functions should be smooth, initial power may not be
modules.f90~:        !Do linear extrapolation in the log
modules.f90~:        !Obviouly inaccurate, non-linear etc, but OK if only using in tails of window functions
modules.f90~:    !set va1, var2 e.g. to get the value from some combination of transfer functions rather than total
modules.f90~:    integer, intent(in), optional :: var1, var2
modules.f90~:    integer, intent(in), optional :: power_ix
modules.f90~:    logical, intent(in), optional :: root !if true, give sigma8, otherwise sigma8^2
modules.f90~:    real(dl), dimension(CP%Transfer%PK_num_redshifts) ::  dsig8, dsig8o, sig8, sig8o
modules.f90~:            !Contribution should be very small in any case
modules.f90~:    integer, intent(in), optional :: redshift_ix, var1, var2, power_ix
modules.f90~:    real(dl), dimension(size(R)) ::  x, win, dsig8, dsig8o, sig8, sig8o
modules.f90~:                !Contribution should be very small in any case
modules.f90~:    ! set va1, var2 e.g. to get the value from some combination of transfer functions rather than total
modules.f90~:    real(dl), intent(in), optional :: R
modules.f90~:    integer, intent(in), optional :: var1, var2
modules.f90~:    real(dl), intent(in), optional :: R
modules.f90~:    integer, intent(in), optional :: var_delta,var_v
modules.f90~:    !Changed function below to write to only P%NLL_*redshifts* variables
modules.f90~:        !only notionally more accuracy, more stable for RS
modules.f90~:    real, dimension(:,:,:), allocatable :: outpower
modules.f90~:    !JD 08/13 New function for nonlinear lensing of CMB + MPK compatibility
modules.f90~:    real(dl), dimension(:), allocatable :: vis,dvis,ddvis,expmmu,dopac, opac, lenswin
modules.f90~:    !Times when 1/(opacity*tau) = 0.01, for use switching tight coupling approximation
modules.f90~:    !and ionization fraction by interpolating pre-computed tables.
modules.f90~:    real(dl), intent(out), optional :: dopacity
modules.f90~:        !Linear interpolation if out of bounds (should not occur).
modules.f90~:        !Cubic spline interpolation.
modules.f90~:    function Thermo_OpacityToTime(opacity)
modules.f90~:    end function Thermo_OpacityToTime
modules.f90~:    !  Compute and save unperturbed baryon temperature and ionization fraction
modules.f90~:    !  as a function of time.  With nthermo=10000, xe(tau) has a relative
modules.f90~:    ! accuracy (numerical integration precision) better than 1.e-5.
modules.f90~:    use precision
modules.f90~:    real(dl) dtauda  !diff of tau w.CP%r.t a and integration
modules.f90~:    call Recombination_Init(CP%Recomb, CP%omegac/(CP%H0/100.0)**2.0, CP%omegab/(CP%H0/100.0)**2.0,CP%Omegan/(CP%H0/100.0)**2.0, &
modules.f90~:    call Recombination_Init(CP%Recomb, CP%omegac, CP%omegab,CP%Omegan, CP%Omegav, &
modules.f90~:    !  Initial conditions: assume radiation-dominated universe.
modules.f90~:    !  Assume that any entropy generation occurs before tauminn.
modules.f90~:    !  This gives wrong temperature before pair annihilation, but
modules.f90~:        !  Integrate Friedmann equation using inverse trapezoidal rule.
modules.f90~:        !  Baryon temperature evolution: adiabatic except for Thomson cooling.
modules.f90~:        !  Use  quadrature solution.
modules.f90~:        ! This is redundant as also calculated in REFCAST, but agrees well before reionization
modules.f90~:        !  the solution of the ionization equation.
modules.f90~:        ! If there is re-ionization, smoothly increase xe to the
modules.f90~:        if (CP%Reion%Reionization .and. tau > CP%ReionHist%tau_start) then
modules.f90~:            xe(i) = Reionization_xe(a, tau, xe(ncount))
modules.f90~:            if (CP%AccurateReionization .and. CP%DerivedParameters) then
modules.f90~:                dotmu(i)=(Recombination_xe(a) - xe(i))*akthom/a2
modules.f90~:            xe(i)=Recombination_xe(a)
modules.f90~:        ! Calculation of the visibility function
modules.f90~:    if (CP%Reion%Reionization .and. (xe(nthermo) < 0.999d0)) then
modules.f90~:        write(*,*) 'Check input parameters an Reionization_xe'
modules.f90~:        write(*,*) 'function in the Reionization module'
modules.f90~:            if (.not. CP%AccurateReionization .and. &
modules.f90~:            if (CP%AccurateReionization .and. CP%DerivedParameters .and. z_star==0.d0) then
modules.f90~:    if (CP%AccurateReionization .and. FeedbackLevel > 0 .and. CP%DerivedParameters) then
modules.f90~:        write(*,'("Reion opt depth      = ",f7.4)') actual_opt_depth
modules.f90~:        call GlobalError('inithermo: failed to find end of recombination',error_reionization)
modules.f90~:    ! Calculating the timesteps during recombination.
modules.f90~:    if (CP%Reion%Reionization) taurend=min(taurend,CP%ReionHist%tau_start)
modules.f90~:    ! Calculating the timesteps after recombination
modules.f90~:    if (CP%Reion%Reionization) then
modules.f90~:        nri0=int(Reionization_timesteps(CP%ReionHist)*AccuracyBoost)
modules.f90~:        !Steps while reionization going from zero to maximum
modules.f90~:        call Ranges_Add(TimeSteps,CP%ReionHist%tau_start,CP%ReionHist%tau_complete,nri0)
modules.f90~:    !Create arrays out of the region information.
modules.f90~:    !     Cubic-spline interpolation.
modules.f90~:    function ddamping_da(a)
modules.f90~:    !ignoring reionisation, not relevant for distance measures
modules.f90~:    ddamping_da = (R**2 + 16*(1+R)/15)/(1+R)**2*dtauda(a)*a**2/(Recombination_xe(a)*akthom)
modules.f90~:    end function ddamping_da
modules.f90~:    !JH: functions and subroutines for calculating z_star and z_drag
modules.f90~:    function doptdepth_dz(z)
modules.f90~:    !ignoring reionisation, not relevant for distance measures
modules.f90~:    doptdepth_dz = Recombination_xe(a)*akthom*dtauda(a)
modules.f90~:    end function doptdepth_dz
modules.f90~:    function optdepth(z)
modules.f90~:    end function optdepth
modules.f90~:    function ddragoptdepth_dz(z)
modules.f90~:    end function ddragoptdepth_dz
modules.f90~:    function dragoptdepth(z)
modules.f90~:    end function dragoptdepth
modules.f90~:            call GlobalError('optical depth redshift finder did not converge',error_reionization)
params_EFT.ini:####### Model selection flags for EFTCAMB #######
params_EFT.ini:# 	 We refer to the documentation (EFTCAMB:numerical notes) for a thorough 
params_EFT.ini:# 	 explanation of the effect of these flags.
params_EFT.ini:#      EFTflag = 0 : GR code. Every EFT modification is ignored.
params_EFT.ini:#      EFTflag = 3 : EFT alternative parametrizations.
params_EFT.ini:# 2) Pure EFT model selection flag.
params_EFT.ini:# 3) Designer mapping EFT model selection flag. Relevant if EFTflag = 2.
params_EFT.ini:# 4) EFT alternative parametrizations model selection flag. Relevant if EFTflag = 3.
params_EFT.ini:# 5) Full mapping EFT model selection flag. Relevant if EFTflag = 4.
params_EFT.ini:####### Stability conditions flags   #######
params_EFT.ini:# 1) enforces the mathematical stability of the scalar field equation.
params_EFT.ini:# 3) Additional priors on cosmological parameters. For more informations read the related section in the notes.
params_EFT.ini:EFTAdditionalPriors        = T
params_EFT.ini:# 1) Background Dark Energy equation of state flag:
params_EFT.ini:#      EFTwDE = 2 : CPL parametrization
params_EFT.ini:#      EFTwDE = 3 : JBP parametrization
params_EFT.ini:#      EFTwDE = 4 : turning point parametrization
params_EFT.ini:#      EFTwDE = 5 : Taylor expansion
params_EFT.ini:# 3) RPH model selection: select a model for the RPH functions. Relevant if EFTflag = 3 and AltParEFTmodel = 1.
params_EFT.ini:#      RPH___model = 0 : Zero (function ignored)	
params_EFT.ini:#	Notice that if the model is not selected via the model selection flags then
params_EFT.ini:#  1) Background Dark Energy equation of state parameters:
params_EFT.ini:# 3 thereafter : Other user-defined potentials. Initial conditions may have to be modified in EFT_designer.f90 
params_EFT.ini:#  4) EFT alternative parametrizations parameters:
params_EFT.ini~:####### Model selection flags for EFTCAMB #######
params_EFT.ini~:# 	 We refer to the documentation (EFTCAMB:numerical notes) for a thorough 
params_EFT.ini~:# 	 explanation of the effect of these flags.
params_EFT.ini~:#      EFTflag = 0 : GR code. Every EFT modification is ignored.
params_EFT.ini~:#      EFTflag = 3 : EFT alternative parametrizations.
params_EFT.ini~:# 2) Pure EFT model selection flag.
params_EFT.ini~:# 3) Designer mapping EFT model selection flag. Relevant if EFTflag = 2.
params_EFT.ini~:# 4) EFT alternative parametrizations model selection flag. Relevant if EFTflag = 3.
params_EFT.ini~:# 5) Full mapping EFT model selection flag. Relevant if EFTflag = 4.
params_EFT.ini~:####### Stability conditions flags   #######
params_EFT.ini~:# 1) enforces the mathematical stability of the scalar field equation.
params_EFT.ini~:# 3) Additional priors on cosmological parameters. For more informations read the related section in the notes.
params_EFT.ini~:EFTAdditionalPriors        = T
params_EFT.ini~:# 1) Background Dark Energy equation of state flag:
params_EFT.ini~:#      EFTwDE = 2 : CPL parametrization
params_EFT.ini~:#      EFTwDE = 3 : JBP parametrization
params_EFT.ini~:#      EFTwDE = 4 : turning point parametrization
params_EFT.ini~:#      EFTwDE = 5 : Taylor expansion
params_EFT.ini~:# 3) RPH model selection: select a model for the RPH functions. Relevant if EFTflag = 3 and AltParEFTmodel = 1.
params_EFT.ini~:#      RPH___model = 0 : Zero (function ignored)	
params_EFT.ini~:#	Notice that if the model is not selected via the model selection flags then
params_EFT.ini~:#  1) Background Dark Energy equation of state parameters:
params_EFT.ini~:# 3 thereafter : Other user-defined potentials. Initial conditions may have to be modified in EFT_designer.f90 
params_EFT.ini~:#  4) EFT alternative parametrizations parameters:
params.ini:####### Model selection flags and parameters for EFTCAMB #######
params.ini:#if do_lensing then scalar_output_file contains additional columns of l^4 C_l^{pp} and l^3 C_l^{pT}
params.ini:#effective equation of state parameter for dark energy
params.ini:#varying w is not supported by default, compile with EQUATIONS=equations_ppf to use crossing PPF w-wa model:
params.ini:helium_fraction    = 0.24271
params.ini:#for share_delta_neff = T, the fractional part of massless_neutrinos gives the change in the effective number 
params.ini:#specify whether all neutrinos should have the same temperature, specified from fractional part of massless_neutrinos
params.ini:#nu_mass_fractions specifies how Omeganu_h2 is shared between the eigenstates
params.ini:#i.e. to indirectly specify the mass of each state; e.g. nu_mass_factions= 0.75 0.25
params.ini:nu_mass_fractions = 1
params.ini:#Three parameterizations (1,2,3) for tensors, see http://cosmologist.info/notes/CAMB.pdf
params.ini:tensor_parameterization   = 1
params.ini:#ratio is that of the initial tens/scal power spectrum amplitudes, depending on parameterization
params.ini:#for tensor_parameterization == 1, P_T = initial_ratio*scalar_amp*(k/pivot_tensor)^tensor_spectral_index
params.ini:#for tensor_parameterization == 2, P_T = initial_ratio*P_s(pivot_tensor)*(k/pivot_tensor)^tensor_spectral_index
params.ini:#Note that for general pivot scales and indices, tensor_parameterization==2 as P_T depending on n_s
params.ini:#tensor_amp is used instead if tensor_parameterization == 3, P_T = tensor_amp *(k/pivot_tensor)^tensor_spectral_index
params.ini:#Reionization, ignored unless reionization = T, re_redshift measures where x_e=0.5
params.ini:reionization         = T
params.ini:#width of reionization transition. CMBFAST model was similar to re_delta_redshift~0.5.
params.ini:#re_ionization_frac=-1 sets to become fully ionized using YE to get helium contribution
params.ini:#Otherwise x_e varies from 0 to re_ionization_frac
params.ini:re_ionization_frac   = -1
params.ini:#RECFAST 1.5.x recombination parameters;
params.ini:# CosmoMC parameters - compile with RECOMBINATION=cosmorec and link to CosmoMC to use these
params.ini:# cosmorec_runmode== 0: CosmoMC run with diffusion
params.ini:#                    1: CosmoMC run without diffusion
params.ini:#                    2: RECFAST++ run (equivalent of the original RECFAST version)
params.ini:#                    3: RECFAST++ run with correction function of Calumba & Thomas, 2010
params.ini:# For 'cosmorec_accuracy' and 'cosmorec_fdm' see CosmoMC for explanation
params.ini:#Initial scalar perturbation mode (adiabatic=1, CDM iso=2, Baryon iso=3, 
params.ini:initial_condition   = 1
params.ini:#If above is zero, use modes in the following (totally correlated) proportions
params.ini:#Normalization
params.ini:#otherwise for dimensionless transfer functions set scalar_amp(1)=1 and use
params.ini:#Transfer function settings, transfer_kmax=0.5 is enough for sigma_8
params.ini:# use transfer_interp_matterpower =F to output calculated values (e.g. for later interpolation)
params.ini:transfer_high_precision = F
params.ini:#bispectrum_do_fisher estimates errors and correlations between bispectra
params.ini:##Optional parameters to control the computation speed,accuracy and feedback
params.ini:#If feedback_level > 0 print out useful information computed about the model
params.ini:# 1: curved correlation function, 2: flat correlation function, 3: inaccurate harmonic method
params.ini:#massive_nu_approx: 0 - integrate distribution function
params.ini:#Whether you are bothered about polarization. 
params.ini:accurate_polarization   = T
params.ini:#Whether you are bothered about percent accuracy on EE from reionization
params.ini:accurate_reionization   = T
params.ini:#whether or not to include neutrinos in the tensor evolution equations
params.ini:#Whether to turn off small-scale late time radiation hierarchies (save time,v. accurate)
params.ini:do_late_rad_truncation   = T
params.ini:#Which version of Halofit approximation to use (default currently Takahashi):
params.ini:halofit_version= 
params.ini:#Computation parameters
params.ini:#Larger to keep more terms in the hierarchy evolution. 
params.ini:#Increase to use more C_l values for interpolation.
params.ini:#Increasing a bit will improve the polarization accuracy at l up to 200 -
params.ini:#interpolation errors may be up to 3%
params.ini~:####### Model selection flags and parameters for EFTCAMB #######
params.ini~:#if do_lensing then scalar_output_file contains additional columns of l^4 C_l^{pp} and l^3 C_l^{pT}
params.ini~:#effective equation of state parameter for dark energy
params.ini~:#varying w is not supported by default, compile with EQUATIONS=equations_ppf to use crossing PPF w-wa model:
params.ini~:helium_fraction    = 0.24271
params.ini~:#for share_delta_neff = T, the fractional part of massless_neutrinos gives the change in the effective number 
params.ini~:#specify whether all neutrinos should have the same temperature, specified from fractional part of massless_neutrinos
params.ini~:#nu_mass_fractions specifies how Omeganu_h2 is shared between the eigenstates
params.ini~:#i.e. to indirectly specify the mass of each state; e.g. nu_mass_factions= 0.75 0.25
params.ini~:nu_mass_fractions = 1
params.ini~:#Three parameterizations (1,2,3) for tensors, see http://cosmologist.info/notes/CAMB.pdf
params.ini~:tensor_parameterization   = 1
params.ini~:#ratio is that of the initial tens/scal power spectrum amplitudes, depending on parameterization
params.ini~:#for tensor_parameterization == 1, P_T = initial_ratio*scalar_amp*(k/pivot_tensor)^tensor_spectral_index
params.ini~:#for tensor_parameterization == 2, P_T = initial_ratio*P_s(pivot_tensor)*(k/pivot_tensor)^tensor_spectral_index
params.ini~:#Note that for general pivot scales and indices, tensor_parameterization==2 as P_T depending on n_s
params.ini~:#tensor_amp is used instead if tensor_parameterization == 3, P_T = tensor_amp *(k/pivot_tensor)^tensor_spectral_index
params.ini~:#Reionization, ignored unless reionization = T, re_redshift measures where x_e=0.5
params.ini~:reionization         = T
params.ini~:#width of reionization transition. CMBFAST model was similar to re_delta_redshift~0.5.
params.ini~:#re_ionization_frac=-1 sets to become fully ionized using YE to get helium contribution
params.ini~:#Otherwise x_e varies from 0 to re_ionization_frac
params.ini~:re_ionization_frac   = -1
params.ini~:#RECFAST 1.5.x recombination parameters;
params.ini~:# CosmoMC parameters - compile with RECOMBINATION=cosmorec and link to CosmoMC to use these
params.ini~:# cosmorec_runmode== 0: CosmoMC run with diffusion
params.ini~:#                    1: CosmoMC run without diffusion
params.ini~:#                    2: RECFAST++ run (equivalent of the original RECFAST version)
params.ini~:#                    3: RECFAST++ run with correction function of Calumba & Thomas, 2010
params.ini~:# For 'cosmorec_accuracy' and 'cosmorec_fdm' see CosmoMC for explanation
params.ini~:#Initial scalar perturbation mode (adiabatic=1, CDM iso=2, Baryon iso=3, 
params.ini~:initial_condition   = 1
params.ini~:#If above is zero, use modes in the following (totally correlated) proportions
params.ini~:#Normalization
params.ini~:#otherwise for dimensionless transfer functions set scalar_amp(1)=1 and use
params.ini~:#Transfer function settings, transfer_kmax=0.5 is enough for sigma_8
params.ini~:# use transfer_interp_matterpower =F to output calculated values (e.g. for later interpolation)
params.ini~:transfer_high_precision = F
params.ini~:#bispectrum_do_fisher estimates errors and correlations between bispectra
params.ini~:##Optional parameters to control the computation speed,accuracy and feedback
params.ini~:#If feedback_level > 0 print out useful information computed about the model
params.ini~:# 1: curved correlation function, 2: flat correlation function, 3: inaccurate harmonic method
params.ini~:#massive_nu_approx: 0 - integrate distribution function
params.ini~:#Whether you are bothered about polarization. 
params.ini~:accurate_polarization   = T
params.ini~:#Whether you are bothered about percent accuracy on EE from reionization
params.ini~:accurate_reionization   = T
params.ini~:#whether or not to include neutrinos in the tensor evolution equations
params.ini~:#Whether to turn off small-scale late time radiation hierarchies (save time,v. accurate)
params.ini~:do_late_rad_truncation   = T
params.ini~:#Which version of Halofit approximation to use (default currently Takahashi):
params.ini~:halofit_version= 
params.ini~:#Computation parameters
params.ini~:#Larger to keep more terms in the hierarchy evolution. 
params.ini~:#Increase to use more C_l values for interpolation.
params.ini~:#Increasing a bit will improve the polarization accuracy at l up to 200 -
params.ini~:#interpolation errors may be up to 3%
plotcls.m:function plotcls(varargin)
plotcls.m:function seth(h)
plotcls.m:function setaxes(a,b,c,d)
plotdiffs.m:%use plotdiffs('scalCls.dat','scalCls2.dat','scalCls3.dat') to plot fractional differences
plotdiffs.m:function plotdiffs(varargin)
plotpk.m:function plotpk(varargin);
plotTT.m:function plotTT(varargin)
plotTT.m:function seth(h)
plotTT.m:function setaxes(a,b,c,d)
power_tilt.f90:    !This module provides the initial power spectra, parameterized as an expansion in ln k
power_tilt.f90:    !The tensor spectrum has three different supported parameterizations giving
power_tilt.f90:    ! tensor_parameterization==tensor_param_indeptilt (=1) (default, same as CAMB pre-April 2014)
power_tilt.f90:    ! tensor_parameterization==tensor_param_rpivot (=2)
power_tilt.f90:    ! tensor_parameterization==tensor_param_AT (=3)
power_tilt.f90:    !The absolute normalization of the Cls is unimportant here, but the relative ratio
power_tilt.f90:    !April 2014 added different tensor parameterizations, running of running and running of tensors
power_tilt.f90:    use Precision
power_tilt.f90:        integer :: tensor_parameterization = tensor_param_indeptilt
power_tilt.f90:        !For the default implementation return power spectra based on spectral indices
power_tilt.f90:        real(dl) TensorPowerAmp(nnmax) !A_T at k_0_tensor if tensor_parameterization==tensor_param_AT
power_tilt.f90:    AP%tensor_parameterization = tensor_param_indeptilt
power_tilt.f90:    !Write implementation specific code here...
power_tilt.f90:    function ScalarPower(k,ix)
power_tilt.f90:    !The normalization is defined so that for adiabatic perturbations the gradient of the 3-Ricci
power_tilt.f90:    !In other words ScalarPower is the power spectrum of the conserved curvature perturbation given by
power_tilt.f90:    !Near the end of inflation chi is equal to 3/2 Psi.
power_tilt.f90:    end function ScalarPower
power_tilt.f90:    function TensorPower(k,ix)
power_tilt.f90:    !The normalization is defined so that
power_tilt.f90:    if (P%tensor_parameterization==tensor_param_indeptilt) then
power_tilt.f90:    else if (P%tensor_parameterization==tensor_param_rpivot) then
power_tilt.f90:    else if (P%tensor_parameterization==tensor_param_AT) then
power_tilt.f90:    end function TensorPower
power_tilt.f90:    !Get parameters describing parameterisation (for FITS file)
power_tilt.f90:    !Does not support running extensions
power_tilt.f90:    function Power_Descript(in, Scal, Tens, Keys, Vals)
power_tilt.f90:    end  function Power_Descript
power_tilt.f90:        InitPower%tensor_parameterization =  Ini_Read_Int_File(Ini, 'tensor_parameterization',tensor_param_indeptilt)
power_tilt.f90:        if (InitPower%tensor_parameterization < tensor_param_indeptilt .or. &
power_tilt.f90:        & InitPower%tensor_parameterization > tensor_param_AT) &
power_tilt.f90:        & stop 'InitialPower: unknown tensor_parameterization'
power_tilt.f90:            if (InitPower%tensor_parameterization == tensor_param_AT) then
python/cambPlots.py:            arr[:, 1 + 2 + i * n] *= sqrt(self.l * (self.l + 1))  # deflection angle rather than lensing potential
python/cambPlots.py:            arr[:, 1 + i + n * 2] *= sqrt(self.l * (self.l + 1))  # deflection angle rather than lensing potential
python/cambPlots.py:    if not isinstance(result, ClResult): raise Exception('expecting a ClResult object, numpy array or string for filename')
python/cambPlots.py:def plot_compare(clResults, colors=def_colors, ncl=1, x='sqrt', x_lens='log', y=None, y_lens='log', compare=None, diff_fraction=True, **args):
python/cambPlots.py:                        if diff_fraction: diff /= cl_base.cls[:nmax, icl]
python/cambPlots.py:                        if diff_fraction: diff /= sqrt(cl_base.TT[:nmax] * cl_base.EE[:nmax])
python/CLCompare.py:# see camPlots.py for function declaration
python/covCompare.py:# sample script to compare two different sets of cross-correlation spectra from scalar_covariance_output_file output
python/covCompare.py:# Fractional difference between two outputs
python/covCompare.py:# Fractional difference between two outputs, restricted to correlations between sources 4 and 5 (CAMB sources, first two window functions)
python/iniFile.py:                        raise Exception('Error: duplicate key: ' + key)
python/iniFile.py:        raise Exception('parameter not defined: ' + name)
python/iniFile.py:            raise Exception('parameter does not have valid T or F boolean value: ' + name)
readme.html:<A HREF="#compiling">Compiling</A> | <A HREF="#inputs">Inputs</A> | <A HREF="#outputs">Outputs</A>| <A HREF="#coding">Customization</A> | <A HREF="#version">History</A> | <A HREF="#COMPARE">Comparison</A> | <A HREF="#FILES">Source files</A> | <A HREF="#ACCURACY">Accuracy</A> |
readme.html:This version February 2015.
readme.html:For latest information on this program see <A HREF="http://camb.info">camb.info</A>.
readme.html:CAMB is also supplied as part of the <A HREF="http://cosmologist.info/cosmomc/">CosmoMC</A> parameter estimation package. For an extension including perturbed recombination, 21cm, lensing and number count sources see <A HREF="http://camb.info/sources">CAMB sources</A>.
readme.html:The Makefile comes set up for Intel machines using Intel's ifort compiler. Just comment the relevant parts to compile on different systems. If you have Intel's Visual Fortran you can use the projects in the VisualStudio folder, no need to use the Makefile. To run on multi-processor machines add the -openmp (or equivalent) option to the Makefile's FFLAGS parameter to compile a parallelized (OPENMP) version.
readme.html:Martina Schwind has kindly contributed some <A hREF="Work_with_CAMB_V13_for_AL.pdf">introductory slides</A> with details of program running and internal structure. For some further technical details about the algorithms, equations and code see the <A HREF="http://cosmologist.info/notes/CAMB.pdf">CAMB notes</A>.
readme.html:see the documentation and examples in the <A HREF="http://cosmologist.info/notes/CAMB.pdf">CAMB notes</A>. To produce the matter power spectrum in addition to CMB C<sub>l</sub> set <b>get_transfer = T</b>; the <b>do_nonlinear</b> input parameter determines whether this is output as the linear power spectrum or includes non-linear corrections from the Halofit model.
readme.html:The default params.ini file produces results in &mu;K<sup>2</sup> from the given primordial curvature perturbation power (<B>scalar_amp</B>) on 0.05 MPc<sup>-1</sup> scales. To get unnormalized dimensionless results set <B>scalar_amp(1)=1</B> and <B>CMB_outputscale=1</B>. To compute lensed C<sub>l</sub>s you must set the normalization to some realistic value (the calculation is non-linear, so normalization matters).
readme.html:Here all C<sub>X</sub> are l(l+1)C_l/2pi except for C<sub>&Phi;</sub> and C<sub>&Phi;T</sub> which are C<sub>&Phi;</sub>= l<sup>4</sup> C<sub>l</sub><sup>&Phi;</sup>, where  C<sub>l</sub><sup>&Phi;</sup> is the (CMB) lensing potential power spectrum, and C<sub>&Phi;T</sub> = l<sup>3</sup> C<sub>l</sub><sup>&Phi;T</sup>. The lensing terms in square brackets are only produced if <b>do_lensing = T</b>. If <b>CMB_outputscale = 7.4311e12</B> ([T<sub>CMB</sub>10<sup>6</sup>]<sup>2</sup>, the default), the units are &mu;K<sup>2</sup>. Note that lensing spectra are also multiplied by CMB_outputscale, so you may want to divide this out of the answer to get a sensible dimensionless spectrum or use the <b>lens_potential_output_file</b> file mentioned below. If requested the lensed power spectrum is output to <b>output_root</b>_lensedCls.dat
readme.html:where as before C<sub>X</sub> are l(l+1)C<sub>l</sub>/2&pi;, and d is the deflection angle, so C<sub>dd</sub>=[l(l+1)]<sup>2</sup>C<sub>l</sub><sup>&Phi;</sup>/2&pi;,  C<sub>dT</sub>=[l(l+1)]<sup>3/2</sup>C<sub>l</sub><sup>&Phi;T</sup>/2&pi;,
readme.html:If transfer functions are requested the columns in the <b>output_root</b>_transfer.dat output file are:
readme.html:where Delta_X is defined as (delta rho_X)/rho_X  in the synchronous gauge and evaluated at the requested redshift, given a unit primordial curvature perturbation on superhorizon scales (for adiabatic modes, chi_0=-1).
readme.html:<b>output_root</b>_matterpower.dat contains the conventionally normalized matter power spectrum (for baryons+cdm+massive neutrinos), in h/Mpc units.
readme.html:<H3>Compilation options and code modifications</H3>
readme.html:You can edit the Makefile's EQUATIONS, POWERSPECTRUM, RECOMBINATION and REIONIZATION
readme.html: variables , which determine which module is used to implement and model various parts of the calculation. The POWERSPECTRUM.f90  file7 contains a module giving the initial
readme.html: power spectrum, the EQUATIONS.f90 file contains the background evolution
readme.html: equations and sets of gauge-dependent perturbation
readme.html: equations (the alternative equations_ppf.f90 is provided to implement the common <i>w</i>, <i>w<sub>a</sub></i> varying dark energy parameterization). RECOMBINATION.f90 gives the background recombination history: recfast by default, but you can also compile to use <A HREF="http://www.cita.utoronto.ca/~jchluba/Science_Jens/Recombination/CosmoRec.html">CosmoRec</A> and <A HREF="http://www.sns.ias.edu/~yacine/hyrec/hyrec.html">HyRec</A>. REIONIZATION is by default a simple relatively fast single-step reionization model (following <A HREF="http://arxiv.org/abs/0804.3865">arXiv:0804.3865</A>).
readme.html: Makefile before recompiling. You can also use e.g. <B>make RECOMBINATION=cosmorec</b> to override the default and compile with a different module.
readme.html: produced is given the name specified in params.ini. Note that the FITS file format for polarization changed with HEALPIX 1.2, CAMB uses the new format.
readme.html:All the equations that need to be modified for
readme.html:simple non-standard models are in the equations.f90 file.  It should be possible to produce other files
readme.html:constant - e.g. alpha -  models are not quite so simple to plug in; a sample equations_ppf.f90 file provided to implement a varying <i>w</i> dark energy equation of state in the <A HREF="http://arxiv.org/abs/0808.3125">PPF</A> model).
readme.html:You can <A HREF="http://camb.info/test_suite.tar.gz">download</A> a test suite for comparing accuracy with different parameters and code versions. Just extract the file to your CAMB directory and read the readme.
readme.html:<A NAME="version">
readme.html:<H3>Version history</H3>
readme.html:<LI>Transfer function output now includes more variables, including different total densities and velocities (see <A HREF="#transfer">list</A>)
readme.html:<LI>Generalized matter power and sigma8 functions; output of "growth" (from CDM velocity correlation sigma8_vd^2/sigma8)
readme.html:<LI>Output of additional derived parameters (k<sub>eq</sub>, D<sub>A</sub>, &theta;<sub>s,eq</sub> - the angular scale of the sound horizon at matter-radiation equality)
readme.html:<LI>Add <b>halofit_version</b> (=1,2,3,4) to set halofit version (see params.ini)
readme.html:<LI>Add AngularDiameterDistance2 utility function
readme.html:<LI>Added two alternative tensor power spectrum parameterizations (see <A HREF="http://cosmologist.info/notes/CAMB.pdf">CAMB notes</A> section on initial power spectra), allowing easy specification of r or tensor amplitude with different scalar/tensor pivot scales
readme.html:<LI>Added optional parameters <b>scalar_nrunrun</b> (for running of running of scalar power), and <b>tensor_nrun</b> for running of tensors
readme.html:<LI>Start lensing potential integration at tau_maxvis (gets T-phi slightly closer to result from using visibility, very small change to anything else) and added negligible anisotropic stress correction for consistency in extended models.
readme.html:<LI>Minor fix so to set NLL_num_redshifts=0 by default so transfer functions don't have to always be integrated down to z=0
readme.html:<LI>CAMB_GetCls function in camb.f90 now returns total lensed C<sub>l</sub> if DoLensing is true (rather than always unlensed)
readme.html:<LI>Fix to equations_ppf for w/=-1 models; corrected source output fixes C<sub>L</sub> error at very low L (<2% for w&gt;-0.8, more for w&lt;-0.8). (thanks David Rapetti and Matteo Cataneo)
readme.html:<LI>Modified more general neutrino mass input specification: <B>share_delta_neff</B> and <B>massive_neutrinos</b> now integer array. See section the <A HREF="http://cosmologist.info/notes/CAMB.pdf">CAMB notes</A> for detailed documentation and examples.
readme.html:<LI>Replaced numerical recipes functions with internal fortran or new versions (thanks Martin Reinecke)
readme.html:<LI>Improved speed and accuracy of lensed CMB calculation at L>5000 (tweaks to correlation function apodization, etc.)
readme.html:<LI>More accurate Limber approximation for lensing potential (<A HREF="http://arxiv.org/abs/0809.5112">arXiv:0809.5112</A>); result much more stable around Limber switch scale
readme.html:<LI>Fix numerical accuracy for larger neutrino masses and bug in and non-linear lensing calculation in very closed models
readme.html:<LI>Fixed bug calculating zstar with Feedback=0 and accurate_reionization (gave wrong results)
readme.html:<LI>Utility functions Hofz, DeltaPhysicalTimeGyr, and dsound_da_exact for getting H(z), age and the accurate sound speed
readme.html:<LI>Updated Recfast to 1.5.2 (~0.15% change in C<sub>l</sub> from small tweaks to fudge parameters to match <A HREF="http://www.cita.utoronto.ca/~jchluba/Science_Jens/Recombination/CosmoRec.html">CosmoRec</A> and <A HREF="http://www.sns.ias.edu/~yacine/hyrec/hyrec.html">HyRec</A>)
readme.html:<LI>Calculation of various potentially useful derived parameters (if <b>derived_parameters=T</b>)
readme.html:<LI>Typo in approximation result in equations.f90 corrected (thanks Alex Hall; no effect on numerics)
readme.html:<LI>Support for compiling with and linking to <A HREF="http://www.cita.utoronto.ca/~jchluba/Science_Jens/Recombination/CosmoRec.html">CosmoRec</A> for recombination model (make RECOMBINATION=cosmorec) and HyRec <A HREF="http://www.sns.ias.edu/~yacine/hyrec/hyrec.html">HyRec</A> (make RECOMBINATION=hyrec)
readme.html:<LI>Interpolation accuracy and speed improved by using fiducial template (set <b>use_spline_template=F</b> to recover previous behaviour). For summary of current accuracy performance see <A HREF="http://arxiv.org/abs/1201.3654">arXiv:1201.3654</A>.
readme.html:<LI>Added <b>version_check</b> to output .ini files to track CAMB version being used
readme.html:<LI>Option to export curvature alpha_l(r) and beta_l(r) [useful for local non-Gaussianity]
readme.html:<LI>Fixed array bounds issue for closed-model tensor calculation
readme.html:<LI>Added improved high k&tau; approximations from <A HREF="http://arxiv.org/abs/1104.2933">arXiv:1104.2933</A>.
readme.html:<LI>Optimized very accurate massive neutrino evolution and perturbatively relativistic expansion (much faster, see the <A HREF="http://cosmologist.info/notes/CAMB.pdf">notes</A>)
readme.html:<LI>Fractional numbers of neutrinos now used to increase neutrino temperature equally for all neutrinos, giving consistency for number densities of massive neutrinos
readme.html:Merged flat and non-flat derivative routines in equations.f90, time evolution restructuring and some higher-order tight coupling terms from <A HREF="http://arxiv.org/abs/1012.0569">arXiv:1012.0569</A>.
readme.html:<LI>Added apodization in lensing.f90 so that slow full integration is now only used for lmax>=5000 rather than lmax>=3000 (or if AccurateBB is set).
readme.html:<LI>Added quick calculation of the high-L tails of the lensing convolution by rescaling a template (speeds up high-accuracy lensedCl calculation with minimal loss of accuracy).
readme.html:<LI>Removed a couple of options relating to unlensed or temperature-only calculations that are now rarely relevant
readme.html:<LI>(14 Jan) updated Makefile for gfortran compatibility and easier compilation for bispectrum fisher calculations
readme.html:<LI>Added Bispectrum module to calculate CMB lensing and local primordial non-Gaussianity bispectra for temperature and polarization (see <A HREF="http://arxiv.org/abs/1101.2234">arXiv:1101.2234</A>). Define FISHER in the makefile to also calculate Fisher elements for the bispectra, including lensing signal variance effects (you make need to edit makefile to link to LAPACK). Corresponding new parameters in the .ini file.
readme.html:<LI><b>lens_potential_output_file</b> format changed to included temperature and polarization spectra (scalar+tensor), and extra column giving [l(l+1)]<sup>3/2</sup>C<sub>&psi;E</sub>/2&pi; - the correlation of the lensing potential with the E polarization.
readme.html:Updates for BAO calculations were in CosmoMC May 2010.
readme.html:Recfast updated to version 1.5 (rising to 2% change at l=2000; added rate fudge to match <A HREF="http://arxiv.org/abs/0910.4383">0910.4383</A>; use <b>RECFAST_Hswitch = F</b> to recover old result). Added <b>lens_potential_output_file</b> parameter to get sensibly normalized lensing potential ([l(l+1)]<sup>2</sup>C<sub>l</sub>/2&pi; and temperature correlation). Added code parameter do_bispectrum to modules.f90 for parameter tweaks to get accurate transfer functions for f<sub>NL</sub> calculations.
readme.html:Fixed serious bug in the calculation of lensed non-flat models (introduced in the Feb 2008 version).
readme.html:Fixed proton mass error (and hence incorrect baryon evolution on pressure-damping scales; note CAMB is not as accurate as <A HREF="http://camb.info/sources/">CAMB sources</A> anyway due to use of adiabatic pressure).
readme.html:Restructured recombination module to allow use of different models. RECFAST default implementation updated to version 1.4.2 (+fixes, tiny change to results). Misc minor changes.
readme.html:New reionization history model: new input parameter <B>re_delta_redshift</B> (does not change optical depth), and option to set <B>re_ionization_frac=-1</B> to automatically set the reionization fraction from input Y<sub>He</sub> assuming Helium is singly reionized at the same time as hydrogen (hence mapping of redshift to optical depth different to before at 10% level; see the <A HREF="http://cosmologist.info/notes/CAMB.pdf">notes</A>).  Reionization history now specified in (replaceable) module in reionization.f90; default includes tiny effect of He double reionization at z~3.5. Some internal reorganization.
readme.html:Added <B>pivot_scalar</B> and <B>pivot_tensor</B> input parameters for initial power spectrum. <b>output</b> subroutine (equations.f90) re-arranged to separated ISW source terms.
readme.html:Updated RECFAST to version 1.4 (~0.5% effect at high <I>l</I>; new RECFAST_fudge_He,RECFAST_Heswitch parameters, removed Dubrovich modifications). <B>lensed_total_output_file</b> parameter to get lensed scalar plus tensor power spectrum. Calculates CosmoMC's theta parameter for each model (code in modules.f90). Modules routine <B>MatterPowerData_Load</B> to read in matter power (for splining from pre-computed file); <B>MatterPowerData_k</B> function now extrapolates low-k out of range. <B>transfer_interp_matterpower</B> parameter to switch between interpolated regular grid in log k or array at actual computed values (better for later re-interpolation). Added camb.vfproj Intel Visual Fortran project file. Simplifying internal changes from <A HREF="http://camb.info/sources">CAMB sources</A>, e.g. use of Ranges module for setting time steps and k sampling values; also now switches to log k source spacing at very high l to speed up calculation where spectra smooth. More diagnostics and options in the  <A HREF="http://camb.info/test_suite.tar.gz">test suite</A>.
readme.html:Updated RECFAST to version 1.3 (0.1% effect on C<sub>l</sub>). Tweak to get &lt;0.3% error in matter power spectrum around the peak when <B>transfer_high_precision = T</B>.
readme.html:Fixed problem generating combinations of scalars and tensors in camb.f90 (since August version).
readme.html:Speeded calculation of lensed spectra and lensing power spectrum by using Limber approximation on small scales (no loss of accuracy). Fixed missing f_K in source term for non-flat lensing potential. Minor changes to default parameters and compatibility tweaks. Can <A HREF="http://camb.info/test_suite.tar.gz">download</A> test suite for comparing accuracy and code versions.
readme.html:Fixed bug setting default neutrino degeneracy if none specified and initialization of nu_mass_eigenstates for programmatic access. Other minor fixes.
readme.html:Added support for arbitrary neutrino mass splittings. New option to set <B>transfer_k_per_logint=0</B> to get automatic accurate k-sampling of the matter power spectrum. Fixed Transfer_GetMatterPower at large scales for non-flat models. New setting value <B>massive_nu_approx=3</B> to use whatever method is good to get fast accurate results. Other internal changes.
readme.html:Added <B>do_nonlinear</B> option to apply non-linear corrections from HALOFIT (<A HREF="http://arxiv.org/abs/astro-ph/0207664">astro-ph/0207664</A>). <B>do_nonlinear = 1</B> applies just to the matter power spectra, <B>do_nonlinear=2</B> applies corrections to the lensed CMB power spectra (important for BB). HALOFIT should only be used for standard adiabatic &Lambda;CDM models with power law initial power spectra.
readme.html:New <B>recombination</B> option (1 does RECFAST as before, 2 uses modified version from <a href="http://arxiv.org/abs/astro-ph/0501672">astro-ph/0501672</a>). New option <B>do_late_rad_trunction</B> to turn off the small scale radiation hierarchies after matter domination (see <A HREF="http://cosmocoffee.info/discuss/astro-ph/0503277">astro-ph/0503277</A> and the <A HREF="http://cosmologist.info/notes/CAMB.pdf">notes</A>) - saves some time. New <B>output_root</B> option to prefix output file names and generate output_root_params.ini file of input parameters for the run.
readme.html:Default lensing routine (<B>lensing_method=1</B>) changed to use new full-sky correlation function method (<A HREF="http://arxiv.org/abs/astro-ph/0502425">astro-ph/0502425</A>) in preference to the harmonic method of <A HREF="http://arxiv.org/abs/astro-ph/0001303">astro-ph/0001303</A> (<B>lensing_method=3</B>; inaccurate at l>1000 at ~1.5% level by l=2000). The lensed result is now significantly faster and more accurate.
readme.html:Also added flat-sky method (<B>lensing_method=2</B>) of <A HREF="http://arxiv.org/abs/astro-ph/9505109">astro-ph/9505109</A> and <A HREF="http://arxiv.org/abs/astro-ph/9803150">astro-ph/9803150</A> as in CMBFAST (accurate to 0.4%). New <B>accurate_BB</B> parameter to get lensed BB accurately (within assumptions of linearity and given k_max, l_max, etc.). Note lensed_output_file no longer contains any tensor contribution. Various changes for better accuracy and compiler compatibility, including same accuracy with massive neutrinos as with massless.
readme.html:Fixed effect of reionization on the lensed C<sub>l</sub> (0.5% on small scale TT).
readme.html:Fixed serious problem with tensor mode polarized C<sub>l</sub> from reionization (significantly underestimated power).
readme.html:Changed default tensor pivot scale to 0.05 Mpc<sup>-1</sup> (same as for scalars). Flat Bessel functions no longer cached to disk (faster to compute than read in many cases; prevents problems in uses with MPI). New <B>accurate_reionization</B> flag for accurate calculation of large scale scalar EE around the first dip (also outputs computed optical depth due to reionization). Option to output vector mode spectra from regular vorticity mode (<A HREF="http://arxiv.org/abs/astro-ph/0403583">astro-ph/0403583</A>) or magnetic field (<A HREF="http://arxiv.org/abs/astro-ph/0406096">astro-ph/0406096</A>).
readme.html:Improved accuracy of non-flat calculation, and allowed for very nearly flat models (&Omega;<sub>K</sub> ~ 1e-5). Non-flat code should be as accurate as the flat (0.5%) on most scales. Added run-time parameters <B>do_tensor_neutrinos</B> (to include the neutrino evolution in the tensor equations) and <B>cs2_lam</B> (constant sound speed of the dark energy) instead of having to modify the code. Fixed fatal bug in tensor neutrino setup introduced some time this year. Added parameter <B>CMB_outputscale</B> to scale output Cls by a constant (see comments in params.ini for getting microK^2 output).
readme.html:Fixed instability in bessels.f90 which gave problem for very nearly flat closed models with abnormal Helium fractions (and possibly other models). Dark energy equations in equations.f90 changed to use simpler general fluid equations for the perturbations (see <A HREF="http://arxiv.org/abs/astro-ph/0307104">astro-ph/0307104</A>). inidriver.F90 now reads in scalar amplitude even if computing tensors only (so combination with the initial ratio sets correct tensor amplitude).
readme.html:Fixed bug in equations.f90 giving errors with non-flat models. Fixed bug in inidriver.F90 setting H<sub>0</sub> with <B>use_physical=F</B>. Fixed camb.f90 file in download - missing routines for getting C<sub>l</sub> transfer functions.
readme.html:Some major restructuring, including new functions to return the CMB transfer functions (see camb.f90). The tight coupling code has been re-written, adding quadrupole terms and accounting for the time variation of the opacity numerically. The code should be more accurate and faster, especially on small scales. Minor fixes to RECFAST to match version in CMBFAST (0.01% effect on C<sub>l</sub>s), and bug fix in output routine (0.3%). Includes constant w dark energy and running spectral index parameters by default (rather than with an add-on). New <B>use_physical</B> parameter to allow alternative model specification by Om_b h^2, Om_b h^2 and Om_k. Polarization .fits files now compatible with HEALPIX 1.2.
readme.html:Minor changes for greater compiler compatibility, in particular with Visual Fortran. Makefile includes suggested options for a variety of compilers.
readme.html:Added support for neutrino isocurvature initial conditions, and
readme.html:totally correlated mixed initial conditions (assuming the same power
readme.html:params.ini. Partially correlated mixed initial conditions can be
readme.html:correlated initial conditions.
readme.html:HREF="http://cosmologist.info/cosmomc/">CosmoMC</A>. New option to output matter power spectrum.
readme.html:0.002 MPc<sup>-1</sup> (power_tilt.f90), added pivot point and normalization to
readme.html:Massive neutrino support improved. Background evolution is much
readme.html:masses. Output transfer function files now include columns for the
readme.html:massive neutrino and total perturbations. Sigma_8 is now computed
readme.html:how the massive neutrinos are evolved - option for new approximate fast scheme
readme.html:that can be used to get useful information about the model being
readme.html:Fixed rare problem computing closed models, and bug in computation of
readme.html:closed transfer functions. The names of the massive neutrino
readme.html:column of the scalar_output_file, followed by the cross-correlation
readme.html:evolution is now determined from routines in gauge_inv.f90 (and
readme.html:additional matter components, use extended theories, etc. RECFAST now
readme.html:Added Makefile for better compilation, and added option to create FITS
readme.html:Fixed the neutrino ratio factor in the normalization of the scalar
readme.html:since the January 2001 version. Changes to gauge_inv.f90 and gauge_sync.f90.
readme.html:parameterizing in terms of slow-roll inflation parameters.<P>
readme.html:erroneous blip in ionization history).<P>
readme.html:additional parameters to control the normalization of the output Cls,
readme.html:allowing absolute computations using correctly normalized initial
readme.html:explain the definition of the power spectra that should be returned by the TensorPower and
readme.html:The transfer functions are now output in terms of k rather than beta
readme.html:functions via d2norm is documented. The variables used to propagate
readme.html:Now uses an accurate approximation to propagate massive neutrino
readme.html:perturbations once no longer highly relativistic, speeding up
readme.html:computation by about a factor of two (gauge_inv routine only). All massive
readme.html:neutrino equations are described in  <A
readme.html:Fixes inaccurate computation of the tensor quadrupole in flat
readme.html:stress in the tensor computation by default, accounting for massive neutrinos
readme.html:This version also fixes the tight coupling switch over to give
readme.html:Adds support for RECFAST recombination
readme.html:3.0. RECFAST is an option via the fifth line in the input file as in
readme.html: The <A href="http://class-code.net">CLASS</A> CMB code is written independently of CAMB and CMBFAST and is in pure C (not C++, despite the name). The basic equations and algorithm are substantially the same as CMBFAST in both cases, with CLASS having a C implementation of CAMB's lensed power spectrum method, and CAMB implementing in F90 some of the new very-sub-horizon approximations introduced in CLASS (which make little difference at WMAP precision, but significantly increase speed for small-scales and high accuracy). The codes use different combinations of approximation schemes and sampling for massive neutrinos. For standard models at CAMB's default accuracy settings speeds should be similar depending on compilers used, with CAMB's <b>high_accuracy_default</b> option being similar to CLASS's <b>cl_permille.pre</b>.
readme.html:The main differences in the non-flat computation lie in how we perform the integral of the source
readme.html:functions with the hyperspherical Bessel functions. We use
readme.html:Kosowsky's WKB approximation or the recursion relation to evaluate the Bessel
readme.html:functions at the starting point of ranges of integration, and then
readme.html:integrate the differential equation. CMBFAST
readme.html:integrates up the differential equation from a pre-calculated starting point. Unlike
readme.html:CMBFAST 3.2 our ranges of integration continue into the Chi > pi/2
readme.html:region for closed models. We avoid problems with stability of the
readme.html:integration (contamination with the irregular solution) by cutting off
readme.html:the integration when the errors become important (where the values in the
readme.html:the symmetry of the Bessel functions is used to extend to the Chi> Pi/2 region.
readme.html:rather faster than CMBFAST in many cases. Assuming same recombination history CAMB agrees with the CMBFAST 4.5 high precision TT calculation to < 1% at low l, and about 0.3% at l>100 in concordance flat models. If CAMB is run with high precision options the agreement is nearly 0.1% at high l. The polarized spectra also agree well except around the first dip in the EE spectrum with reionization (see CAMB's accurate_reionization parameter).
readme.html:Note that as of March 2008 CAMB's reionization parameterization is slightly different to CMBFAST. CMBFAST 4.5.1 also uses an old version of RECFAST.
readme.html:CMBFAST uses the flat sky and Limber approximation and works from the transfer
readme.html:functions to work out the lensing potential, CAMB uses the full result (agreement is excellent). CAMB uses a full-sky correlation function method rather than the flat sky approx (about max 0.4% effect on EE).
readme.html:CMBFAST 4 uses a "k-splitting" to allow rapid computation of grids of
readme.html:CAMB is in Fortran 90 and is more modularized, so using different initial power spectra, modified equations, etc. is often just a case of modifying one or two files and re-compiling.
readme.html:Note that the conventions for the polarization power spectra output by CAMB agree with those of CMBFAST. This sign convention for the cross-correlation C_l^TE spectrum differs from the definitions in <A
readme.html:HREF="http://arxiv.org/abs/astro-ph/9911481">astro-ph/9911481</A>. As from CMBFAST 4.2 the initial power spectrum normalization conventions also agree.
readme.html:use CAMB from your own programs. You can also use CAMB_GetTransfers to access the C_l transfer functions directly without incorporating the initial power spectrum.
readme.html:The main subroutine that does integrations, etc. Encompasses CMBFAST's
readme.html:<B>equations.f90</B>
readme.html:Files containing background and perturbation evolution equations. The
readme.html:perturbations equations used are derived in the covariant approach,
readme.html:fixing to the CDM (zero acceleration) frame, which are essentially
readme.html:equivalent to the synchronous gauge equations.
readme.html:   the necessary perturbation calculation routines for
readme.html:   background evolution is needed. It
readme.html:   also need to change the GetOmegak routine if you add additional
readme.html:   additional initialization.
readme.html:   outtransf writes out the matter transfer functions.
readme.html:   given wavenumber. These are the temperature, E polarization and (if
readme.html:   doing lensing) the lensing source. By editing the equation for the
readme.html:   spectra for other matter tracers, e.g. for cross-correlation with
readme.html:<P><i>equations_ppf.f90</i> is an alternative module that allows evolving dark energy crossing w=-1.
readme.html:<B> reionization.f90</B>
readme.html:This file defines a module called Reionization that parameterizes the reionization history and supplies a function <B>Reionization_xe</B> that gives x<sub>e</sub> as a function of redshift. Optical depth input parameters are mapped into z<sub>re</sub> (defined as where x<sub>e</sub> is half its maximum (ex second He reionization)) using a binary search. See the CAMB <A HREF="http://cosmologist.info/notes/CAMB.pdf">notes</A> for discussion. This module should be easily modifiable for alternative reionization models.
readme.html:Implements the NonLinear module, to calculate non linear scalings of the matter power spectrum as a function of redshift. Uses HALOFIT (<A HREF="http://arxiv.org/abs/astro-ph/0207664">astro-ph/0207664</A>, code thanks to <A HREF="http://www.astro.upenn.edu/~res">Robert Smith</A>, with tweaks
readme.html:from <A HREF="http://arxiv.org/abs/1208.2701">arXiv:1208.2701</A> (thanks Ryuichi Takahashi) - see that paper for discussion of numerical accuracy. This module can be replaced to use a different non-linear fitting method if desired.
readme.html:    this file to generate grids of models, change the parameterization, etc.
readme.html:   functions. Hyper-spherical functions generated by use of
readme.html:   either the recursion relation or Kosowsky's WKB approximation. Based on
readme.html:   Various subroutines for interpolation, and modified Runge-Kutta
readme.html:   dverk for parallelized evolution.
readme.html: RECFAST integrator for Cosmic Recombination of Hydrogen and Helium
readme.html: by Douglas Scott (with minor modifications for CMBFAST and the
readme.html: for the original code. This module implements the RECOMBINATION module required by CAMB, and could be replaced by more detailed codes. Sample wrappers are also provided for <A HREF="http://www.cita.utoronto.ca/~jchluba/Science_Jens/Recombination/CosmoRec.html">CosmoRec</A> and <A HREF="http://www.sns.ias.edu/~yacine/hyrec/hyrec.html">HyRec</A>, but the libraries for these must be installed separately.
readme.html:  Implements calculation of simple separable primordial bispectra, specifically the local constant f<sub>NL</sub> model, and the CMB lensing bispectrum due to the linear temperature and polarization cross-correlation with the lensing potential. Compile with FISHER defined in the makefile to also calculate Fisher elements, including the effects of lensing signal variance (edit Makefile to link to LAPACK if necessary). Note that the primordial bispectra here are unlensed (see <A HREF="http://arxiv.org/abs/0905.4732">arXiv:0905.4732</a> for a calculation), but the lensed bispectra are calculated non-perturbatively (but approximately) using the lensed small-scale CMB power spectra. Note that calculating primordial bispectra is significantly slower than doing standard power spectrum calculations, however it parallelizes well.
readme.html:Scalar numerical errors should rarely exceed 0.3% for min(2500, L well into the damping tail) at default accuracy setting, and 0.1% for 500&lt;L&lt;2000 with <b>high_accuracy_default=T</b>. Matter power spectrum errors are usually dominated by interpolation in the acoustic oscillations, with about 0.2% accuracy with high_accuracy_default (but much better rms accuracy). For a detailed study of numerical accuracy as of January 2012 see <A HREF="http://arxiv.org/abs/1201.3654">arXiv:1201.3654</A>.
readme.html:See also <A HREF="#COMPARE">comparison</A> with CMBFAST. Accuracy of course assumes the model is correct, and is dependent on RECFAST being the correct ionization history. Lensed C_l TT, TE and EE are accurate at the same level  (to within the approximation that the lensing potential is linear, or the accuracy of the HALOFIT non-linear model).
readme.html: Tensor errors around 2% or more on small scales (e.g. due to l-interpolation). Low l accuracy somewhat worse than scalars (typically < 1%). Turn on neutrinos in the input file for accurate results (automatic on high accuracy setting).
readme.html: Hierarchy truncation errors up to 5% at high l (&gt;1500) in some
readme.html:<H3>Add-ons, extensions, external sites</H3>
readme.html:<LI><A HREF="http://background.uchicago.edu/camb_rpc/">Reionization principal components</a>
readme.html:<LI><A HREF="http://camb.info/sources">CAMB sources</A> get linear 21cm, lensing and number counts; 3rd order perturbation theory P(k); perturbed recombination
readme.html:<LI><A HREF="http://lambda.gsfc.nasa.gov/toolbox/tb_camb_form.cfm">CAMB online</A> (note may not be latest version)
readme.html:<LI><A HREF="http://people.sissa.it/~leach/inflation/camb_inflation.html">Inflationary parameterization</A> of initial power by Samuel Leach.
readme.html:Some notes and relevant Maple derivations are given <A HREF="http://camb.info/theory.html">here</A> (see also the Appendix of <A HREF="http://arxiv.org/abs/astro-ph/0406096">astro-ph/0406096</A>). The <A HREF="http://cosmologist.info/notes/CAMB.pdf">CAMB notes</A> outline the equations and approximations used, and relation to standard synchronous-gauge and Newtonian-gauge variables; see also <A
readme.html:CMB power spectrum parameter degeneracies in the era of precision cosmology<BR>
readme.html:Efficient computation of CMB anisotropies in closed FRW Models<BR>
readme.html:<P>Evolution of cosmological dark matter perturbations<BR>
readme.html: Microwave background anisotropies from gravitational waves: the 1+3
readme.html:Microwave background polarization in cosmological models<BR>
readme.html:(The appendix contains general derivations of the multipole equations and C<SUB>l</SUB> as used in CAMB)
readme.html:<B>Initial conditions</B>
readme.html: The General Primordial Cosmic Perturbation <BR>
readme.html:<B>RECOMBINATION</B>
readme.html:A new calculation of the recombination epoch.<BR>
readme.html:How well do we understand cosmological recombination?<BR>
readme.html:Lensed CMB power spectra from all-sky correlation functions<BR>
readme.html:A. Challinor and A. Lewis. <A HREF="http://arxiv.org/abs/astro-ph/0502425">astro-ph/0502425</A>. (For Maple derivations see the <A HREF="http://camb.info/theory.html">theory page</A>.)<BR>
readme.html:Gravitational lensing effect on cosmic microwave background
readme.html:Gravitational Lensing Effect on Cosmic Microwave Background
readme.html:                  Polarization<BR>
readme.html:<B>Sub-horizon radiation approximations</B>
readme.html:                  Approximation schemes<BR>
readme.html:CMB power spectrum parameter degeneracies in the era of precision cosmology
readme.html:<P>Evolution of cosmological dark matter perturbations<BR>
readme.html:<B>WKB approx to hyperspherical Bessel functions</B>
readme.html: Efficient Computation of Hyperspherical Bessel Functions<BR>
readme.html: A line of sight integration approach to Cosmic Microwave Background
readme.html:Integral solution for the microwave background
recfast.f90:!Recombination module for CAMB, using RECFAST
recfast.f90:!C Integrator for Cosmic Recombination of Hydrogen and Helium,
recfast.f90:!C based on calculations in the paper Seager, Sasselov & Scott
recfast.f90:!C Permission to use, copy, modify and distribute without fee or royalty at
recfast.f90:!C any tier, this software and its documentation, for any purpose and without
recfast.f90:!C and that the same appear on ALL copies of the software and documentation,
recfast.f90:!C including modifications that you make for internal use or for distribution:
recfast.f90:!C REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  
recfast.f90:!C BY WAY OF EXAMPLE, BUT NOT LIMITATION,
recfast.f90:!c U.B.C. MAKES NO REPRESENTATIONS OR WARRANTIES OF 
recfast.f90:!C THE USE OF THE LICENSED SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE 
recfast.f90:!CV     Version: 1.5.2
recfast.f90:!CP     Purpose:  Calculate ionised fraction as a function of redshift.
recfast.f90:!CD     Description: Solves for ionisation history since recombination
recfast.f90:!CD     using the equations in Seager, Sasselov & Scott (ApJ, 1999).
recfast.f90:!CD	 Additional He "fudge factors" are as described in Wong, Moss
recfast.f90:!CD	 Extra fitting function included (in optical depth) to account
recfast.f90:!CA     Name, Description
recfast.f90:!CA     x is total ionised fraction, relative to H
recfast.f90:!CA     x_H is ionized fraction of H - y(1) in R-K routine
recfast.f90:!CA     x_He is ionized fraction of He - y(2) in R-K routine
recfast.f90:!CA     alphaB is case B recombination rate
recfast.f90:!CA     alpHe is the singlet only HeII recombination rate
recfast.f90:!CA     Trad and Tmat are radiation and matter temperatures
recfast.f90:!CA	    Hz is the value of H at the specific z (in ION)
recfast.f90:!CA     G is grvitational constant
recfast.f90:!CA     x0 is initial ionized fraction
recfast.f90:!CA     x_H0 is initial ionized fraction of Hydrogen
recfast.f90:!CA     x_He0 is initial ionized fraction of Helium
recfast.f90:!CA     zeq is the redshift of matter-radiation equality
recfast.f90:!CA     sigma: Thomson cross-section
recfast.f90:!CA     a_rad: radiation constant for u=aT^4
recfast.f90:!CA     L_H_ion: level for H ionization in m^-1
recfast.f90:!CA     L_He1_ion: level for HeI ionization
recfast.f90:!CA     L_He2_ion: level for HeII ionization
recfast.f90:!CA     CB1_He1: CB1 for HeI ionization potential
recfast.f90:!CA     CB1_He2: CB1 for HeII ionization potential
recfast.f90:!CA Heswitch=integer for modifying HeI recombination
recfast.f90:!CA  and also the continuum opacity of H, with a fitting function
recfast.f90:!CA a_trip: used to fit HeI triplet recombination rate
recfast.f90:!CA b_trip: used to fit HeI triplet recombination rate
recfast.f90:!CA L_He2St_ion: level for 23S1-continuum in m^-1
recfast.f90:!CA sigma_He_2Ps: H ionization x-section at HeI 21P1-11S0 freq. in m^2
recfast.f90:!CA sigma_He_2Pt: H ionization x-section at HeI 23P1-11S0 freq. in m^2
recfast.f90:!CA CfHe_t: triplet statistical correction
recfast.f90:!CA	Hswitch is an boolean for modifying the H recombination
recfast.f90:!CM     GET_INIT (initial values for ionization fractions)
recfast.f90:!CM     ION (ionization and Temp derivatives)
recfast.f90:!CH     CREATED            (simplest version) 19th March 1989
recfast.f90:!CH               initial conditions are Saha
recfast.f90:!CH               July 1998 (include OmegaT correction and H fudge factor)
recfast.f90:!CH               Jan 1999 (tidied up for public consumption)
recfast.f90:!CH                     Oct 2001 fixed error in hubble parameter, now uses global function (AML)
recfast.f90:!                       March 2005 added option for corrections from astro-ph/0501672.
recfast.f90:!CH              January 2008 (improved HeI recombination effects,
recfast.f90:!                           removed Dubrovich option (wrong anyway)
recfast.f90:!CH   			 Sept 2008 (added extra term to make transition, smoother for Tmat evolution)
recfast.f90:!                          General recombination module structure, fix to make He x_e smooth also in recfast (AML)
recfast.f90:!CH		 Jan 2010 (added fitting function to modify K
recfast.f90:!AL             Sept 2012 changes now in public recfast, version number changed to match Recfast 1.5.2.
recfast.f90:        real(dl) L_H_ion,L_H_alpha,L_He1_ion,L_He2_ion,L_He_2s,L_He_2p
recfast.f90:        real(dl)  L_He_2Pt,L_He_2St,L_He2St_ion
recfast.f90:!The following only used for approximations where small effect
recfast.f90:        data    L_H_ion     /1.096787737D7/ !level for H ion. (in m^-1)
recfast.f90:        data    L_He1_ion   /1.98310772D7/  !from Drake (1993)
recfast.f90:        data    L_He2_ion   /4.389088863D7/ !from JPhysChemRefData (1987)
recfast.f90:        data    L_He2St_ion /3.8454693845D6/ !Drake & Morton (2007)
recfast.f90:        module Recombination
recfast.f90:        logical, parameter  :: RECFAST_Hswitch_default = .true. !include H corrections (v1.5, 2010)
recfast.f90:        type RecombinationParams
recfast.f90:         !1) full expression for escape probability for singlet'
recfast.f90:         !'   1P-1S transition'
recfast.f90:         !3) only including recombination through the triplets'
recfast.f90:        end  type RecombinationParams
recfast.f90:        character(LEN=*), parameter :: Recombination_Name = 'Recfast_1.5.2'
recfast.f90:        real(dl) :: recombination_saha_z !Redshift at which saha OK
recfast.f90:        real(dl) :: recombination_saha_tau !set externally
recfast.f90:        public RecombinationParams, Recombination_xe, Recombination_tm,Recombination_ts ,Recombination_init,   &
recfast.f90:               Recombination_ReadParams, Recombination_SetDefParams, Recombination_Validate, Recombination_Name, &
recfast.f90:               recombination_saha_tau, recombination_saha_z
recfast.f90:         subroutine Recombination_ReadParams(R, Ini)
recfast.f90:          Type(RecombinationParams) :: R
recfast.f90:         end subroutine Recombination_ReadParams
recfast.f90:        subroutine Recombination_SetDefParams(R)
recfast.f90:         type (RecombinationParams) ::R
recfast.f90:        end subroutine Recombination_SetDefParams
recfast.f90:        subroutine Recombination_Validate(R, OK)
recfast.f90:          Type(RecombinationParams),intent(in) :: R
recfast.f90:         end subroutine Recombination_Validate
recfast.f90:        function Recombination_tm(a)
recfast.f90:        real(dl) zst,a,z,az,bz,Recombination_tm
recfast.f90:        if (.not. doTmatTspin) stop 'RECFAST: Recombination_tm not stored'
recfast.f90:            Recombination_tm=Tnow/a
recfast.f90:          Recombination_tm=Tmrec(nz)
recfast.f90:          Recombination_tm=az*Tmrec(ilo)+bz*Tmrec(ihi)+ &
recfast.f90:        end function Recombination_tm
recfast.f90:        function Recombination_ts(a)
recfast.f90:        real(dl) zst,z,az,bz,Recombination_ts
recfast.f90:          Recombination_ts=tsrec(1)
recfast.f90:          Recombination_ts=tsrec(nz)
recfast.f90:          Recombination_ts=az*tsrec(ilo)+bz*tsrec(ihi)+ &
recfast.f90:        end function Recombination_ts
recfast.f90:        function Recombination_xe(a)
recfast.f90:        real(dl) zst,z,az,bz,Recombination_xe
recfast.f90:          Recombination_xe=xrec(1)
recfast.f90:          Recombination_xe=xrec(nz)
recfast.f90:          Recombination_xe=az*xrec(ilo)+bz*xrec(ihi)+ &
recfast.f90:        end function Recombination_xe
recfast.f90:        subroutine Recombination_init(Recomb, OmegaC, OmegaB, Omegan, Omegav, h0inp,tcmb,yp, nnu, eftflag, eftmodelflag)
recfast.f90:        !Note recfast only uses OmegaB, h0inp, tcmb and yp - others used only for Tmat approximation where effect small
recfast.f90:        Type (RecombinationParams) :: Recomb
recfast.f90:        real(dl), intent(in), optional :: nnu
recfast.f90:        real(dl), dimension(:,:), allocatable :: w
recfast.f90:           !For example if called with different reionization, or tensor rather than scalar
recfast.f90:!       write(*,*)'recfast version 1.0'
recfast.f90:!       write(*,*)'Using Hummer''s case B recombination rates for H'
recfast.f90:!       write(*,*)'and tabulated HeII singlet recombination rates'
recfast.f90:        recombination_saha_z=0.d0
recfast.f90:!	(this is explictly for 3 massless neutrinos - change if N_nu.ne.3; but only used for approximation so not critical)
recfast.f90:        DeltaB = h_P*C*(L_H_ion-L_H_alpha)
recfast.f90:        DeltaB_He = h_P*C*(L_He1_ion-L_He_2s)   !2s, not 2p
recfast.f90:        CB1 = h_P*C*L_H_ion/k_B
recfast.f90:        CB1_He1 = h_P*C*L_He1_ion/k_B   !ionization for HeI
recfast.f90:        CB1_He2 = h_P*C*L_He2_ion/k_B   !ionization for HeII
recfast.f90:!       Matter departs from radiation when t(Th) > H_frac * t(H)
recfast.f90:!       OK that's the initial conditions, now start writing output file
recfast.f90:! Use Saha to get x_e, using the equation for x_e for ionized helium
recfast.f90:! Everything ionized above z=8000.  First ionization over by z=5000.
recfast.f90:! Assume He all singly ionized down to z=3500, then use He Saha until
recfast.f90:! He is 99% singly ionized, and *then* switch to joint H/He recombination.
recfast.f90:            call DVERK(Recomb,3,ION,zstart,y,zend,tol,ind,cw,nw,w)
recfast.f90:            call DVERK(Recomb,nw,ION,zstart,y,zend,tol,ind,cw,nw,w)
recfast.f90:        end subroutine Recombination_init
recfast.f90:!       Set up the initial conditions so it will work for general,
recfast.f90:!       Initial ionization fraction using Saha for relevant species
recfast.f90:        subroutine ION(Recomb,Ndim,z,Y,f)
recfast.f90:        Type (RecombinationParams) :: Recomb
recfast.f90:	print*,'ION is called!!!!!!!' !bh
recfast.f90:!c	fit a double Gaussian correction function
recfast.f90:    Rup_trip = Rdown_trip*dexp(-h_P*C*L_He2St_ion/(k_B*Tmat))
recfast.f90:            recombination_saha_z = z  
recfast.f90:!   for interest, calculate the correction factor compared to Saha
recfast.f90:!   Modification to HeI recombination including channel via triplets
recfast.f90:!	additional term to smooth transition to Tmat evolution,
recfast.f90:        end subroutine ION
recfast.f90:        function dDeltaxe_dtau(a, Delta_xe,Delta_nH, Delta_Tm, hdot, kvb)
recfast.f90:        !d x_e/d tau assuming Helium all neutral and temperature perturbations negligible
recfast.f90:        x_H = min(1._dl,Recombination_xe(a))
recfast.f90:        Tmat = Recombination_tm(a)
recfast.f90:        end function dDeltaxe_dtau
recfast.f90:          function polevl(x,coef,N)
recfast.f90:          end function polevl
recfast.f90:          function derivpolevl(x,coef,N)
recfast.f90:          end function derivpolevl
recfast.f90:        function kappa_HH_21cm(T, deriv)
recfast.f90:        !Polynomail fit to Hydrogen-Hydrogen collision rate as function of Tmatter, from astro-ph/0608032
recfast.f90: !        real(dl), dimension(8), parameter :: fit = &
recfast.f90:         integer, dimension(n_table), parameter :: Temps = &
recfast.f90:         real, dimension(n_table), parameter :: rates = &
recfast.f90:         real(dl), save, dimension(:), allocatable :: logRates, logTemps, ddlogRates
recfast.f90:        end function kappa_HH_21cm
recfast.f90:        function kappa_eH_21cm(T, deriv)
recfast.f90:        !Polynomail fit to electron-Hydrogen collision rate as function of Tmatter; from astro-ph/0608032
recfast.f90:         real(dl), dimension(6), parameter :: fit = &
recfast.f90:        end function kappa_eH_21cm
recfast.f90:        function kappa_pH_21cm(T, deriv) ! from astro-ph/0702487
recfast.f90:        !Polynomail fit to proton-Hydrogen collision rate as function of Tmatter
recfast.f90:         integer, dimension(n_table), parameter :: Temps = &
recfast.f90:         real, dimension(n_table), parameter :: rates = &
recfast.f90:         real(dl), save, dimension(:), allocatable :: logRates, logTemps, ddlogRates
recfast.f90:        end function kappa_pH_21cm
recfast.f90:        end module Recombination
recfast.f90~:!Recombination module for CAMB, using RECFAST
recfast.f90~:!C Integrator for Cosmic Recombination of Hydrogen and Helium,
recfast.f90~:!C based on calculations in the paper Seager, Sasselov & Scott
recfast.f90~:!C Permission to use, copy, modify and distribute without fee or royalty at
recfast.f90~:!C any tier, this software and its documentation, for any purpose and without
recfast.f90~:!C and that the same appear on ALL copies of the software and documentation,
recfast.f90~:!C including modifications that you make for internal use or for distribution:
recfast.f90~:!C REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  
recfast.f90~:!C BY WAY OF EXAMPLE, BUT NOT LIMITATION,
recfast.f90~:!c U.B.C. MAKES NO REPRESENTATIONS OR WARRANTIES OF 
recfast.f90~:!C THE USE OF THE LICENSED SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE 
recfast.f90~:!CV     Version: 1.5.2
recfast.f90~:!CP     Purpose:  Calculate ionised fraction as a function of redshift.
recfast.f90~:!CD     Description: Solves for ionisation history since recombination
recfast.f90~:!CD     using the equations in Seager, Sasselov & Scott (ApJ, 1999).
recfast.f90~:!CD	 Additional He "fudge factors" are as described in Wong, Moss
recfast.f90~:!CD	 Extra fitting function included (in optical depth) to account
recfast.f90~:!CA     Name, Description
recfast.f90~:!CA     x is total ionised fraction, relative to H
recfast.f90~:!CA     x_H is ionized fraction of H - y(1) in R-K routine
recfast.f90~:!CA     x_He is ionized fraction of He - y(2) in R-K routine
recfast.f90~:!CA     alphaB is case B recombination rate
recfast.f90~:!CA     alpHe is the singlet only HeII recombination rate
recfast.f90~:!CA     Trad and Tmat are radiation and matter temperatures
recfast.f90~:!CA	    Hz is the value of H at the specific z (in ION)
recfast.f90~:!CA     G is grvitational constant
recfast.f90~:!CA     x0 is initial ionized fraction
recfast.f90~:!CA     x_H0 is initial ionized fraction of Hydrogen
recfast.f90~:!CA     x_He0 is initial ionized fraction of Helium
recfast.f90~:!CA     zeq is the redshift of matter-radiation equality
recfast.f90~:!CA     sigma: Thomson cross-section
recfast.f90~:!CA     a_rad: radiation constant for u=aT^4
recfast.f90~:!CA     L_H_ion: level for H ionization in m^-1
recfast.f90~:!CA     L_He1_ion: level for HeI ionization
recfast.f90~:!CA     L_He2_ion: level for HeII ionization
recfast.f90~:!CA     CB1_He1: CB1 for HeI ionization potential
recfast.f90~:!CA     CB1_He2: CB1 for HeII ionization potential
recfast.f90~:!CA Heswitch=integer for modifying HeI recombination
recfast.f90~:!CA  and also the continuum opacity of H, with a fitting function
recfast.f90~:!CA a_trip: used to fit HeI triplet recombination rate
recfast.f90~:!CA b_trip: used to fit HeI triplet recombination rate
recfast.f90~:!CA L_He2St_ion: level for 23S1-continuum in m^-1
recfast.f90~:!CA sigma_He_2Ps: H ionization x-section at HeI 21P1-11S0 freq. in m^2
recfast.f90~:!CA sigma_He_2Pt: H ionization x-section at HeI 23P1-11S0 freq. in m^2
recfast.f90~:!CA CfHe_t: triplet statistical correction
recfast.f90~:!CA	Hswitch is an boolean for modifying the H recombination
recfast.f90~:!CM     GET_INIT (initial values for ionization fractions)
recfast.f90~:!CM     ION (ionization and Temp derivatives)
recfast.f90~:!CH     CREATED            (simplest version) 19th March 1989
recfast.f90~:!CH               initial conditions are Saha
recfast.f90~:!CH               July 1998 (include OmegaT correction and H fudge factor)
recfast.f90~:!CH               Jan 1999 (tidied up for public consumption)
recfast.f90~:!CH                     Oct 2001 fixed error in hubble parameter, now uses global function (AML)
recfast.f90~:!                       March 2005 added option for corrections from astro-ph/0501672.
recfast.f90~:!CH              January 2008 (improved HeI recombination effects,
recfast.f90~:!                           removed Dubrovich option (wrong anyway)
recfast.f90~:!CH   			 Sept 2008 (added extra term to make transition, smoother for Tmat evolution)
recfast.f90~:!                          General recombination module structure, fix to make He x_e smooth also in recfast (AML)
recfast.f90~:!CH		 Jan 2010 (added fitting function to modify K
recfast.f90~:!AL             Sept 2012 changes now in public recfast, version number changed to match Recfast 1.5.2.
recfast.f90~:        real(dl) L_H_ion,L_H_alpha,L_He1_ion,L_He2_ion,L_He_2s,L_He_2p
recfast.f90~:        real(dl)  L_He_2Pt,L_He_2St,L_He2St_ion
recfast.f90~:!The following only used for approximations where small effect
recfast.f90~:        data    L_H_ion     /1.096787737D7/ !level for H ion. (in m^-1)
recfast.f90~:        data    L_He1_ion   /1.98310772D7/  !from Drake (1993)
recfast.f90~:        data    L_He2_ion   /4.389088863D7/ !from JPhysChemRefData (1987)
recfast.f90~:        data    L_He2St_ion /3.8454693845D6/ !Drake & Morton (2007)
recfast.f90~:        module Recombination
recfast.f90~:        logical, parameter  :: RECFAST_Hswitch_default = .true. !include H corrections (v1.5, 2010)
recfast.f90~:        type RecombinationParams
recfast.f90~:         !1) full expression for escape probability for singlet'
recfast.f90~:         !'   1P-1S transition'
recfast.f90~:         !3) only including recombination through the triplets'
recfast.f90~:        end  type RecombinationParams
recfast.f90~:        character(LEN=*), parameter :: Recombination_Name = 'Recfast_1.5.2'
recfast.f90~:        real(dl) :: recombination_saha_z !Redshift at which saha OK
recfast.f90~:        real(dl) :: recombination_saha_tau !set externally
recfast.f90~:        public RecombinationParams, Recombination_xe, Recombination_tm,Recombination_ts ,Recombination_init,   &
recfast.f90~:               Recombination_ReadParams, Recombination_SetDefParams, Recombination_Validate, Recombination_Name, &
recfast.f90~:               recombination_saha_tau, recombination_saha_z
recfast.f90~:         subroutine Recombination_ReadParams(R, Ini)
recfast.f90~:          Type(RecombinationParams) :: R
recfast.f90~:         end subroutine Recombination_ReadParams
recfast.f90~:        subroutine Recombination_SetDefParams(R)
recfast.f90~:         type (RecombinationParams) ::R
recfast.f90~:        end subroutine Recombination_SetDefParams
recfast.f90~:        subroutine Recombination_Validate(R, OK)
recfast.f90~:          Type(RecombinationParams),intent(in) :: R
recfast.f90~:         end subroutine Recombination_Validate
recfast.f90~:        function Recombination_tm(a)
recfast.f90~:        real(dl) zst,a,z,az,bz,Recombination_tm
recfast.f90~:        if (.not. doTmatTspin) stop 'RECFAST: Recombination_tm not stored'
recfast.f90~:            Recombination_tm=Tnow/a
recfast.f90~:          Recombination_tm=Tmrec(nz)
recfast.f90~:          Recombination_tm=az*Tmrec(ilo)+bz*Tmrec(ihi)+ &
recfast.f90~:        end function Recombination_tm
recfast.f90~:        function Recombination_ts(a)
recfast.f90~:        real(dl) zst,z,az,bz,Recombination_ts
recfast.f90~:          Recombination_ts=tsrec(1)
recfast.f90~:          Recombination_ts=tsrec(nz)
recfast.f90~:          Recombination_ts=az*tsrec(ilo)+bz*tsrec(ihi)+ &
recfast.f90~:        end function Recombination_ts
recfast.f90~:        function Recombination_xe(a)
recfast.f90~:        real(dl) zst,z,az,bz,Recombination_xe
recfast.f90~:          Recombination_xe=xrec(1)
recfast.f90~:          Recombination_xe=xrec(nz)
recfast.f90~:          Recombination_xe=az*xrec(ilo)+bz*xrec(ihi)+ &
recfast.f90~:        end function Recombination_xe
recfast.f90~:        subroutine Recombination_init(Recomb, OmegaC, OmegaB, Omegan, Omegav, h0inp,tcmb,yp, nnu, eftflag, eftmodelflag)
recfast.f90~:        !Note recfast only uses OmegaB, h0inp, tcmb and yp - others used only for Tmat approximation where effect small
recfast.f90~:        Type (RecombinationParams) :: Recomb
recfast.f90~:        real(dl), intent(in), optional :: nnu
recfast.f90~:        real(dl), dimension(:,:), allocatable :: w
recfast.f90~:           !For example if called with different reionization, or tensor rather than scalar
recfast.f90~:!       write(*,*)'recfast version 1.0'
recfast.f90~:!       write(*,*)'Using Hummer''s case B recombination rates for H'
recfast.f90~:!       write(*,*)'and tabulated HeII singlet recombination rates'
recfast.f90~:        recombination_saha_z=0.d0
recfast.f90~:!	(this is explictly for 3 massless neutrinos - change if N_nu.ne.3; but only used for approximation so not critical)
recfast.f90~:        DeltaB = h_P*C*(L_H_ion-L_H_alpha)
recfast.f90~:        DeltaB_He = h_P*C*(L_He1_ion-L_He_2s)   !2s, not 2p
recfast.f90~:        CB1 = h_P*C*L_H_ion/k_B
recfast.f90~:        CB1_He1 = h_P*C*L_He1_ion/k_B   !ionization for HeI
recfast.f90~:        CB1_He2 = h_P*C*L_He2_ion/k_B   !ionization for HeII
recfast.f90~:!       Matter departs from radiation when t(Th) > H_frac * t(H)
recfast.f90~:!       OK that's the initial conditions, now start writing output file
recfast.f90~:! Use Saha to get x_e, using the equation for x_e for ionized helium
recfast.f90~:! Everything ionized above z=8000.  First ionization over by z=5000.
recfast.f90~:! Assume He all singly ionized down to z=3500, then use He Saha until
recfast.f90~:! He is 99% singly ionized, and *then* switch to joint H/He recombination.
recfast.f90~:            call DVERK(Recomb,3,ION,zstart,y,zend,tol,ind,cw,nw,w)
recfast.f90~:            call DVERK(Recomb,nw,ION,zstart,y,zend,tol,ind,cw,nw,w)
recfast.f90~:        end subroutine Recombination_init
recfast.f90~:!       Set up the initial conditions so it will work for general,
recfast.f90~:!       Initial ionization fraction using Saha for relevant species
recfast.f90~:        subroutine ION(Recomb,Ndim,z,Y,f)
recfast.f90~:        Type (RecombinationParams) :: Recomb
recfast.f90~:!c	fit a double Gaussian correction function
recfast.f90~:    Rup_trip = Rdown_trip*dexp(-h_P*C*L_He2St_ion/(k_B*Tmat))
recfast.f90~:            recombination_saha_z = z  
recfast.f90~:!   for interest, calculate the correction factor compared to Saha
recfast.f90~:!   Modification to HeI recombination including channel via triplets
recfast.f90~:!	additional term to smooth transition to Tmat evolution,
recfast.f90~:        end subroutine ION
recfast.f90~:        function dDeltaxe_dtau(a, Delta_xe,Delta_nH, Delta_Tm, hdot, kvb)
recfast.f90~:        !d x_e/d tau assuming Helium all neutral and temperature perturbations negligible
recfast.f90~:        x_H = min(1._dl,Recombination_xe(a))
recfast.f90~:        Tmat = Recombination_tm(a)
recfast.f90~:        end function dDeltaxe_dtau
recfast.f90~:          function polevl(x,coef,N)
recfast.f90~:          end function polevl
recfast.f90~:          function derivpolevl(x,coef,N)
recfast.f90~:          end function derivpolevl
recfast.f90~:        function kappa_HH_21cm(T, deriv)
recfast.f90~:        !Polynomail fit to Hydrogen-Hydrogen collision rate as function of Tmatter, from astro-ph/0608032
recfast.f90~: !        real(dl), dimension(8), parameter :: fit = &
recfast.f90~:         integer, dimension(n_table), parameter :: Temps = &
recfast.f90~:         real, dimension(n_table), parameter :: rates = &
recfast.f90~:         real(dl), save, dimension(:), allocatable :: logRates, logTemps, ddlogRates
recfast.f90~:        end function kappa_HH_21cm
recfast.f90~:        function kappa_eH_21cm(T, deriv)
recfast.f90~:        !Polynomail fit to electron-Hydrogen collision rate as function of Tmatter; from astro-ph/0608032
recfast.f90~:         real(dl), dimension(6), parameter :: fit = &
recfast.f90~:        end function kappa_eH_21cm
recfast.f90~:        function kappa_pH_21cm(T, deriv) ! from astro-ph/0702487
recfast.f90~:        !Polynomail fit to proton-Hydrogen collision rate as function of Tmatter
recfast.f90~:         integer, dimension(n_table), parameter :: Temps = &
recfast.f90~:         real, dimension(n_table), parameter :: rates = &
recfast.f90~:         real(dl), save, dimension(:), allocatable :: logRates, logTemps, ddlogRates
recfast.f90~:        end function kappa_pH_21cm
recfast.f90~:        end module Recombination
reionization.f90:module Reionization
reionization.f90: use Precision
reionization.f90:!This module puts smooth tanh reionization of specified mid-point (z_{re}) and width
reionization.f90:!The tanh function is in the variable (1+z)**Rionization_zexp
reionization.f90:!Rionization_zexp=1.5 has the property that for the same z_{re}
reionization.f90:!the optical depth agrees with infinitely sharp model for matter domination
reionization.f90:!so could be easily modified for other monatonic parameterizations.
reionization.f90:!See CAMB notes for further discussion: http://cosmologist.info/notes/CAMB.pdf
reionization.f90:       character(LEN=*), parameter :: Reionization_Name = 'CAMB_reionization'
reionization.f90:       real(dl), parameter :: Reionization_DefFraction = -1._dl
reionization.f90:        !if -1 set from YHe assuming Hydrogen and first ionization of Helium follow each other
reionization.f90:       real(dl) :: Reionization_AccuracyBoost = 1._dl
reionization.f90:       real(dl) :: Rionization_zexp = 1.5_dl
reionization.f90:       logical :: include_helium_fullreion = .true.
reionization.f90:       real(dl) :: helium_fullreion_redshift  = 3.5_dl
reionization.f90:       real(dl) :: helium_fullreion_deltaredshift  = 0.5
reionization.f90:       real(dl) :: helium_fullreion_redshiftstart  = 5._dl
reionization.f90:       type ReionizationParams
reionization.f90:             logical    :: Reionization
reionization.f90:             real(dl)   :: redshift, delta_redshift, fraction
reionization.f90:        end type ReionizationParams
reionization.f90:        type ReionizationHistory
reionization.f90:!These two are used by main code to bound region where xe changing
reionization.f90:        end type ReionizationHistory
reionization.f90:      ! EFTCAMB MOD START: increase max reionization redshift
reionization.f90:      real(dl), parameter :: Reionization_maxz = 1000._dl
reionization.f90:      ! real(dl), parameter :: Reionization_maxz = 50._dl
reionization.f90:      real(dl), private, parameter :: Reionization_tol = 1d-5
reionization.f90:    Type(ReionizationParams), private, pointer ::  ThisReion
reionization.f90:    Type(ReionizationHistory), private, pointer :: ThisReionHist
reionization.f90: function Reionization_xe(a, tau, xe_recomb)
reionization.f90: !xe_recomb is xe(tau_start) from recombination (typically very small, ~2e-4)
reionization.f90:  real(dl), intent(in), optional :: tau, xe_recomb
reionization.f90:  real(dl) Reionization_xe
reionization.f90:        xod = (ThisReionHist%WindowVarMid - 1._dl/a**Rionization_zexp)/ThisReionHist%WindowVarDelta
reionization.f90:        Reionization_xe =(ThisReion%fraction-xstart)*(tgh+1._dl)/2._dl+xstart
reionization.f90:        if (include_helium_fullreion .and. a > (1/(1+ helium_fullreion_redshiftstart))) then
reionization.f90:         !Effect of Helium becoming fully ionized at z <~ 3.5 is very small so details not important
reionization.f90:          xod = (1+helium_fullreion_redshift - 1._dl/a)/helium_fullreion_deltaredshift
reionization.f90:        Reionization_xe =  Reionization_xe + ThisReionHist%fHe*(tgh+1._dl)/2._dl
reionization.f90: end function Reionization_xe
reionization.f90: function Reionization_timesteps(ReionHist)
reionization.f90:  Type(ReionizationHistory) :: ReionHist
reionization.f90:  integer Reionization_timesteps
reionization.f90:  Reionization_timesteps = 50
reionization.f90: end  function Reionization_timesteps
reionization.f90: subroutine Reionization_ReadParams(Reion, Ini)
reionization.f90:  Type(ReionizationParams) :: Reion
reionization.f90:   Reion%Reionization = Ini_Read_Logical_File(Ini,'reionization')
reionization.f90:   if (Reion%Reionization) then
reionization.f90:    Reion%use_optical_depth = Ini_Read_Logical_File(Ini,'re_use_optical_depth')
reionization.f90:    if (Reion%use_optical_depth) then
reionization.f90:              Reion%optical_depth = Ini_Read_Double_File(Ini,'re_optical_depth')
reionization.f90:              Reion%redshift = Ini_Read_Double_File(Ini,'re_redshift')
reionization.f90:    Reion%delta_redshift = Ini_Read_Double_File(Ini,'re_delta_redshift', 0.5_dl) !default similar to CMBFAST original
reionization.f90:    Reion%fraction = Ini_Read_Double_File(Ini,'re_ionization_frac',Reionization_DefFraction)
reionization.f90: end subroutine Reionization_ReadParams
reionization.f90: subroutine Reionization_SetParamsForZre(Reion,ReionHist)
reionization.f90:  Type(ReionizationParams), target :: Reion
reionization.f90:  Type(ReionizationHistory), target :: ReionHist
reionization.f90:       ReionHist%WindowVarMid = (1._dl+Reion%redshift)**Rionization_zexp
reionization.f90:       ReionHist%WindowVarDelta = &
reionization.f90:         Rionization_zexp*(1._dl+Reion%redshift)**(Rionization_zexp-1._dl)*Reion%delta_redshift
reionization.f90: end subroutine Reionization_SetParamsForZre
reionization.f90: subroutine Reionization_Init(Reion, ReionHist, Yhe, akthom, tau0, FeedbackLevel)
reionization.f90:  Type(ReionizationParams), target :: Reion
reionization.f90:  Type(ReionizationHistory), target :: ReionHist
reionization.f90:     ReionHist%akthom = akthom
reionization.f90:     ReionHist%fHe =  YHe/(mass_ratio_He_H*(1.d0-YHe))
reionization.f90:     ReionHist%tau_start=tau0
reionization.f90:     ReionHist%tau_complete=tau0
reionization.f90:     ThisReion => Reion
reionization.f90:     ThisReionHist => ReionHist
reionization.f90:     if (Reion%Reionization) then
reionization.f90:            if (Reion%optical_depth /= 0._dl .and. .not. Reion%use_optical_depth) &
reionization.f90:           if (Reion%use_optical_depth.and.Reion%optical_depth<0.001 &
reionization.f90:                .or. .not.Reion%use_optical_depth .and. Reion%Redshift<0.001) then
reionization.f90:               Reion%Reionization = .false.
reionization.f90:     if (Reion%Reionization) then
reionization.f90:        if (Reion%fraction==Reionization_DefFraction) &
reionization.f90:                 Reion%fraction = 1._dl + ReionHist%fHe  !H + singly ionized He
reionization.f90:       if (Reion%use_optical_depth) then
reionization.f90:        call Reionization_SetFromOptDepth(Reion,ReionHist)
reionization.f90:        if (FeedbackLevel > 0) write(*,'("Reion redshift       =  ",f6.3)') Reion%redshift
reionization.f90:       call Reionization_SetParamsForZre(ThisReion,ThisReionHist)
reionization.f90:      !this is a check, agrees very well in default parameterization
reionization.f90:            Reionization_GetOptDepth(Reion, ReionHist)
reionization.f90:       astart=1.d0/(1.d0+Reion%redshift + Reion%delta_redshift*8)
reionization.f90:       ReionHist%tau_start = max(0.05_dl, rombint(dtauda,0._dl,astart,1d-3))
reionization.f90:          !Time when a very small reionization fraction (assuming tanh fitting)
reionization.f90:       ReionHist%tau_complete = min(tau0, &
reionization.f90:          ReionHist%tau_start+ rombint(dtauda,astart,1.d0/(1.d0+max(0.d0,Reion%redshift-Reion%delta_redshift*8)),1d-3))
reionization.f90: end subroutine Reionization_Init
reionization.f90: subroutine Reionization_SetDefParams(Reion)
reionization.f90:  Type(ReionizationParams) :: Reion
reionization.f90:       Reion%Reionization = .true.
reionization.f90:       Reion%use_optical_depth = .false.
reionization.f90:       Reion%optical_depth = 0._dl
reionization.f90:       Reion%redshift = 10
reionization.f90:       Reion%fraction = Reionization_DefFraction
reionization.f90:       Reion%delta_redshift = 0.5_dl
reionization.f90: end subroutine Reionization_SetDefParams
reionization.f90: subroutine Reionization_Validate(Reion, OK)
reionization.f90:  Type(ReionizationParams),intent(in) :: Reion
reionization.f90:      if (Reion%Reionization) then
reionization.f90:        if (Reion%use_optical_depth) then
reionization.f90:            if (Reion%optical_depth<0 .or. Reion%optical_depth > 0.9  .or. &
reionization.f90:               include_helium_fullreion .and. Reion%optical_depth<0.01) then
reionization.f90:             write(*,*) 'Optical depth is strange. You have:', Reion%optical_depth
reionization.f90:            if (Reion%redshift < 0 .or. Reion%Redshift +Reion%delta_redshift*3 > Reionization_maxz .or. &
reionization.f90:              include_helium_fullreion .and. Reion%redshift < helium_fullreion_redshift) then
reionization.f90:                write(*,*) 'Reionization redshift strange. You have: ',Reion%Redshift
reionization.f90:        if (Reion%fraction/= Reionization_DefFraction .and. (Reion%fraction < 0 .or. Reion%fraction > 1.5)) then
reionization.f90:                write(*,*) 'Reionization fraction strange. You have: ',Reion%fraction
reionization.f90:        if (Reion%delta_redshift > 3 .or. Reion%delta_redshift<0.1 ) then
reionization.f90:        !Very narrow windows likely to cause problems in interpolation etc.
reionization.f90:                write(*,*) 'Reionization delta_redshift is strange. You have: ',Reion%delta_redshift
reionization.f90:  end  subroutine Reionization_Validate
reionization.f90: function Reionization_doptdepth_dz(z)
reionization.f90:   real(dl) :: Reionization_doptdepth_dz
reionization.f90:   Reionization_doptdepth_dz = Reionization_xe(a)*ThisReionHist%akthom*dtauda(a)
reionization.f90: end function Reionization_doptdepth_dz
reionization.f90:function Reionization_GetOptDepth(Reion, ReionHist)
reionization.f90: Type(ReionizationParams), target :: Reion
reionization.f90: Type(ReionizationHistory), target :: ReionHist
reionization.f90: real(dl) Reionization_GetOptDepth
reionization.f90:  ThisReion => Reion
reionization.f90:  ThisReionHist => ReionHist
reionization.f90:  Reionization_GetOptDepth = rombint2(Reionization_doptdepth_dz,0.d0,Reionization_maxz,&
reionization.f90:         Reionization_tol, 20, nint(Reionization_maxz/Reion%delta_redshift*5))
reionization.f90:end function Reionization_GetOptDepth
reionization.f90: subroutine Reionization_zreFromOptDepth(Reion, ReionHist)
reionization.f90: !Not used for Rionization_zexp = 1.5
reionization.f90:  Type(ReionizationParams) :: Reion
reionization.f90:  Type(ReionizationHistory) :: ReionHist
reionization.f90:  try_t = Reionization_maxz
reionization.f90:       Reion%redshift = (try_t + try_b)/2
reionization.f90:       call Reionization_SetParamsForZre(Reion,ReionHist)
reionization.f90:       tau = Reionization_GetOptDepth(Reion, ReionHist)
reionization.f90:       if (tau > Reion%optical_depth) then
reionization.f90:                  try_t = Reion%redshift
reionization.f90:                  try_b = Reion%redshift
reionization.f90:       if (abs(try_b - try_t) < 2e-3/Reionization_AccuracyBoost) exit
reionization.f90:       if (i>100) call mpiStop('Reionization_zreFromOptDepth: failed to converge')
reionization.f90:   if (abs(tau - Reion%optical_depth) > 0.002) then
reionization.f90:    write (*,*) 'Reionization_zreFromOptDepth: Did not converge to optical depth'
reionization.f90:    write (*,*) 'tau =',tau, 'optical_depth = ', Reion%optical_depth
reionization.f90: end subroutine Reionization_zreFromOptDepth
reionization.f90: subroutine Reionization_SetFromOptDepth(Reion, ReionHist)
reionization.f90:  Type(ReionizationParams) :: Reion
reionization.f90:  Type(ReionizationHistory) :: ReionHist
reionization.f90:! This subroutine calculates the redshift of reionization
reionization.f90:! This implementation is approximate but quite accurate and fast
reionization.f90:      Reion%redshift = 0
reionization.f90:      if (Reion%Reionization .and. Reion%optical_depth /= 0) then
reionization.f90:           call Reionization_zreFromOptDepth(Reion, ReionHist)
reionization.f90:            dz=1._dl/2000/Reionization_AccuracyBoost
reionization.f90:            tmp = dz*Reion%fraction*ThisReionHist%akthom
reionization.f90:            tmpHe = dz*(Reion%fraction+ReionHist%fHe)*ThisReionHist%akthom
reionization.f90:            do while (optd < Reion%optical_depth)
reionization.f90:                if (include_helium_fullreion .and. z < helium_fullreion_redshift) then
reionization.f90:         Reion%Reionization = .false.
reionization.f90: end  subroutine Reionization_SetFromOptDepth
reionization.f90:end module Reionization
Binary file Release/bessels.o matches
Binary file Release/bispectrum.mod matches
Binary file Release/camb.mod matches
Binary file Release/camb.o matches
Binary file Release/cambmain.mod matches
Binary file Release/cmbmain.o matches
Binary file Release/constants.mod matches
Binary file Release/constants.o matches
Binary file Release/EFT_def.o matches
Binary file Release/EFT_designer.o matches
Binary file Release/EFT_functions.o matches
Binary file Release/EFT_Horndeski.o matches
Binary file Release/EFT_main.o matches
Binary file Release/eftdeeos.mod matches
Binary file Release/eftdef.mod matches
Binary file Release/eftdesigner.mod matches
Binary file Release/eftfunctions.mod matches
Binary file Release/eftinitialization.mod matches
Binary file Release/eftreturntogr.mod matches
Binary file Release/eftstability.mod matches
Binary file Release/equations_EFT.o matches
Binary file Release/errors.mod matches
Binary file Release/gaugeinterface.mod matches
Binary file Release/halofit_ppf.o matches
Binary file Release/inifile.o matches
Binary file Release/initialpower.mod matches
Binary file Release/lambdageneral.mod matches
Binary file Release/lensing.mod matches
Binary file Release/lensing.o matches
Binary file Release/lvalues.mod matches
Binary file Release/massivenu.mod matches
Binary file Release/modeldata.mod matches
Binary file Release/modelparams.mod matches
Binary file Release/modules.o matches
Binary file Release/nonlinear.mod matches
Binary file Release/power_tilt.o matches
Binary file Release/precision.mod matches
Binary file Release/random.mod matches
Binary file Release/ranges.mod matches
Binary file Release/recdata.mod matches
Binary file Release/recfast.o matches
Binary file Release/recombination.mod matches
Binary file Release/reionization.mod matches
Binary file Release/reionization.o matches
Binary file Release/rph_to_eft.mod matches
Binary file Release/rphfunctions.mod matches
Binary file Release/SeparableBispectrum.o matches
Binary file Release/spherbessels.mod matches
Binary file Release/subroutines.o matches
Binary file Release/thermodata.mod matches
Binary file Release/transfer.mod matches
Binary file Release/utils.o matches
residues.f90:function Hdotbd(a,phi,phiprime,om,omr,H0,arglamda) !d H/dt
residues.f90:end function Hdotbd
residues.f90:function Hdotdotbd(a,phi,phiprime,om,omr,H0,arglamda) !d^2 H/dt^2
residues.f90:end function Hdotdotbd
residues.f90:function Hdtaubd(a,phi,phiprime,om,omr,H0,arglamda) !d H/ d tau
residues.f90:end function Hdtaubd    
residues.f90:function Hdtaudtaubd(a,phi,phiprime,om,omr,H0,arglamda) !d^2 H/ dtau^2
residues.f90:end function Hdtaudtaubd
residues.f90:function dedensitybd(a,phi,phiprime,om,omr,H0,arglamda)
residues.f90:function phidotdot(phi,phiprime,a,om,omr,H0,arglamda) !in physical time
residues.f90:end function phidotdot
residues.f90~:function Hdotbd(a,phi,phiprime,om,omr,H0,arglamda) !d H/dt
residues.f90~:end function Hdotbd
residues.f90~:function Hdotdotbd(a,phi,phiprime,om,omr,H0,arglamda) !d^2 H/dt^2
residues.f90~:end function Hdotdotbd
residues.f90~:function Hdtaubd(a,phi,phiprime,om,omr,H0,arglamda) !d H/ d tau
residues.f90~:end function Hdtaubd    
residues.f90~:function Hdtaudtaubd(a,phi,phiprime,om,omr,H0,arglamda) !d^2 H/ dtau^2
residues.f90~:end function Hdtaudtaubd
residues.f90~:function dedensitybd(a,phi,phiprime,om,omr,H0,arglamda)
SeparableBispectrum.F90:!First version AL October 2010
SeparableBispectrum.F90:!CMB lensing bispectra are calculated in the approximation in which the first-order
SeparableBispectrum.F90:         ! j_l' array for interpolation if needed; not needed for local fnl
SeparableBispectrum.F90:         !functions of the form int dk k^2 k^i j_l(kr) Delta_l(k) [P]
SeparableBispectrum.F90:         !functions of the form int dk k^2 k^i j_l(kr) Delta_l(k) [P]
SeparableBispectrum.F90:          Type(Regions) :: TimeStepsNongauss
SeparableBispectrum.F90:              !For use in Fisher approximations 
SeparableBispectrum.F90:            !assume C^{T\psi} zero above this for CMB lensing; also neglect lensing contributions to variance
SeparableBispectrum.F90:                 !set correlations to zero where very small to avoid numerical issues
SeparableBispectrum.F90:           npd=0 !derivatives of function
SeparableBispectrum.F90:               !Note that all the points outside recombination are not really needed
SeparableBispectrum.F90:               !And these are for curvature perturbation, so do not include 3/5 factor
SeparableBispectrum.F90:          Noise = BispectrumParams%FisherNoise/ (COBE_CMBTemp*1e6)**2  !Planckish, dimensionless units  
SeparableBispectrum.F90:!!!! contribution of lensing to the fnl variance for temperature:
SeparableBispectrum.F90:!              print *,'signal contribution to fnl variance', sum(fish_contribs_sig)/Fisher(bispectrum_type,bispectrum_type2)**2
SeparableBispectrum.F90: !!! same with polarization
SeparableBispectrum.F90:           print *,'Zero-signal Bispectrum correlation matrix:'
SeparableBispectrum.F90:           print *,'Optimal Bispectrum correlation matrix with lensing variance:'
SeparableBispectrum.F90:        !As above, but integral against derivative of bessel function to get derivative of function
SeparableBispectrum.F90:          if (B%nfields /= 2 .and. B%nfields/=1) stop 'Bispectrum: nfields=1 for T only or 2 for polarization'
SeparableBispectrum.F90:             write(*,*) 'Ignoring do_parity_odd since do_lensing_bispectrum=F or no polarization'
sigma8.f90:     !Simple test program to print out sigma_8 as a function of the CDM density
sigma8.f90:        P%Transfer%high_precision=.false.
subroutines.f90:        use Precision
subroutines.f90:        real(dl), allocatable, dimension(:) :: f
subroutines.f90:        use Precision
subroutines.f90:        function rombint2(f,a,b,tol, maxit, minsteps)
subroutines.f90:        use precision
subroutines.f90:!  Rombint returns the integral from a to b of using Romberg integration.
subroutines.f90:! Modified by AL to specify max iterations and minimum number of steps
subroutines.f90:! (min steps useful to stop wrong results on periodic or sharp functions)
subroutines.f90:        dimension g(MAXJ+1)
subroutines.f90:!  Calculate next trapezoidal rule approximation to integral.
subroutines.f90:!  Use Richardson extrapolation.
subroutines.f90:        end function rombint2
subroutines.f90:        function rombint(f,a,b,tol)
subroutines.f90:        use Precision
subroutines.f90:!  Rombint returns the integral from a to b of using Romberg integration.
subroutines.f90:        dimension g(MAXJ+1)
subroutines.f90:!  Calculate next trapezoidal rule approximation to integral.
subroutines.f90:!  Use Richardson extrapolation.
subroutines.f90:        end function rombint
subroutines.f90:        function rombint_obj(obj,f,a,b,tol, maxit)
subroutines.f90:        use Precision
subroutines.f90:!  Rombint returns the integral from a to b of using Romberg integration.
subroutines.f90:        integer, intent(in), optional :: maxit
subroutines.f90:        dimension g(MAXJ+1)
subroutines.f90:!  Calculate next trapezoidal rule approximation to integral.
subroutines.f90:!  Use Richardson extrapolation.
subroutines.f90:        end function rombint_obj
subroutines.f90:! interpolation. y2 is array of second derivatives, yp1 and ypn are first
subroutines.f90:      use Precision
subroutines.f90:      use Precision
subroutines.f90:       use Precision
subroutines.f90:        use Precision
subroutines.f90:!This version is modified to pass an object parameter to the function on each call
subroutines.f90:!Fortunately Fortran doesn't do type checking on functions, so we can pretend the
subroutines.f90:      use Precision
subroutines.f90:! set for a  vax  in  double  precision.  they  should  be  reset,  as *
subroutines.f90:! fifth and sixth order pair of formulas for finding approximations to *
subroutines.f90:! the solution of  a  system  of  first  order  ordinary  differential *
subroutines.f90:! equations  with  initial  conditions. it attempts to keep the global *
subroutines.f90:! error proportional to  a  tolerance  specified  by  the  user.  (the *
subroutines.f90:! proportionality  depends  on the kind of error control that is used, *
subroutines.f90:! as well as the differential equation and the range of integration.)  *
subroutines.f90:!     various options are available to the user,  including  different *
subroutines.f90:! kinds  of  error control, restrictions on step sizes, and interrupts *
subroutines.f90:! which permit the user to examine the state of the  calculation  (and *
subroutines.f90:! perhaps make modifications) during intermediate stages.              *
subroutines.f90:! function evaluations are very costly.  such a method would  also  be *
subroutines.f90:! solution values by interpolation, as might be the case  for  example *
subroutines.f90:!     n  number of equations                                           *
subroutines.f90:!   fcn  name of subroutine for evaluating functions - the  subroutine *
subroutines.f90:!  xend  value of x to which integration is to be carried out - it may *
subroutines.f90:!           proportional to tol. in some problems there will be enough *
subroutines.f90:!           damping  of  errors, as well as some cancellation, so that *
subroutines.f90:!           calculated value of y at xend which is the exact  solution *
subroutines.f90:!           is proportional to tol.  (the norm  is  a  max  norm  with *
subroutines.f90:!           1  or  2. if the user does not wish to use any options, he *
subroutines.f90:!           may also  select  various  options  on  initial  entry  by *
subroutines.f90:!           c as described in the next section.  he may also  re-enter *
subroutines.f90:!           the  subroutine  with ind = 3 as mentioned again below. in *
subroutines.f90:!              4, 5, or 6 after an interrupt (see options c(8), c(9))  *
subroutines.f90:!              -1, -2, or -3 after an error condition (see below)      *
subroutines.f90:!     c  communications vector - the dimension must be greater than or *
subroutines.f90:!           equal to 24, unless option c(1) = 4 or 5 is used, in which *
subroutines.f90:!           case the dimension must be greater than or equal to n+30   *
subroutines.f90:!    nw  first dimension of workspace w -  must  be  greater  than  or *
subroutines.f90:!     w  workspace matrix - first dimension must be nw and second must *
subroutines.f90:! of xend and an approximation to y at xend.  the  subroutine  can  be *
subroutines.f90:! any other argument.  however, changes in tol, or any of the  options *
subroutines.f90:!        calculation of hmin) is too small                             *
subroutines.f90:!     with ind = -1 the allowed maximum number of fcn evaluations  has *
subroutines.f90:!        been  exceeded,  but  this  can only occur if option c(7), as *
subroutines.f90:!        described in the next section, has been used                  *
subroutines.f90:!     there are several circumstances that will cause the calculations *
subroutines.f90:! to  be  terminated,  along with output of information that will help *
subroutines.f90:!     options - if the subroutine is entered with ind = 1, the first 9 *
subroutines.f90:! components of the communications vector are initialized to zero, and *
subroutines.f90:! the subroutine uses only default values  for  each  option.  if  the *
subroutines.f90:! options he wishes to select. in any event, options may be changed on *
subroutines.f90:! options, or tol, in the course of a calculation he should be careful *
subroutines.f90:! program  -  the information is available to the user, but should not *
subroutines.f90:!                 1/max(1,abs(y(k))), as mentioned earlier             *
subroutines.f90:!           dimension of c to be at least n+30 and must initialize the *
subroutines.f90:!  c(3)  hmin specification - if not zero, the subroutine chooses hmin *
subroutines.f90:!  c(4)  hstart specification - if not zero, the subroutine  will  use *
subroutines.f90:!           the restrictions imposed by hmin and hmax  -  otherwise it *
subroutines.f90:!  c(5)  scale specification - this is intended to be a measure of the *
subroutines.f90:!           approximation to  an  average  value  of  a  norm  of  the *
subroutines.f90:!  c(6)  hmax specification - four cases are possible                  *
subroutines.f90:!  c(7)  maximum number of function evaluations  -  if  not  zero,  an *
subroutines.f90:!           of function evaluations exceeds abs(c(7))                  *
subroutines.f90:!           interrupt   the  calculations  after  it  has  chosen  its *
subroutines.f90:!           and  xtrial  in  preparation for taking a step (htrial may *
subroutines.f90:!           will resume calculation at the point  of  interruption  if *
subroutines.f90:!           interrupt   the  calculations  immediately  after  it  has *
subroutines.f90:!           the  subroutine  will  resume calculations at the point of *
subroutines.f90:!           interruption on re-entry with ind = 5 or 6. (the user  may *
subroutines.f90:!  summary of the components of the communications vector              *
subroutines.f90:!     prescribed at the option       determined by the program         *
subroutines.f90:!     c(3) hmin specification        c(13) hmin                        *
subroutines.f90:!     c(4) hstart specification      c(14) hmag                        *
subroutines.f90:!     c(5) scale specification       c(15) scale                       *
subroutines.f90:!     c(6) hmax specification        c(16) hmax                        *
subroutines.f90:!     begin initialization, parameter checking, interrupt re-entries   *
subroutines.f90:!  .        if initial entry without options (ind .eq. 1)              *
subroutines.f90:!  .        else initial entry with options (ind .eq. 2)               *
subroutines.f90:!  .  end initialization, etc.                                      .  *
subroutines.f90:!  .     stage 4 - make decisions                                   .  *
subroutines.f90:!  begin abort action                                                  *
subroutines.f90:!     output appropriate  message  about  stopping  the  calculations, *
subroutines.f90:!  end abort action                                                    *
subroutines.f90:!     * begin initialization, parameter checking, interrupt re-entries *
subroutines.f90:!              initial entry without options (ind .eq. 1)
subroutines.f90:!              initial entry with options (ind .eq. 2)
subroutines.f90:!     end initialization, etc.
subroutines.f90:!        * stage 1 - prepare - do calculations of  hmin,  hmax,  etc., *
subroutines.f90:!        * values of hmag, xtrial and htrial in preparation for taking *
subroutines.f90:!        * an integration step.                                        *
subroutines.f90:!              overflow. then avoid reduction by more than half.
subroutines.f90:!           calculate ytrial, the extrapolated approximation and store
subroutines.f90:!        * step) for the unextrapolated approximation and store it  in *
subroutines.f90:!        * unit step) for the extrapolated approximation ytrial.       *
subroutines.f90:!        * stage 4 - make decisions.                                   *
subroutines.f90:!  begin abort action
subroutines.f90:!  end abort action
subroutines.f90:!      This is used to solve numerically the equation func=funcZero by means of the Brent method.
subroutines.f90:function zbrent(func,x1,x2,tol,funcZero,succes)
subroutines.f90:    use precision
subroutines.f90:    integer ,parameter :: ITMAX = 2000  !Max Number of iterations.
subroutines.f90:end function zbrent
subroutines.f90:!      a bisection algorithm.
subroutines.f90:    use precision
subroutines.f90:!      of the equation func=funcZero
subroutines.f90:    ! func     = function to find the root of                           (in);
subroutines.f90:    use precision
subroutines.f90:!      This is used to interpolate the EFT functions once the designer/mapping
subroutines.f90:    ! ypl  = value of the interpolated function at xpl              (out)
subroutines.f90:    use precision
subroutines.f90:!      This is a very simple algorithm that is used to solve the designer equation.
subroutines.f90:    ! n     = dimensionality of the problem;
subroutines.f90:    ! y     = 'position' at t=x;
subroutines.f90:    ! yout  = 'position' at t=x+h computed using fourth order Runge-Kutta;
subroutines.f90:    use precision
subroutines.f90:    real(dl), dimension(n) :: y, dydx, yout
subroutines.f90:        use precision
subroutines.f90:            real(dl), dimension(n) :: y
subroutines.f90:            real(dl), dimension(n) :: dydx
subroutines.f90:    real(dl), dimension(n) :: yt, dyt,dym
tester.f90:        P%OutputNormalization = outNone
tester.f90:        P%AccuratePolarization = .false. !We are only interested in the temperature here
test_params.ini:EFTAdditionalPriors = T
test_params.ini:helium_fraction = 0.24271
test_params.ini:transfer_high_precision = F
test_params.ini:reionization = T
test_params.ini:re_ionization_frac = -1
test_params.ini:initial_condition = 1
test_params.ini:accurate_polarization = T
test_params.ini:accurate_reionization = T
test_params.ini:version_check = Feb15
test_params.ini:do_late_rad_truncation = T
ttplot_unlens.py:#Observational data
ttplot_unlens.py~:#Observational data
ttplot_unlens_several_compare.py:#Observational data
ttplot_unlens_several_compare.py~:#Observational data
utils.F90:!Module of generally useful routines and definitions
utils.F90: !A collection of ranges, consisting of sections of minimum step size
utils.F90:  double precision, parameter :: RangeTol = 0.1d0 
utils.F90:    !fraction of bin width we are prepared for merged bin widths to increase by
utils.F90:  Type Region
utils.F90:    double precision Low, High
utils.F90:    double precision delta
utils.F90:    double precision delta_max, delta_min !for log spacing, the non-log max and min step size
utils.F90:  end Type Region
utils.F90:  Type Regions
utils.F90:     double precision Lowest, Highest
utils.F90:     Type(Region) :: R(Max_ranges)
utils.F90:     double precision, dimension(:), pointer :: points, dpoints
utils.F90:  end Type Regions
utils.F90:    Type(Regions) R
utils.F90:    Type(Regions) R
utils.F90:   Type(Regions) R
utils.F90:   Type(Regions) R, Rin
utils.F90:   function Ranges_IndexOf(Reg, tau) result(pointstep)
utils.F90:      Type(Regions), intent(in), target :: Reg
utils.F90:      Type(Region), pointer :: AReg
utils.F90:      double precision :: tau
utils.F90:   end function Ranges_IndexOf
utils.F90:     Type(Regions), target :: Reg
utils.F90:     Type(Region), pointer :: AReg
utils.F90:     logical, intent(in), optional :: want_dpoints 
utils.F90:      Type(Regions), target :: Reg
utils.F90:      logical, intent(in), optional :: half_ends
utils.F90:     Type(Regions), target :: Reg
utils.F90:     logical, intent(in), optional :: IsLog
utils.F90:     double precision, intent(in) :: t_start, t_end, t_approx_delta
utils.F90:     Type(Regions), target :: Reg
utils.F90:     logical, intent(in), optional :: IsLog
utils.F90:     double precision, intent(in) :: t_start, t_end
utils.F90:     Type(Region), pointer :: AReg, LastReg
utils.F90:     Type(Region), target :: NewRegions(Max_Ranges)
utils.F90:     double precision EndPoints(0:Max_Ranges*2)
utils.F90:     double precision delta
utils.F90:     double precision min_request, max_request, min_log_step, max_log_step, diff, max_delta
utils.F90:     double precision RequestDelta(Max_Ranges)
utils.F90:!    if (Reg%count > 0) NewRegions(1:Reg%count) = Reg%R(1:Reg%count)
utils.F90:         NewRegions(i) = Reg%R(i)
utils.F90:     AReg=> NewRegions(nreg)
utils.F90:       AReg => NewRegions(i)
utils.F90:           if (AReg%Low >= NewRegions(j)%Low .and. Areg%Low < NewRegions(j)%High) then
utils.F90:             if (NewRegions(j)%IsLog) then
utils.F90:                 delta = min(delta,NewRegions(j)%delta) 
utils.F90:                 min_log_step = AReg%Low*(exp(NewRegions(j)%delta)-1)
utils.F90:                   max_log_step = AReg%High*(1-exp(-NewRegions(j)%delta)) 
utils.F90:                     delta = NewRegions(j)%delta 
utils.F90:             else !NewRegion is not log
utils.F90:                if (NewRegions(j)%delta < max_log_step) then
utils.F90:                  if (min_log_step <  NewRegions(j)%delta) then
utils.F90:                     delta = - log(1- NewRegions(j)%delta/AReg%High)
utils.F90:               delta = min(delta, NewRegions(j)%delta)  
utils.F90:!Get rid of tiny regions
utils.F90:      Type(Regions), intent(in), target :: Reg
utils.F90:      Type(Region), pointer :: AReg
utils.F90:    real, dimension(:), pointer :: p 
utils.F90:    double precision, dimension(:), pointer :: p 
utils.F90:    character, dimension(:), pointer :: p
utils.F90:    type(Real_Pointer), dimension(:), pointer :: Items 
utils.F90:    type(String_Pointer), dimension(:), pointer :: Items
utils.F90:    type(Real_Pointer), dimension(:), pointer :: TmpItems
utils.F90:    type(Real_Pointer), dimension(:), pointer :: TmpItems
utils.F90:     real, intent(OUT), optional :: Lower, Upper
utils.F90:     integer, intent(IN), optional :: ix1,ix2
utils.F90:     type(Real_Pointer), dimension(:), pointer :: SortItems
utils.F90:    character(Len=*), intent(in), optional :: valid_chars_in
utils.F90:   function TStringList_Item(L, i) result(S)
utils.F90:   end function TStringList_Item
utils.F90:    type(String_Pointer), dimension(:), pointer :: TmpItems
utils.F90:   function TStringList_IndexOf(L, S)
utils.F90:   end function TStringList_IndexOf
utils.F90:      type(real_pointer), dimension(:) :: Arr
utils.F90:      type(real_pointer), dimension(*) :: Arr
utils.F90:      type(double_pointer), dimension(:) :: Arr
utils.F90:      type(double_pointer), dimension(*) :: Arr
utils.F90:      double precision P
utils.F90:  double precision, parameter :: pi=3.14159265358979323846264338328d0, &
utils.F90:  double precision, parameter :: root2 = 1.41421356237309504880168872421d0, sqrt2 = root2
utils.F90:  double precision, parameter :: log2 = 0.693147180559945309417232121458d0
utils.F90: function new_file_unit()
utils.F90: end function new_file_unit
utils.F90:  function GetParamCount()
utils.F90:  end function GetParamCount
utils.F90:  function GetMpiRank()
utils.F90:  end function GetMpiRank
utils.F90:  function IsMainMPI()
utils.F90:  end function IsMainMPI
utils.F90:   character(LEN=*), intent(in), optional :: Msg
utils.F90:  function iargc ()
utils.F90:  end function iargc
utils.F90:  function GetParam(i)
utils.F90:  end function GetParam
utils.F90:  function concat_s(S1,S2,S3,S4,S5,S6,S7,S8) result(concat)
utils.F90:   character(LEN=*), intent(in) , optional :: S3, S4, S5, S6,S7,S8
utils.F90:  end function concat_s
utils.F90: function concat_s_n(SS1,N2,SS3,N4,SS5,N6,SS7,N8,SS9,N10,SS11) result(concat)
utils.F90:   character(LEN=*), intent(in) , optional :: SS3, SS5, SS7, SS9,SS11
utils.F90:   integer, intent(in), optional ::N4,N6,N8, N10
utils.F90: end  function concat_s_n
utils.F90:  function numcat(S, num)
utils.F90:  end function numcat
utils.F90:  function LogicalToint(B)
utils.F90:  end function LogicalToInt
utils.F90:  function IntToLogical(I)
utils.F90:  end  function IntToLogical
utils.F90:  function IntToStr(I, minlen)
utils.F90:   integer, intent(in), optional :: minlen
utils.F90:  end function IntToStr
utils.F90:  function StrToInt(S)
utils.F90:  end function StrToInt
utils.F90:   function DoubleToStr(R, figs)
utils.F90:      double precision, intent(in) :: R
utils.F90:      integer, intent(in), optional :: figs
utils.F90:   end function DoubleToStr
utils.F90:   function SingleToStr(R, figs)
utils.F90:   integer, intent(in), optional :: figs
utils.F90:   end function SingleToStr
utils.F90:     integer, intent(in),optional :: i2,i3,i4
utils.F90:  function IndexOf(aval,arr, n)
utils.F90:  end function IndexOf
utils.F90:  function MaxIndex(arr, n)
utils.F90:  end function MaxIndex
utils.F90:  function MinIndex(arr, n)
utils.F90:  end function MinIndex
utils.F90:  function ExtractFilePath(aname)
utils.F90:  end function ExtractFilePath
utils.F90:  function ExtractFileExt(aname)
utils.F90:  end function ExtractFileExt
utils.F90: function ExtractFileName(aname)
utils.F90:  end function ExtractFileName
utils.F90: function ChangeFileExt(aname,ext)
utils.F90:  end function ChangeFileExt
utils.F90:  function CheckTrailingSlash(aname)
utils.F90:  end  function CheckTrailingSlash
utils.F90:  function FileExists(aname)
utils.F90:  end function FileExists
utils.F90:   open(unit=aunit,file=aname,form=mode,status='old', action='read', err=500)
utils.F90:   logical, optional, intent(in) :: append
utils.F90:   logical, optional, intent(in) :: append
utils.F90:     open(unit=aunit,file=aname,form=mode,status='unknown', err=500, position='append')
utils.F90: function TxtNumberColumns(InLine) result(n)
utils.F90: end function TxtNumberColumns
utils.F90:  function TxtColumns(InLine) result(n)
utils.F90: end function TxtColumns
utils.F90: function FileColumns(aunit) result(n)
utils.F90: end function FileColumns
utils.F90: function FileLines(aunit) result(n)
utils.F90: end function FileLines
utils.F90: function TopCommentLine(aname) result(res)
utils.F90: end function TopCommentLine
utils.F90: function TxtFileColumns(aname) result(n)
utils.F90: end function TxtFileColumns
utils.F90: function LastFileLine(aname)
utils.F90: end function LastFileLine
utils.F90:      real(dp), dimension(:), allocatable :: u
utils.F90:      real(dp), dimension(:), allocatable :: u
utils.F90:      function DLGAMMA(x)
utils.F90:       !Use Stirling generalization for large x
utils.F90:       !See e.g. http://en.wikipedia.org/wiki/Stirling's_approximation
utils.F90:       double precision :: x
utils.F90:       double precision:: DLGAMMA !approx log gamma
utils.F90:       double precision, parameter :: const = .91893853320467274180d0 !log(2pi)/2
utils.F90:      end function DLGAMMA
utils.F90:      function LogGamma(x)
utils.F90:        if (abs(i-x*2) > 1e-4) call MpiStop('LogGamma function for half integral only')
utils.F90:      end function LogGamma
utils.F90:    DOUBLE PRECISION FUNCTION GAMMA(X)
utils.F90:! This routine calculates the GAMMA function for a real argument X.
utils.F90:!   Computation is based on an algorithm outlined in reference 1.
utils.F90:!   The program uses rational functions that approximate the GAMMA
utils.F90:!   function to at least 20 significant decimal digits.  Coefficients
utils.F90:!   for the approximation over the interval (1,2) are unpublished.
utils.F90:!   Those for the approximation for X .GE. 12 are from reference 2.
utils.F90:!   compiler, the intrinsic functions, and proper selection of the
utils.F90:! Explanation of machine-dependent constants
utils.F90:! beta   - radix for the floating-point representation
utils.F90:!          in the machine, i.e., the solution to the equation
utils.F90:!     when overflow would occur.  The computation is believed
utils.F90:!  Intrinsic functions required are:
utils.F90:!              Functions", W. J. Cody, Lecture Notes in Mathemati,
utils.F90:!              Computer Approximations, Hart, Et. Al., Wiley and
utils.F90:!  Latest modification: October 12, 1989
utils.F90:!           Applied Mathemati Division
utils.F90:!           Argonne National Laboratory
utils.F90:    DOUBLE PRECISION C,EPS,FACT,HALF,ONE,P,PI,Q,RES,SQRTPI,SUM,TWELVE, &
utils.F90:      DIMENSION C(7),P(8),Q(8)
utils.F90:!  Numerator and denominator coefficients for rational minimax
utils.F90:!     approximation over (1,2).
utils.F90:! Coefficients for minimax approximation over (12, INF).
utils.F90:!  Statement functions for conversion between integer and float
utils.F90:!  Evaluate approximation for 1.0 .LT. argument .LT. 2.0
utils.F90:      END FUNCTION GAMMA
utils.F90:      !Recursive evaluation of 3j symbols. Does minimal error checking on input parameters.
utils.F90:      real(dl), dimension(*) :: thrcof
utils.F90:    ! by recursion from l1min = max(abs(l2-l3),abs(m1)) 
utils.F90:    ! to achieve the numerical stability, the recursion will proceed
utils.F90:    ! lmatch is the l1-value at which forward and backward recursion are matched.
utils.F90:    ! starting forward recursion from l1min taking nstep1 steps
utils.F90:    ! if l1=l1min+1 the third term in the recursion eqn vanishes, hence
utils.F90:    ! recursion to the next 3j-coeff x  
utils.F90:         ! SO THAT THE RECURSION SERIES THRCOF(1), ... , THRCOF(LSTEP)
utils.F90:    ! as long as abs(c1) is decreasing, the recursion proceeds towards increasing
utils.F90:    ! detected, the recursion direction is reversed.
utils.F90:    ! keep three 3j-coeffs around lmatch for comparison with backward recursion
utils.F90:    ! starting backward recursion from l1max taking nstep2 stpes, so that
utils.F90:    ! forward and backward recursion overlap at 3 points 
utils.F90:         ! if l2=l2max+1, the third term in the recursion vanishes
utils.F90:    ! recursion to the next 3j-coeff y
utils.F90:         ! reached if 3j-coeff larger than srhuge so that the recursion series
utils.F90:    ! the forward recursion 3j-coeffs x1, x2, x3 are to be matched with the 
utils.F90:    ! corresponding backward recursion vals y1, y2, y3
utils.F90:    ! sign convention for last 3j-coeff determines overall phase
utils.F90:! Latest version - 1 January 2001
utils.F90:FUNCTION shr3( ) RESULT( ival )
utils.F90:END FUNCTION shr3
utils.F90:FUNCTION uni( ) RESULT( fn_val )
utils.F90:END FUNCTION uni
utils.F90:FUNCTION rnor( ) RESULT( fn_val )
utils.F90:END FUNCTION rnor
utils.F90:FUNCTION rexp( ) RESULT( fn_val )
utils.F90:END FUNCTION rexp
utils.F90:  INTERFACE RandRotation
utils.F90:  MODULE PROCEDURE RandRotationS, RandRotationD
utils.F90:  integer, optional, intent(IN) :: i
utils.F90:  integer, optional, intent(IN) :: i2
utils.F90:  subroutine RandRotationS(R, N)
utils.F90:   !this is most certainly not the world's most efficient or robust random rotation generator
utils.F90:  end subroutine RandRotationS
utils.F90:  subroutine RandRotationD(R, N)
utils.F90:   !this is most certainly not the world's most efficient or robust random rotation generator
utils.F90:    double precision R(N,N), vec(N), norm
utils.F90:  end subroutine RandRotationD
utils.F90:  double precision function GAUSSIAN1()
utils.F90:    double precision R, V1, V2, FAC
utils.F90:    double precision, save :: gset
utils.F90:      end function GAUSSIAN1
utils.F90:     double precision function CAUCHY1()
utils.F90:     end function CAUCHY1
utils.F90:     real FUNCTION RANDEXP1()
utils.F90:!     Random-number generator for the exponential distribution
utils.F90:!     Communications of the ACM, 31 (1988) 1330--1337.
utils.F90:!     Coded by K. G. Hamilton, December 1996, with corrections.
utils.F90:      end function randexp1
utils.F90:!   representation). 
utils.F90:! The algorithm is a combination of a Fibonacci sequence (with lags of 97
utils.F90:!   and 33, and operation "subtraction plus one, modulo one") and an 
utils.F90:!   "arithmetic sequence" (using subtraction).
utils.F90:! Do the initialization
utils.F90:! This is the initialization routine for the random number generator RANMAR()
utils.F90:! length to complete an entire calculation with. For example, if sveral 
utils.F90:! different groups are working on different parts of the same calculation,
utils.F90:! number generator can create 900 million different subsequences -- with 
utils.F90:      double precision U(97), C, CD, CM, S, T
utils.F90:      double precision function RANMAR()
utils.F90:      double precision U(97), C, CD, CM
utils.F90:       double precision uni
utils.F90:      end function RANMAR
VisualStudio/CAMB.sln:Microsoft Visual Studio Solution File, Format Version 12.00
VisualStudio/CAMB.sln:VisualStudioVersion = 12.0.31101.0
VisualStudio/CAMB.sln:MinimumVisualStudioVersion = 10.0.40219.1
VisualStudio/CAMB.sln:	ProjectSection(ProjectDependencies) = postProject
VisualStudio/CAMB.sln:	EndProjectSection
VisualStudio/CAMB.sln:	ProjectSection(ProjectDependencies) = postProject
VisualStudio/CAMB.sln:	EndProjectSection
VisualStudio/CAMB.sln:	ProjectSection(ProjectDependencies) = postProject
VisualStudio/CAMB.sln:	EndProjectSection
VisualStudio/CAMB.sln:	GlobalSection(SolutionConfigurationPlatforms) = preSolution
VisualStudio/CAMB.sln:	EndGlobalSection
VisualStudio/CAMB.sln:	GlobalSection(ProjectConfigurationPlatforms) = postSolution
VisualStudio/CAMB.sln:	EndGlobalSection
VisualStudio/CAMB.sln:	GlobalSection(SolutionProperties) = preSolution
VisualStudio/CAMB.sln:		HideSolutionNode = FALSE
VisualStudio/CAMB.sln:	EndGlobalSection
VisualStudio/CAMB_devel.vfproj:<?xml version="1.0" encoding="UTF-8"?>
VisualStudio/CAMB_devel.vfproj:<VisualStudioProject ProjectCreator="Intel Fortran" Keyword="Console Application" Version="11.0" ProjectIdGuid="{207BF71A-E457-49F3-BEC8-B2F9E85F74BA}">
VisualStudio/CAMB_devel.vfproj:	<Configurations>
VisualStudio/CAMB_devel.vfproj:		<Configuration Name="Debug|Win32" CommandArguments="params.ini" WorkingDirectory="../">
VisualStudio/CAMB_devel.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" PreprocessorDefinitions="FISHER" ErrorLimit="4" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug" UseMkl="mklParallel"/>
VisualStudio/CAMB_devel.vfproj:				<Tool Name="VFLinkerTool" LinkIncremental="linkIncrementalNo" SuppressStartupBanner="true" GenerateDebugInformation="true" SubSystem="subSystemConsole"/>
VisualStudio/CAMB_devel.vfproj:				<Tool Name="VFManifestTool" SuppressStartupBanner="true"/></Configuration>
VisualStudio/CAMB_devel.vfproj:		<Configuration Name="Release|Win32" CommandArguments="params.ini" WorkingDirectory="../">
VisualStudio/CAMB_devel.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" UseProcessorExtensions="codeExclusivelyHost" Preprocess="preprocessYes" PreprocessorDefinitions="FISHER" OpenMP="OpenMPParallelCode" ErrorLimit="4" UseMkl="mklParallel"/>
VisualStudio/CAMB_devel.vfproj:				<Tool Name="VFManifestTool" SuppressStartupBanner="true"/></Configuration>
VisualStudio/CAMB_devel.vfproj:		<Configuration Name="Debug|x64" CommandArguments="params.ini" WorkingDirectory="../">
VisualStudio/CAMB_devel.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" PreprocessorDefinitions="FISHER" OpenMP="OpenMPParallelCode" ErrorLimit="4" WarnDeclarations="true" WarnUnusedVariables="true" WarnTruncateSource="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug" UseMkl="mklParallel"/>
VisualStudio/CAMB_devel.vfproj:				<Tool Name="VFLinkerTool" LinkIncremental="linkIncrementalNo" SuppressStartupBanner="true" GenerateDebugInformation="true" SubSystem="subSystemConsole" StackReserveSize="100000000"/>
VisualStudio/CAMB_devel.vfproj:				<Tool Name="VFManifestTool" SuppressStartupBanner="true"/></Configuration>
VisualStudio/CAMB_devel.vfproj:		<Configuration Name="Release|x64" CommandArguments="params.ini" WorkingDirectory="../">
VisualStudio/CAMB_devel.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" Preprocess="preprocessYes" PreprocessorDefinitions="FISHER" OpenMP="OpenMPParallelCode" ErrorLimit="4" UseMkl="mklParallel"/>
VisualStudio/CAMB_devel.vfproj:				<Tool Name="VFManifestTool" SuppressStartupBanner="true"/></Configuration></Configurations>
VisualStudio/CAMBLib.vfproj:<?xml version="1.0" encoding="UTF-8"?>
VisualStudio/CAMBLib.vfproj:<VisualStudioProject ProjectType="typeStaticLibrary" ProjectCreator="Intel Fortran" Keyword="Static Library" Version="11.0" ProjectIdGuid="{C7D790F6-3574-43A1-A5E1-1E6FC5478F95}">
VisualStudio/CAMBLib.vfproj:	<Configurations>
VisualStudio/CAMBLib.vfproj:		<Configuration Name="Debug|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/CAMBLib.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug"/>
VisualStudio/CAMBLib.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/CAMBLib.vfproj:		<Configuration Name="Release|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/CAMBLib.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/CAMBLib.vfproj:		<Configuration Name="Debug|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/CAMBLib.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" HeapArrays="1" Preprocess="preprocessYes" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug"/>
VisualStudio/CAMBLib.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/CAMBLib.vfproj:		<Configuration Name="Release|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/CAMBLib.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration></Configurations>
VisualStudio/CAMBLib.vfproj:		<File RelativePath="..\equations.f90"/>
VisualStudio/CAMBLib.vfproj:		<File RelativePath="..\reionization.f90"/>
VisualStudio/CAMBLib_ppf.vfproj:<?xml version="1.0" encoding="UTF-8"?>
VisualStudio/CAMBLib_ppf.vfproj:<VisualStudioProject ProjectType="typeStaticLibrary" ProjectCreator="Intel Fortran" Keyword="Static Library" Version="11.0" ProjectIdGuid="{C7D790F6-3574-43A1-A5E1-1E6FC5478F95}">
VisualStudio/CAMBLib_ppf.vfproj:	<Configurations>
VisualStudio/CAMBLib_ppf.vfproj:		<Configuration Name="Debug|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/CAMBLib_ppf.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug"/>
VisualStudio/CAMBLib_ppf.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/CAMBLib_ppf.vfproj:		<Configuration Name="Release|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/CAMBLib_ppf.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/CAMBLib_ppf.vfproj:		<Configuration Name="Debug|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/CAMBLib_ppf.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" Traceback="true" NullPointerCheck="true" BoundsCheck="true" UninitializedVariablesCheck="true" RuntimeLibrary="rtMultiThreadedDebug"/>
VisualStudio/CAMBLib_ppf.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/CAMBLib_ppf.vfproj:		<Configuration Name="Release|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/CAMBLib_ppf.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/CAMBLib_ppf.vfproj:		<Configuration Name="DebugMPI|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/CAMBLib_ppf.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug"/>
VisualStudio/CAMBLib_ppf.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/CAMBLib_ppf.vfproj:		<Configuration Name="DebugMPI|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/CAMBLib_ppf.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" Traceback="true" BoundsCheck="true" RuntimeLibrary="rtMultiThreadedDebug"/>
VisualStudio/CAMBLib_ppf.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration></Configurations>
VisualStudio/CAMBLib_ppf.vfproj:		<File RelativePath="..\equations_ppf.f90"/>
VisualStudio/CAMBLib_ppf.vfproj:		<File RelativePath="..\reionization.f90"/>
VisualStudio/MatrixDouble.vfproj:<?xml version="1.0" encoding="UTF-8"?>
VisualStudio/MatrixDouble.vfproj:<VisualStudioProject ProjectType="typeStaticLibrary" ProjectCreator="Intel Fortran" Keyword="Static Library" Version="11.0" ProjectIdGuid="{9A850B68-FC7B-42F7-BB78-C4C38EF90B25}">
VisualStudio/MatrixDouble.vfproj:	<Configurations>
VisualStudio/MatrixDouble.vfproj:		<Configuration Name="Debug|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug" UseMkl="mklParallel"/>
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/MatrixDouble.vfproj:		<Configuration Name="Release|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" UseProcessorExtensions="codeExclusivelyHost" Preprocess="preprocessYes" UseMkl="mklParallel"/>
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/MatrixDouble.vfproj:		<Configuration Name="Debug|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" OpenMP="OpenMPParallelCode" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug" UseMkl="mklParallel"/>
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/MatrixDouble.vfproj:		<Configuration Name="Release|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/MatrixDouble.vfproj:		<Configuration Name="DebugMPI|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug" UseMkl="mklParallel"/>
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/MatrixDouble.vfproj:		<Configuration Name="DebugMPI|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" OpenMP="OpenMPParallelCode" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug" UseMkl="mklParallel"/>
VisualStudio/MatrixDouble.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration></Configurations>
VisualStudio/MatrixSingle.vfproj:<?xml version="1.0" encoding="UTF-8"?>
VisualStudio/MatrixSingle.vfproj:<VisualStudioProject ProjectType="typeStaticLibrary" ProjectCreator="Intel Fortran" Keyword="Static Library" Version="11.0" ProjectIdGuid="{9A850B68-FC7B-42F7-BB78-C4C38EF90B25}">
VisualStudio/MatrixSingle.vfproj:	<Configurations>
VisualStudio/MatrixSingle.vfproj:		<Configuration Name="Debug|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/MatrixSingle.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" PreprocessorDefinitions="MATRIX_SINGLE" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug" UseMkl="mklParallel"/>
VisualStudio/MatrixSingle.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/MatrixSingle.vfproj:		<Configuration Name="Release|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/MatrixSingle.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" UseProcessorExtensions="codeExclusivelyHost" Preprocess="preprocessYes" PreprocessorDefinitions="MATRIX_SINGLE" UseMkl="mklParallel"/>
VisualStudio/MatrixSingle.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/MatrixSingle.vfproj:		<Configuration Name="Debug|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/MatrixSingle.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" PreprocessorDefinitions="MATRIX_SINGLE" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug" UseMkl="mklParallel"/>
VisualStudio/MatrixSingle.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/MatrixSingle.vfproj:		<Configuration Name="Release|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/MatrixSingle.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" UseProcessorExtensions="codeExclusivelyHost" Preprocess="preprocessYes" PreprocessorDefinitions="MATRIX_SINGLE" UseMkl="mklParallel"/>
VisualStudio/MatrixSingle.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration></Configurations>
VisualStudio/SharedObj.vfproj:<?xml version="1.0" encoding="UTF-8"?>
VisualStudio/SharedObj.vfproj:<VisualStudioProject ProjectType="typeStaticLibrary" ProjectCreator="Intel Fortran" Keyword="Static Library" Version="11.0" ProjectIdGuid="{C7D790F6-3574-43A1-A5E1-1E6FC5478F95}">
VisualStudio/SharedObj.vfproj:	<Configurations>
VisualStudio/SharedObj.vfproj:		<Configuration Name="Debug|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/SharedObj.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug"/>
VisualStudio/SharedObj.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/SharedObj.vfproj:		<Configuration Name="Release|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/SharedObj.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/SharedObj.vfproj:		<Configuration Name="Debug|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/SharedObj.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" OpenMP="OpenMPParallelCode" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug"/>
VisualStudio/SharedObj.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/SharedObj.vfproj:		<Configuration Name="Release|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/SharedObj.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/SharedObj.vfproj:		<Configuration Name="DebugMPI|Win32" ConfigurationType="typeStaticLibrary">
VisualStudio/SharedObj.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug"/>
VisualStudio/SharedObj.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration>
VisualStudio/SharedObj.vfproj:		<Configuration Name="DebugMPI|x64" ConfigurationType="typeStaticLibrary">
VisualStudio/SharedObj.vfproj:				<Tool Name="VFFortranCompilerTool" SuppressStartupBanner="true" DebugInformationFormat="debugEnabled" Optimization="optimizeDisabled" Preprocess="preprocessYes" OpenMP="OpenMPParallelCode" WarnInterfaces="true" Traceback="true" BoundsCheck="true" StackFrameCheck="true" RuntimeLibrary="rtMultiThreadedDebug"/>
VisualStudio/SharedObj.vfproj:				<Tool Name="VFPostBuildEventTool"/></Configuration></Configurations>
writefits.f90:  CHARACTER(LEN=80), DIMENSION(1:120) :: header
writefits.f90:  real, allocatable, dimension (:,:) :: clout,allcl
writefits.f90:  !HealPix 1.2 uses E-B conventions
writefits.f90:  if (CP%OutputNormalization >=2) then
writefits.f90:  call add_card(header,'VERSION',version,     'Version of the simulation software')
writefits.f90:  call add_card(header,'POLAR',.true.,'Polarisation included (True/False)')
writefits.f90:  call add_card(header,'POLNORM','CMBFAST','Uses E-B conventions')
writefits.f90:     call add_card(header,'TTYPE2', 'E-mode C_l','ELECTRIC polarisation C(l)')
writefits.f90:     call add_card(header,'TTYPE3', 'B-mode C_l','MAGNETIC polarisation C(l)')
writefits.f90: call add_card(header,'HELFRACT',CP%yhe, 'Helium fraction')
writefits.f90: call add_card(header,'OPTDLSS',CP%Reion%optical_depth, 'reionisation optical depth')
writefits.f90: call add_card(header,'IONFRACT',CP%Reion%fraction, 'ionisation fraction')
writefits.f90: call add_card(header,'ZREION',CP%reion%redshift, 'reionisation redshift')
writefits.f90: call add_card(header,'INITFLAG',CP%Scalar_initial_condition, 'initial condition flag') 
writefits.f90: call add_card(header,'PRECIS',AccuracyBoost, 'Relative computation accuracy') 
writefits.f90: call add_card(header,'EQS_FILE',Eqns_name, 'Gauge-dependent and background equations') 
